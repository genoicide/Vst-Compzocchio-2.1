; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gzsetparams
PUBLIC	_gzwrite
PUBLIC	_gzprintf
PUBLIC	_gzputs
PUBLIC	_gzputc
PUBLIC	_gzflush
PUBLIC	_gzclose_w
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
EXTRN	__vsnprintf:PROC
EXTRN	_deflate:PROC
EXTRN	_deflateEnd:PROC
EXTRN	_deflateReset:PROC
EXTRN	_deflateParams:PROC
EXTRN	_deflateInit2_:PROC
EXTRN	_strerror:PROC
EXTRN	__errno:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_close:PROC
EXTRN	_write:PROC
EXTRN	_gz_error:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gz_zero
_TEXT	SEGMENT
_first$1$ = 8						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 4
_gz_zero PROC						; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 115  :     int first;
; 116  :     unsigned n;
; 117  :     z_streamp strm = &(state->strm);

  00004	8b 7d 08	 mov	 edi, DWORD PTR _state$[ebp]

; 118  : 
; 119  :     /* consume whatever's left in the input buffer */
; 120  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00007	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0
  0000b	74 15		 je	 SHORT $LN5@gz_zero
  0000d	6a 00		 push	 0
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _gz_comp
  00015	83 c4 08	 add	 esp, 8
  00018	83 f8 ff	 cmp	 eax, -1
  0001b	75 05		 jne	 SHORT $LN5@gz_zero

; 121  :         return -1;

  0001d	0b c0		 or	 eax, eax
  0001f	5f		 pop	 edi

; 140  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN5@gz_zero:
  00022	53		 push	 ebx

; 122  : 
; 123  :     /* compress len zeros (len guaranteed > 0) */
; 124  :     first = 1;
; 125  :     while (len) {

  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	56		 push	 esi
  0002c	89 45 08	 mov	 DWORD PTR _first$1$[ebp], eax
  0002f	85 db		 test	 ebx, ebx
  00031	74 4d		 je	 SHORT $LN3@gz_zero
$LL4@gz_zero:

; 126  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 127  :             (unsigned)len : state->size;

  00033	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00036	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  0003c	77 04		 ja	 SHORT $LN9@gz_zero
  0003e	3b f3		 cmp	 esi, ebx
  00040	7e 02		 jle	 SHORT $LN10@gz_zero
$LN9@gz_zero:
  00042	8b f3		 mov	 esi, ebx
$LN10@gz_zero:

; 128  :         if (first) {

  00044	85 c0		 test	 eax, eax
  00046	74 15		 je	 SHORT $LN2@gz_zero

; 129  :             memset(state->in, 0, n);

  00048	56		 push	 esi
  00049	6a 00		 push	 0
  0004b	ff 77 18	 push	 DWORD PTR [edi+24]
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  :             first = 0;

  00056	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _first$1$[ebp], 0
$LN2@gz_zero:

; 131  :         }
; 132  :         strm->avail_in = n;

  0005d	89 77 58	 mov	 DWORD PTR [edi+88], esi

; 133  :         strm->next_in = state->in;

  00060	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 134  :         state->pos += n;
; 135  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00063	6a 00		 push	 0
  00065	89 47 54	 mov	 DWORD PTR [edi+84], eax
  00068	01 77 0c	 add	 DWORD PTR [edi+12], esi
  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 _gz_comp
  00071	83 c4 08	 add	 esp, 8
  00074	83 f8 ff	 cmp	 eax, -1
  00077	74 0e		 je	 SHORT $LN12@gz_zero

; 137  :         len -= n;

  00079	8b 45 08	 mov	 eax, DWORD PTR _first$1$[ebp]
  0007c	2b de		 sub	 ebx, esi
  0007e	75 b3		 jne	 SHORT $LL4@gz_zero
$LN3@gz_zero:
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx

; 138  :     }
; 139  :     return 0;

  00082	33 c0		 xor	 eax, eax
  00084	5f		 pop	 edi

; 140  : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN12@gz_zero:
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 136  :             return -1;

  00089	83 c8 ff	 or	 eax, -1
  0008c	5f		 pop	 edi

; 140  : }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_gz_zero ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gz_comp
_TEXT	SEGMENT
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);

  00005	8b 7d 08	 mov	 edi, DWORD PTR _state$[ebp]

; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  00008	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0000c	8d 77 54	 lea	 esi, DWORD PTR [edi+84]
  0000f	75 14		 jne	 SHORT $LN12@gz_comp
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 _gz_init
  00017	83 c4 04	 add	 esp, 4
  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	75 06		 jne	 SHORT $LN12@gz_comp

; 69   :         return -1;

  0001f	5f		 pop	 edi
  00020	0b c0		 or	 eax, eax
  00022	5e		 pop	 esi

; 108  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
$LN12@gz_comp:

; 70   : 
; 71   :     /* run deflate() on provided input until it produces no more output */
; 72   :     ret = Z_OK;

  00025	33 c0		 xor	 eax, eax
  00027	53		 push	 ebx
$LN20@gz_comp:

; 73   :     do {
; 74   :         /* write out current buffer contents if full, or if flushing, but if
; 75   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 76   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 77   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00028	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  0002f	74 0e		 je	 SHORT $LN6@gz_comp
  00031	85 c9		 test	 ecx, ecx
  00033	74 44		 je	 SHORT $LN8@gz_comp
  00035	83 f9 04	 cmp	 ecx, 4
  00038	75 05		 jne	 SHORT $LN6@gz_comp
  0003a	83 f8 01	 cmp	 eax, 1
  0003d	75 3a		 jne	 SHORT $LN8@gz_comp
$LN6@gz_comp:

; 78   :             have = (unsigned)(strm->next_out - state->next);

  0003f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00042	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00045	2b d8		 sub	 ebx, eax

; 79   :             if (have && ((got = write(state->fd, state->next, have)) < 0 ||
; 80   :                          (unsigned)got != have)) {

  00047	74 18		 je	 SHORT $LN5@gz_comp
  00049	53		 push	 ebx
  0004a	50		 push	 eax
  0004b	ff 77 04	 push	 DWORD PTR [edi+4]
  0004e	e8 00 00 00 00	 call	 _write
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	85 c0		 test	 eax, eax
  00058	78 4c		 js	 SHORT $LN4@gz_comp
  0005a	3b c3		 cmp	 eax, ebx
  0005c	75 48		 jne	 SHORT $LN4@gz_comp
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
$LN5@gz_comp:

; 82   :                 return -1;
; 83   :             }
; 84   :             if (strm->avail_out == 0) {

  00061	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00065	75 0c		 jne	 SHORT $LN3@gz_comp

; 85   :                 strm->avail_out = state->size;

  00067	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0006a	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 86   :                 strm->next_out = state->out;

  0006d	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00070	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN3@gz_comp:

; 87   :             }
; 88   :             state->next = strm->next_out;

  00073	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00076	89 47 20	 mov	 DWORD PTR [edi+32], eax
$LN8@gz_comp:

; 89   :         }
; 90   : 
; 91   :         /* compress */
; 92   :         have = strm->avail_out;

  00079	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 93   :         ret = deflate(strm, flush);

  0007c	51		 push	 ecx
  0007d	56		 push	 esi
  0007e	e8 00 00 00 00	 call	 _deflate
  00083	83 c4 08	 add	 esp, 8

; 94   :         if (ret == Z_STREAM_ERROR) {

  00086	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  00089	74 3b		 je	 SHORT $LN17@gz_comp

; 98   :         }
; 99   :         have -= strm->avail_out;

  0008b	2b 5e 10	 sub	 ebx, DWORD PTR [esi+16]

; 100  :     } while (have);

  0008e	75 98		 jne	 SHORT $LN20@gz_comp

; 101  : 
; 102  :     /* if that completed a deflate stream, allow another to start */
; 103  :     if (flush == Z_FINISH)

  00090	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00094	75 09		 jne	 SHORT $LN1@gz_comp

; 104  :         deflateReset(strm);

  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 _deflateReset
  0009c	83 c4 04	 add	 esp, 4
$LN1@gz_comp:

; 105  : 
; 106  :     /* all done, no errors */
; 107  :     return 0;

  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi
  000a1	33 c0		 xor	 eax, eax
  000a3	5e		 pop	 esi

; 108  : }

  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN4@gz_comp:

; 81   :                 gz_error(state, Z_ERRNO, zstrerror());

  000a6	e8 00 00 00 00	 call	 __errno
  000ab	ff 30		 push	 DWORD PTR [eax]
  000ad	e8 00 00 00 00	 call	 _strerror
  000b2	50		 push	 eax
  000b3	6a ff		 push	 -1
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 _gz_error
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 97   :             return -1;

  000be	83 c8 ff	 or	 eax, -1
  000c1	5b		 pop	 ebx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi

; 108  : }

  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN17@gz_comp:

; 95   :             gz_error(state, Z_STREAM_ERROR,
; 96   :                       "internal error: deflate stream corrupt");

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  000cb	6a fe		 push	 -2			; fffffffeH
  000cd	57		 push	 edi
  000ce	e8 00 00 00 00	 call	 _gz_error
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   :             return -1;

  000d6	83 c8 ff	 or	 eax, -1
  000d9	5b		 pop	 ebx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi

; 108  : }

  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_gz_comp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]
  00007	56		 push	 esi

; 20   : 
; 21   :     /* allocate input and output buffers */
; 22   :     state->in = malloc(state->want);

  00008	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _malloc
  00012	8b f8		 mov	 edi, eax

; 23   :     state->out = malloc(state->want);

  00014	56		 push	 esi
  00015	89 7b 18	 mov	 DWORD PTR [ebx+24], edi
  00018	e8 00 00 00 00	 call	 _malloc
  0001d	83 c4 08	 add	 esp, 8
  00020	89 43 1c	 mov	 DWORD PTR [ebx+28], eax

; 24   :     if (state->in == NULL || state->out == NULL) {

  00023	85 ff		 test	 edi, edi
  00025	74 75		 je	 SHORT $LN4@gz_init
  00027	85 c0		 test	 eax, eax
  00029	74 7e		 je	 SHORT $LN3@gz_init

; 31   :     }
; 32   : 
; 33   :     /* allocate deflate memory, set up for gzip compression */
; 34   :     strm->zalloc = Z_NULL;
; 35   :     strm->zfree = Z_NULL;
; 36   :     strm->opaque = Z_NULL;
; 37   :     ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 38   :                        15 + 16, 8, state->strategy);

  0002b	6a 38		 push	 56			; 00000038H
  0002d	8d 73 54	 lea	 esi, DWORD PTR [ebx+84]
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45?$AA@
  00035	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0003c	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  0004a	ff 73 40	 push	 DWORD PTR [ebx+64]
  0004d	6a 08		 push	 8
  0004f	6a 1f		 push	 31			; 0000001fH
  00051	6a 08		 push	 8
  00053	ff 73 3c	 push	 DWORD PTR [ebx+60]
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _deflateInit2_
  0005c	83 c4 20	 add	 esp, 32			; 00000020H

; 39   :     if (ret != Z_OK) {

  0005f	85 c0		 test	 eax, eax
  00061	74 20		 je	 SHORT $LN1@gz_init

; 40   :         free(state->in);

  00063	ff 73 18	 push	 DWORD PTR [ebx+24]
  00066	e8 00 00 00 00	 call	 _free

; 41   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00070	6a fc		 push	 -4			; fffffffcH
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 _gz_error
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	83 c8 ff	 or	 eax, -1
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 53   : }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN1@gz_init:

; 42   :         return -1;
; 43   :     }
; 44   : 
; 45   :     /* mark state as initialized */
; 46   :     state->size = state->want;

  00083	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00086	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 47   : 
; 48   :     /* initialize write buffer */
; 49   :     strm->avail_out = state->size;

  00089	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 50   :     strm->next_out = state->out;

  0008c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0008f	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00092	5f		 pop	 edi

; 51   :     state->next = strm->next_out;

  00093	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00096	5e		 pop	 esi

; 52   :     return 0;

  00097	33 c0		 xor	 eax, eax
  00099	5b		 pop	 ebx

; 53   : }

  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN4@gz_init:

; 25   :         if (state->out != NULL)

  0009c	85 c0		 test	 eax, eax
  0009e	74 09		 je	 SHORT $LN3@gz_init

; 26   :             free(state->out);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _free
  000a6	83 c4 04	 add	 esp, 4
$LN3@gz_init:

; 27   :         if (state->in != NULL)

  000a9	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  000ac	85 c0		 test	 eax, eax
  000ae	74 09		 je	 SHORT $LN2@gz_init

; 28   :             free(state->in);

  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _free
  000b6	83 c4 04	 add	 esp, 4
$LN2@gz_init:

; 29   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000be	6a fc		 push	 -4			; fffffffcH
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 _gz_error
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30   :         return -1;

  000c9	83 c8 ff	 or	 eax, -1
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx

; 53   : }

  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_gz_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzclose_w
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_w PROC						; COMDAT

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 503  :     int ret = 0;
; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure */
; 507  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	85 f6		 test	 esi, esi
  0000c	75 09		 jne	 SHORT $LN3@gzclose_w
$LN6@gzclose_w:
  0000e	5f		 pop	 edi

; 508  :         return Z_STREAM_ERROR;

  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00014	5e		 pop	 esi

; 531  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN3@gzclose_w:

; 509  :     state = (gz_statep)file;
; 510  : 
; 511  :     /* check that we're writing */
; 512  :     if (state->mode != GZ_WRITE)

  00017	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  0001d	75 ef		 jne	 SHORT $LN6@gzclose_w

; 513  :         return Z_STREAM_ERROR;
; 514  : 
; 515  :     /* check for seek request */
; 516  :     if (state->seek) {

  0001f	39 7e 48	 cmp	 DWORD PTR [esi+72], edi
  00022	74 11		 je	 SHORT $LN1@gzclose_w

; 517  :         state->seek = 0;
; 518  :         ret += gz_zero(state, state->skip);

  00024	ff 76 44	 push	 DWORD PTR [esi+68]
  00027	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _gz_zero
  00030	83 c4 08	 add	 esp, 8
  00033	8b f8		 mov	 edi, eax
$LN1@gzclose_w:

; 519  :     }
; 520  : 
; 521  :     /* flush, free memory, and close file */
; 522  :     ret += gz_comp(state, Z_FINISH);

  00035	6a 04		 push	 4
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _gz_comp

; 523  :     (void)deflateEnd(&(state->strm));

  0003d	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  00040	51		 push	 ecx
  00041	03 f8		 add	 edi, eax
  00043	e8 00 00 00 00	 call	 _deflateEnd

; 524  :     free(state->out);

  00048	ff 76 1c	 push	 DWORD PTR [esi+28]
  0004b	e8 00 00 00 00	 call	 _free

; 525  :     free(state->in);

  00050	ff 76 18	 push	 DWORD PTR [esi+24]
  00053	e8 00 00 00 00	 call	 _free

; 526  :     gz_error(state, Z_OK, NULL);

  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 _gz_error

; 527  :     free(state->path);

  00062	ff 76 08	 push	 DWORD PTR [esi+8]
  00065	e8 00 00 00 00	 call	 _free

; 528  :     ret += close(state->fd);

  0006a	ff 76 04	 push	 DWORD PTR [esi+4]
  0006d	e8 00 00 00 00	 call	 _close

; 529  :     free(state);

  00072	56		 push	 esi
  00073	03 f8		 add	 edi, eax
  00075	e8 00 00 00 00	 call	 _free
  0007a	83 c4 2c	 add	 esp, 44			; 0000002cH

; 530  :     return ret ? Z_ERRNO : Z_OK;

  0007d	f7 df		 neg	 edi
  0007f	1b ff		 sbb	 edi, edi
  00081	8b c7		 mov	 eax, edi
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 531  : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzflush
_TEXT	SEGMENT
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush PROC						; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 430  :     gz_statep state;
; 431  : 
; 432  :     /* get internal structure */
; 433  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN7@gzflush
$LN10@gzflush:

; 434  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 455  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN7@gzflush:

; 435  :     state = (gz_statep)file;
; 436  : 
; 437  :     /* check that we're writing and that there's no error */
; 438  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00017	75 3c		 jne	 SHORT $LN5@gzflush
  00019	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001d	75 36		 jne	 SHORT $LN5@gzflush

; 440  : 
; 441  :     /* check flush parameter */
; 442  :     if (flush < 0 || flush > Z_FINISH)

  0001f	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00023	77 30		 ja	 SHORT $LN5@gzflush

; 443  :         return Z_STREAM_ERROR;
; 444  : 
; 445  :     /* check for seek request */
; 446  :     if (state->seek) {

  00025	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00029	74 18		 je	 SHORT $LN1@gzflush

; 447  :         state->seek = 0;
; 448  :         if (gz_zero(state, state->skip) == -1)

  0002b	ff 76 44	 push	 DWORD PTR [esi+68]
  0002e	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 _gz_zero
  0003b	83 c4 08	 add	 esp, 8
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 c8		 je	 SHORT $LN10@gzflush
$LN1@gzflush:

; 449  :             return -1;
; 450  :     }
; 451  : 
; 452  :     /* compress remaining data with requested flush */
; 453  :     gz_comp(state, flush);

  00043	ff 75 0c	 push	 DWORD PTR _flush$[ebp]
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 _gz_comp

; 454  :     return state->err;

  0004c	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0004f	83 c4 08	 add	 esp, 8
  00052	5e		 pop	 esi

; 455  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN5@gzflush:

; 439  :         return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	5e		 pop	 esi

; 455  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_gzflush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzputc
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_c$ = 12						; size = 4
_gzputc	PROC						; COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 225  :     unsigned char buf[1];
; 226  :     gz_statep state;
; 227  :     z_streamp strm;
; 228  : 
; 229  :     /* get internal structure */
; 230  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 75		 je	 SHORT $LN6@gzputc

; 231  :         return -1;
; 232  :     state = (gz_statep)file;
; 233  :     strm = &(state->strm);
; 234  : 
; 235  :     /* check that we're writing and that there's no error */
; 236  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000b	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00011	75 6d		 jne	 SHORT $LN6@gzputc
  00013	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00017	75 67		 jne	 SHORT $LN6@gzputc

; 238  : 
; 239  :     /* check for seek request */
; 240  :     if (state->seek) {

  00019	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0001d	74 18		 je	 SHORT $LN4@gzputc

; 241  :         state->seek = 0;
; 242  :         if (gz_zero(state, state->skip) == -1)

  0001f	ff 76 44	 push	 DWORD PTR [esi+68]
  00022	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 _gz_zero
  0002f	83 c4 08	 add	 esp, 8
  00032	83 f8 ff	 cmp	 eax, -1
  00035	74 49		 je	 SHORT $LN6@gzputc
$LN4@gzputc:

; 243  :             return -1;
; 244  :     }
; 245  : 
; 246  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 247  :        initialized) */
; 248  :     if (strm->avail_in < state->size) {

  00037	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  0003a	3b 56 10	 cmp	 edx, DWORD PTR [esi+16]
  0003d	73 1c		 jae	 SHORT $LN3@gzputc

; 249  :         if (strm->avail_in == 0)

  0003f	85 d2		 test	 edx, edx
  00041	75 06		 jne	 SHORT $LN2@gzputc

; 250  :             strm->next_in = state->in;

  00043	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00046	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN2@gzputc:

; 251  :         strm->next_in[strm->avail_in++] = c;

  00049	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0004f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00052	ff 46 58	 inc	 DWORD PTR [esi+88]

; 252  :         state->pos++;

  00055	ff 46 0c	 inc	 DWORD PTR [esi+12]
  00058	5e		 pop	 esi

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN3@gzputc:
  0005b	53		 push	 ebx

; 253  :         return c;
; 254  :     }
; 255  : 
; 256  :     /* no room in buffer or not initialized, use gz_write() */
; 257  :     buf[0] = c;

  0005c	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]

; 258  :     if (gzwrite(file, buf, 1) != 1)

  0005f	6a 01		 push	 1
  00061	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  00064	50		 push	 eax
  00065	56		 push	 esi
  00066	88 5d 0b	 mov	 BYTE PTR _buf$[ebp], bl
  00069	e8 00 00 00 00	 call	 _gzwrite
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	83 c9 ff	 or	 ecx, -1
  00074	83 f8 01	 cmp	 eax, 1
  00077	0f 45 d9	 cmovne	 ebx, ecx
  0007a	8b c3		 mov	 eax, ebx
  0007c	5b		 pop	 ebx
  0007d	5e		 pop	 esi

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN6@gzputc:

; 237  :         return -1;

  00080	83 c8 ff	 or	 eax, -1
  00083	5e		 pop	 esi

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzputs
_TEXT	SEGMENT
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs	PROC						; COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 268  :     int ret;
; 269  :     unsigned len;
; 270  : 
; 271  :     /* write string */
; 272  :     len = (unsigned)strlen(str);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  0000c	8d 64 24 00	 npad	 4
$LL5@gzputs:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	46		 inc	 esi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL5@gzputs
  00017	2b f2		 sub	 esi, edx

; 273  :     ret = gzwrite(file, str, len);

  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	ff 75 08	 push	 DWORD PTR _file$[ebp]
  0001e	e8 00 00 00 00	 call	 _gzwrite
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  :     return ret == 0 && len != 0 ? -1 : ret;

  00026	85 c0		 test	 eax, eax
  00028	75 07		 jne	 SHORT $LN4@gzputs
  0002a	85 f6		 test	 esi, esi
  0002c	74 03		 je	 SHORT $LN4@gzputs
  0002e	83 c8 ff	 or	 eax, -1
$LN4@gzputs:
  00031	5e		 pop	 esi

; 275  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 283  :     int size, len;
; 284  :     gz_statep state;
; 285  :     z_streamp strm;
; 286  :     va_list va;
; 287  : 
; 288  :     /* get internal structure */
; 289  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN9@gzprintf

; 290  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 347  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN9@gzprintf:

; 291  :     state = (gz_statep)file;
; 292  :     strm = &(state->strm);
; 293  : 
; 294  :     /* check that we're writing and that there's no error */
; 295  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00017	75 1a		 jne	 SHORT $LN13@gzprintf
  00019	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001d	75 14		 jne	 SHORT $LN13@gzprintf

; 296  :         return 0;
; 297  : 
; 298  :     /* make sure we have some buffer space */
; 299  :     if (state->size == 0 && gz_init(state) == -1)

  0001f	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00023	75 13		 jne	 SHORT $LN6@gzprintf
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 _gz_init
  0002b	83 c4 04	 add	 esp, 4
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 05		 jne	 SHORT $LN6@gzprintf
$LN13@gzprintf:

; 300  :         return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 347  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN6@gzprintf:

; 301  : 
; 302  :     /* check for seek request */
; 303  :     if (state->seek) {

  00038	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0003c	74 18		 je	 SHORT $LN4@gzprintf

; 304  :         state->seek = 0;
; 305  :         if (gz_zero(state, state->skip) == -1)

  0003e	ff 76 44	 push	 DWORD PTR [esi+68]
  00041	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 _gz_zero
  0004e	83 c4 08	 add	 esp, 8
  00051	83 f8 ff	 cmp	 eax, -1
  00054	74 dd		 je	 SHORT $LN13@gzprintf
$LN4@gzprintf:

; 306  :             return 0;
; 307  :     }
; 308  : 
; 309  :     /* consume whatever's left in the input buffer */
; 310  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00056	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0005a	74 10		 je	 SHORT $LN3@gzprintf
  0005c	6a 00		 push	 0
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 _gz_comp
  00064	83 c4 08	 add	 esp, 8
  00067	83 f8 ff	 cmp	 eax, -1
  0006a	74 c7		 je	 SHORT $LN13@gzprintf
$LN3@gzprintf:

; 311  :         return 0;
; 312  : 
; 313  :     /* do the printf() into the input buffer, put length in len */
; 314  :     size = (int)(state->size);
; 315  :     state->in[size - 1] = 0;

  0006c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0006f	57		 push	 edi
  00070	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00073	c6 44 07 ff 00	 mov	 BYTE PTR [edi+eax-1], 0

; 316  :     va_start(va, format);
; 317  : #ifdef NO_vsnprintf
; 318  : #  ifdef HAS_vsprintf_void
; 319  :     (void)vsprintf(state->in, format, va);
; 320  :     va_end(va);
; 321  :     for (len = 0; len < size; len++)
; 322  :         if (state->in[len] == 0) break;
; 323  : #  else
; 324  :     len = vsprintf(state->in, format, va);
; 325  :     va_end(va);
; 326  : #  endif
; 327  : #else
; 328  : #  ifdef HAS_vsnprintf_void
; 329  :     (void)vsnprintf(state->in, size, format, va);
; 330  :     va_end(va);
; 331  :     len = strlen(state->in);
; 332  : #  else
; 333  :     len = vsnprintf((char *)(state->in), size, format, va);

  00078	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  0007b	50		 push	 eax
  0007c	ff 75 0c	 push	 DWORD PTR _format$[ebp]
  0007f	57		 push	 edi
  00080	ff 76 18	 push	 DWORD PTR [esi+24]
  00083	e8 00 00 00 00	 call	 __vsnprintf
  00088	8b d0		 mov	 edx, eax
  0008a	83 c4 10	 add	 esp, 16			; 00000010H

; 334  :     va_end(va);
; 335  : #  endif
; 336  : #endif
; 337  : 
; 338  :     /* check that printf() results fit in buffer */
; 339  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  0008d	85 d2		 test	 edx, edx
  0008f	7e 1f		 jle	 SHORT $LN1@gzprintf
  00091	3b d7		 cmp	 edx, edi
  00093	7d 1b		 jge	 SHORT $LN1@gzprintf
  00095	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00098	80 7c 0f ff 00	 cmp	 BYTE PTR [edi+ecx-1], 0
  0009d	75 11		 jne	 SHORT $LN1@gzprintf

; 341  : 
; 342  :     /* update buffer and position, defer compression until needed */
; 343  :     strm->avail_in = (unsigned)len;
; 344  :     strm->next_in = state->in;

  0009f	8b c1		 mov	 eax, ecx
  000a1	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000a4	89 56 58	 mov	 DWORD PTR [esi+88], edx

; 345  :     state->pos += len;

  000a7	01 56 0c	 add	 DWORD PTR [esi+12], edx
  000aa	5f		 pop	 edi

; 346  :     return len;

  000ab	8b c2		 mov	 eax, edx
  000ad	5e		 pop	 esi

; 347  : }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN1@gzprintf:
  000b0	5f		 pop	 edi

; 340  :         return 0;

  000b1	33 c0		 xor	 eax, eax
  000b3	5e		 pop	 esi

; 347  : }

  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzwrite
_TEXT	SEGMENT
_put$1$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf$1$ = 16						; size = 4
_len$ = 16						; size = 4
_gzwrite PROC						; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 148  :     unsigned put = len;

  00005	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00008	56		 push	 esi

; 149  :     unsigned n;
; 150  :     gz_statep state;
; 151  :     z_streamp strm;
; 152  : 
; 153  :     /* get internal structure */
; 154  :     if (file == NULL)

  00009	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000c	89 5d fc	 mov	 DWORD PTR _put$1$[ebp], ebx
  0000f	85 f6		 test	 esi, esi
  00011	74 22		 je	 SHORT $LN28@gzwrite

; 155  :         return 0;
; 156  :     state = (gz_statep)file;
; 157  :     strm = &(state->strm);
; 158  : 
; 159  :     /* check that we're writing and that there's no error */
; 160  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00019	75 1a		 jne	 SHORT $LN28@gzwrite
  0001b	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001f	75 14		 jne	 SHORT $LN28@gzwrite

; 161  :         return 0;
; 162  : 
; 163  :     /* since an int is returned, make sure len fits in one, otherwise return
; 164  :        with an error (this avoids the flaw in the interface) */
; 165  :     if ((int)len < 0) {

  00021	85 db		 test	 ebx, ebx
  00023	79 18		 jns	 SHORT $LN26@gzwrite

; 166  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0002a	6a fb		 push	 -5			; fffffffbH
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 _gz_error
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@gzwrite:

; 167  :         return 0;

  00035	5e		 pop	 esi
  00036	33 c0		 xor	 eax, eax
  00038	5b		 pop	 ebx

; 218  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN26@gzwrite:

; 168  :     }
; 169  : 
; 170  :     /* if len is zero, avoid unnecessary operations */
; 171  :     if (len == 0)

  0003d	74 f6		 je	 SHORT $LN28@gzwrite

; 172  :         return 0;
; 173  : 
; 174  :     /* allocate memory if this is the first time through */
; 175  :     if (state->size == 0 && gz_init(state) == -1)

  0003f	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00043	75 0e		 jne	 SHORT $LN13@gzwrite
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 _gz_init
  0004b	83 c4 04	 add	 esp, 4
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	74 e2		 je	 SHORT $LN28@gzwrite
$LN13@gzwrite:

; 176  :         return 0;
; 177  : 
; 178  :     /* check for seek request */
; 179  :     if (state->seek) {

  00053	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00057	74 18		 je	 SHORT $LN11@gzwrite

; 180  :         state->seek = 0;
; 181  :         if (gz_zero(state, state->skip) == -1)

  00059	ff 76 44	 push	 DWORD PTR [esi+68]
  0005c	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 _gz_zero
  00069	83 c4 08	 add	 esp, 8
  0006c	83 f8 ff	 cmp	 eax, -1
  0006f	74 c4		 je	 SHORT $LN28@gzwrite
$LN11@gzwrite:
  00071	57		 push	 edi

; 182  :             return 0;
; 183  :     }
; 184  : 
; 185  :     /* for small len, copy to input buffer, otherwise compress directly */
; 186  :     if (len < state->size) {

  00072	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00075	73 59		 jae	 SHORT $LN10@gzwrite
  00077	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0007a	89 55 10	 mov	 DWORD PTR _buf$1$[ebp], edx
  0007d	8d 49 00	 npad	 3
$LL9@gzwrite:

; 187  :         /* copy to input buffer, compress when full */
; 188  :         do {
; 189  :             if (strm->avail_in == 0)

  00080	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00083	85 c9		 test	 ecx, ecx
  00085	75 06		 jne	 SHORT $LN6@gzwrite

; 190  :                 strm->next_in = state->in;

  00087	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0008a	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN6@gzwrite:

; 191  :             n = state->size - strm->avail_in;

  0008d	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 192  :             if (n > len)
; 193  :                 n = len;
; 194  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  00090	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00093	2b f9		 sub	 edi, ecx
  00095	3b fb		 cmp	 edi, ebx
  00097	0f 47 fb	 cmova	 edi, ebx
  0009a	57		 push	 edi
  0009b	52		 push	 edx
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _memcpy

; 195  :             strm->avail_in += n;

  000a4	01 7e 58	 add	 DWORD PTR [esi+88], edi

; 196  :             state->pos += n;

  000a7	01 7e 0c	 add	 DWORD PTR [esi+12], edi

; 197  :             buf = (char *)buf + n;

  000aa	01 7d 10	 add	 DWORD PTR _buf$1$[ebp], edi
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :             len -= n;

  000b0	2b df		 sub	 ebx, edi

; 199  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000b2	74 4e		 je	 SHORT $LN1@gzwrite
  000b4	6a 00		 push	 0
  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 _gz_comp
  000bc	8b 55 10	 mov	 edx, DWORD PTR _buf$1$[ebp]
  000bf	83 c4 08	 add	 esp, 8
  000c2	83 f8 ff	 cmp	 eax, -1
  000c5	75 b9		 jne	 SHORT $LL9@gzwrite
$LN27@gzwrite:
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 200  :                 return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx

; 218  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN10@gzwrite:

; 201  :         } while (len);
; 202  :     }
; 203  :     else {
; 204  :         /* consume whatever's left in the input buffer */
; 205  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000d0	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000d4	74 10		 je	 SHORT $LN2@gzwrite
  000d6	6a 00		 push	 0
  000d8	56		 push	 esi
  000d9	e8 00 00 00 00	 call	 _gz_comp
  000de	83 c4 08	 add	 esp, 8
  000e1	83 f8 ff	 cmp	 eax, -1
  000e4	74 e1		 je	 SHORT $LN27@gzwrite
$LN2@gzwrite:

; 206  :             return 0;
; 207  : 
; 208  :         /* directly compress user buffer to file */
; 209  :         strm->avail_in = len;
; 210  :         strm->next_in = (voidp)buf;

  000e6	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 211  :         state->pos += len;
; 212  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000e9	6a 00		 push	 0
  000eb	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  000ee	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000f1	01 5e 0c	 add	 DWORD PTR [esi+12], ebx
  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 _gz_comp
  000fa	83 c4 08	 add	 esp, 8
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	74 c5		 je	 SHORT $LN27@gzwrite
$LN1@gzwrite:

; 213  :             return 0;
; 214  :     }
; 215  : 
; 216  :     /* input was all buffered or compressed (put will fit in int) */
; 217  :     return (int)put;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _put$1$[ebp]
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 218  : }

  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_gzwrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzwrite.c
;	COMDAT _gzsetparams
_TEXT	SEGMENT
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams PROC					; COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 463  :     gz_statep state;
; 464  :     z_streamp strm;
; 465  : 
; 466  :     /* get internal structure */
; 467  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN8@gzsetparam
$LN6@gzsetparam:

; 468  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 497  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN8@gzsetparam:

; 469  :     state = (gz_statep)file;
; 470  :     strm = &(state->strm);
; 471  : 
; 472  :     /* check that we're writing and that there's no error */
; 473  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00019	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
  0001c	75 ed		 jne	 SHORT $LN6@gzsetparam
  0001e	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00022	75 e7		 jne	 SHORT $LN6@gzsetparam

; 474  :         return Z_STREAM_ERROR;
; 475  : 
; 476  :     /* if no change is requested, then do nothing */
; 477  :     if (level == state->level && strategy == state->strategy)

  00024	53		 push	 ebx
  00025	8b 5d 0c	 mov	 ebx, DWORD PTR _level$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 10	 mov	 edi, DWORD PTR _strategy$[ebp]
  0002c	3b 5e 3c	 cmp	 ebx, DWORD PTR [esi+60]
  0002f	75 05		 jne	 SHORT $LN5@gzsetparam
  00031	3b 7e 40	 cmp	 edi, DWORD PTR [esi+64]
  00034	74 60		 je	 SHORT $LN15@gzsetparam
$LN5@gzsetparam:

; 478  :         return Z_OK;
; 479  : 
; 480  :     /* check for seek request */
; 481  :     if (state->seek) {

  00036	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0003a	74 22		 je	 SHORT $LN3@gzsetparam

; 482  :         state->seek = 0;
; 483  :         if (gz_zero(state, state->skip) == -1)

  0003c	ff 76 44	 push	 DWORD PTR [esi+68]
  0003f	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 _gz_zero
  0004c	83 c4 08	 add	 esp, 8
  0004f	83 f8 ff	 cmp	 eax, -1
  00052	75 07		 jne	 SHORT $LN12@gzsetparam

; 484  :             return -1;

  00054	5f		 pop	 edi
  00055	5b		 pop	 ebx
  00056	0b c0		 or	 eax, eax
  00058	5e		 pop	 esi

; 497  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN12@gzsetparam:
  0005b	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
$LN3@gzsetparam:

; 485  :     }
; 486  : 
; 487  :     /* change compression parameters for subsequent input */
; 488  :     if (state->size) {

  0005e	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00062	74 2c		 je	 SHORT $LN2@gzsetparam

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00064	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00068	74 1b		 je	 SHORT $LN1@gzsetparam
  0006a	6a 01		 push	 1
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 _gz_comp
  00072	83 c4 08	 add	 esp, 8
  00075	83 f8 ff	 cmp	 eax, -1
  00078	75 08		 jne	 SHORT $LN11@gzsetparam

; 491  :             return state->err;

  0007a	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0007d	5f		 pop	 edi
  0007e	5b		 pop	 ebx
  0007f	5e		 pop	 esi

; 497  : }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN11@gzsetparam:
  00082	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
$LN1@gzsetparam:

; 492  :         deflateParams(strm, level, strategy);

  00085	57		 push	 edi
  00086	53		 push	 ebx
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _deflateParams
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gzsetparam:

; 493  :     }
; 494  :     state->level = level;

  00090	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx

; 495  :     state->strategy = strategy;

  00093	89 7e 40	 mov	 DWORD PTR [esi+64], edi
$LN15@gzsetparam:

; 496  :     return Z_OK;

  00096	5f		 pop	 edi
  00097	5b		 pop	 ebx
  00098	33 c0		 xor	 eax, eax
  0009a	5e		 pop	 esi

; 497  : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_gzsetparams ENDP
_TEXT	ENDS
END
