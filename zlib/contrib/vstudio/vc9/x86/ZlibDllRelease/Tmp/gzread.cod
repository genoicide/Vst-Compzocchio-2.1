; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gzread
PUBLIC	_gzgets
PUBLIC	_gzgetc
PUBLIC	_gzungetc
PUBLIC	_gzdirect
PUBLIC	_gzclose_r
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	_inflate:PROC
EXTRN	_inflateEnd:PROC
EXTRN	_inflateReset:PROC
EXTRN	_crc32:PROC
EXTRN	_inflateInit2_:PROC
EXTRN	_memchr:PROC
EXTRN	_strerror:PROC
EXTRN	__errno:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_close:PROC
EXTRN	_read:PROC
EXTRN	_gz_error:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_skip
_TEXT	SEGMENT
_state$ = 8						; size = 4
_len$ = 12						; size = 4
_gz_skip PROC						; COMDAT

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	74 47		 je	 SHORT $LN6@gz_skip
  0000c	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  0000f	90		 npad	 1
$LL7@gz_skip:

; 338  :         /* skip over whatever is in output buffer */
; 339  :         if (state->have) {

  00010	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00013	85 c0		 test	 eax, eax
  00015	74 1e		 je	 SHORT $LN5@gz_skip

; 340  :             n = GT_OFF(state->have) || (z_off64_t)state->have > len ?
; 341  :                 (unsigned)len : state->have;

  00017	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0001c	77 06		 ja	 SHORT $LN11@gz_skip
  0001e	8b c8		 mov	 ecx, eax
  00020	3b c7		 cmp	 eax, edi
  00022	7e 02		 jle	 SHORT $LN12@gz_skip
$LN11@gz_skip:
  00024	8b cf		 mov	 ecx, edi
$LN12@gz_skip:

; 342  :             state->have -= n;
; 343  :             state->next += n;

  00026	01 4e 20	 add	 DWORD PTR [esi+32], ecx

; 344  :             state->pos += n;

  00029	01 4e 0c	 add	 DWORD PTR [esi+12], ecx
  0002c	2b c1		 sub	 eax, ecx
  0002e	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 345  :             len -= n;

  00031	2b f9		 sub	 edi, ecx
  00033	eb 1a		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 346  :         }
; 347  : 
; 348  :         /* output buffer empty -- return if we're at the end of the input */
; 349  :         else if (state->eof && state->strm.avail_in == 0)

  00035	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00039	74 06		 je	 SHORT $LN3@gz_skip
  0003b	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0003f	74 12		 je	 SHORT $LN6@gz_skip
$LN3@gz_skip:

; 350  :             break;
; 351  : 
; 352  :         /* need more data to skip -- load up output buffer */
; 353  :         else {
; 354  :             /* get more output, looking for header if required */
; 355  :             if (gz_make(state) == -1)

  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 _gz_make
  00047	83 c4 04	 add	 esp, 4
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	74 0a		 je	 SHORT $LN15@gz_skip
$LN1@gz_skip:

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  0004f	85 ff		 test	 edi, edi
  00051	75 bd		 jne	 SHORT $LL7@gz_skip
$LN6@gz_skip:
  00053	5f		 pop	 edi

; 357  :         }
; 358  :     return 0;

  00054	33 c0		 xor	 eax, eax
  00056	5e		 pop	 esi

; 359  : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN15@gz_skip:
  00059	5f		 pop	 edi

; 356  :                 return -1;

  0005a	83 c8 ff	 or	 eax, -1
  0005d	5e		 pop	 esi

; 359  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_gz_skip ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_make
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_make PROC						; COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 307  :     z_streamp strm = &(state->strm);

  00004	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]

; 308  : 
; 309  :     if (state->how == LOOK) {           /* look for gzip header */

  00007	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0000b	75 1a		 jne	 SHORT $LN6@gz_make

; 310  :         if (gz_head(state) == -1)

  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 _gz_head
  00013	83 c4 04	 add	 esp, 4
  00016	83 f8 ff	 cmp	 eax, -1
  00019	75 06		 jne	 SHORT $LN7@gz_make
$LN11@gz_make:

; 311  :             return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5e		 pop	 esi

; 327  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN7@gz_make:

; 312  :         if (state->have)                /* got some data from gz_head() */

  00021	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00025	75 4f		 jne	 SHORT $LN1@gz_make
$LN6@gz_make:

; 313  :             return 0;
; 314  :     }
; 315  :     if (state->how == COPY) {           /* straight copy */

  00027	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	75 26		 jne	 SHORT $LN5@gz_make

; 316  :         if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)

  0002f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00032	50		 push	 eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	03 c0		 add	 eax, eax
  00038	50		 push	 eax
  00039	ff 76 1c	 push	 DWORD PTR [esi+28]
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _gz_load
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 d1		 je	 SHORT $LN11@gz_make

; 317  :             return -1;
; 318  :         state->next = state->out;

  0004a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0004d	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 324  :             return -1;
; 325  :     }
; 326  :     return 0;

  00050	33 c0		 xor	 eax, eax
  00052	5e		 pop	 esi

; 327  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN5@gz_make:

; 319  :     }
; 320  :     else if (state->how == GZIP) {      /* decompress */

  00055	83 f8 02	 cmp	 eax, 2
  00058	75 1c		 jne	 SHORT $LN1@gz_make

; 321  :         strm->avail_out = state->size << 1;

  0005a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005d	03 c0		 add	 eax, eax
  0005f	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 322  :         strm->next_out = state->out;

  00062	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 323  :         if (gz_decomp(state) == -1)

  00065	56		 push	 esi
  00066	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00069	e8 00 00 00 00	 call	 _gz_decomp
  0006e	83 c4 04	 add	 esp, 4
  00071	83 f8 ff	 cmp	 eax, -1
  00074	74 a5		 je	 SHORT $LN11@gz_make
$LN1@gz_make:

; 324  :             return -1;
; 325  :     }
; 326  :     return 0;

  00076	33 c0		 xor	 eax, eax
  00078	5e		 pop	 esi

; 327  : }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_gz_make ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_decomp
_TEXT	SEGMENT
_len$ = -4						; size = 4
_had$1$ = 8						; size = 4
_crc$ = 8						; size = 4
_state$ = 8						; size = 4
_gz_decomp PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 236  :     int ret;
; 237  :     unsigned had;
; 238  :     unsigned long crc, len;
; 239  :     z_streamp strm = &(state->strm);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]
  00008	56		 push	 esi

; 240  : 
; 241  :     /* fill output buffer up to end of deflate stream */
; 242  :     had = strm->avail_out;

  00009	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0000c	57		 push	 edi
  0000d	8d 7b 54	 lea	 edi, DWORD PTR [ebx+84]
  00010	89 45 08	 mov	 DWORD PTR _had$1$[ebp], eax
$LL15@gz_decomp:

; 243  :     do {
; 244  :         /* get more input for inflate() */
; 245  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00013	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00017	75 1c		 jne	 SHORT $LN27@gz_decomp
  00019	53		 push	 ebx
  0001a	e8 00 00 00 00	 call	 _gz_avail
  0001f	83 c4 04	 add	 esp, 4
  00022	83 f8 ff	 cmp	 eax, -1
  00025	0f 84 4f 01 00
	00		 je	 $LN21@gz_decomp

; 246  :             return -1;
; 247  :         if (strm->avail_in == 0) {

  0002b	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0002f	0f 84 ac 00 00
	00		 je	 $LN22@gz_decomp
$LN27@gz_decomp:

; 249  :             return -1;
; 250  :         }
; 251  : 
; 252  :         /* decompress and handle errors */
; 253  :         ret = inflate(strm, Z_NO_FLUSH);

  00035	6a 00		 push	 0
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 _inflate
  0003d	8b f0		 mov	 esi, eax
  0003f	83 c4 08	 add	 esp, 8

; 254  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00042	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00045	0f 84 1f 01 00
	00		 je	 $LN9@gz_decomp
  0004b	83 fe 02	 cmp	 esi, 2
  0004e	0f 84 16 01 00
	00		 je	 $LN9@gz_decomp

; 258  :         }
; 259  :         if (ret == Z_MEM_ERROR) {

  00054	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00057	0f 84 f3 00 00
	00		 je	 $LN24@gz_decomp

; 261  :             return -1;
; 262  :         }
; 263  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  0005d	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00060	0f 84 c7 00 00
	00		 je	 $LN25@gz_decomp

; 266  :             return -1;
; 267  :         }
; 268  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00066	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0006a	74 05		 je	 SHORT $LN6@gz_decomp
  0006c	83 fe 01	 cmp	 esi, 1
  0006f	75 a2		 jne	 SHORT $LL15@gz_decomp
$LN6@gz_decomp:

; 269  : 
; 270  :     /* update available output and crc check value */
; 271  :     state->have = had - strm->avail_out;

  00071	8b 4d 08	 mov	 ecx, DWORD PTR _had$1$[ebp]
  00074	2b 4f 10	 sub	 ecx, DWORD PTR [edi+16]
  00077	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx

; 272  :     state->next = strm->next_out - state->have;

  0007a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0007d	2b c1		 sub	 eax, ecx

; 273  :     strm->adler = crc32(strm->adler, state->next, state->have);

  0007f	51		 push	 ecx
  00080	50		 push	 eax
  00081	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00084	ff 77 30	 push	 DWORD PTR [edi+48]
  00087	e8 00 00 00 00	 call	 _crc32
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 274  : 
; 275  :     /* check gzip trailer if at end of deflate stream */
; 276  :     if (ret == Z_STREAM_END) {

  00092	83 fe 01	 cmp	 esi, 1
  00095	0f 85 89 00 00
	00		 jne	 $LN5@gz_decomp

; 277  :         if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

  0009b	8d 45 08	 lea	 eax, DWORD PTR _crc$[ebp]
  0009e	50		 push	 eax
  0009f	53		 push	 ebx
  000a0	e8 00 00 00 00	 call	 _gz_next4
  000a5	83 c4 08	 add	 esp, 8
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	74 34		 je	 SHORT $LN22@gz_decomp
  000ad	8d 45 fc	 lea	 eax, DWORD PTR _len$[ebp]
  000b0	50		 push	 eax
  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 _gz_next4
  000b7	83 c4 08	 add	 esp, 8
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	74 22		 je	 SHORT $LN22@gz_decomp

; 278  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");
; 279  :             return -1;
; 280  :         }
; 281  :         if (crc != strm->adler) {

  000bf	8b 45 08	 mov	 eax, DWORD PTR _crc$[ebp]
  000c2	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  000c5	74 34		 je	 SHORT $LN2@gz_decomp

; 282  :             gz_error(state, Z_DATA_ERROR, "incorrect data check");

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  000cc	6a fd		 push	 -3			; fffffffdH
  000ce	53		 push	 ebx
  000cf	e8 00 00 00 00	 call	 _gz_error
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	83 c8 ff	 or	 eax, -1
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx

; 295  : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN22@gz_decomp:

; 248  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  000e6	6a fd		 push	 -3			; fffffffdH

; 255  :             gz_error(state, Z_STREAM_ERROR,
; 256  :                       "internal error: inflate stream corrupt");

  000e8	53		 push	 ebx
  000e9	e8 00 00 00 00	 call	 _gz_error
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  :             return -1;

  000f1	83 c8 ff	 or	 eax, -1
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 295  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN2@gz_decomp:

; 283  :             return -1;
; 284  :         }
; 285  :         if (len != (strm->total_out & 0xffffffffL)) {

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  000fe	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00101	74 1a		 je	 SHORT $LN1@gz_decomp

; 286  :             gz_error(state, Z_DATA_ERROR, "incorrect length check");

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  00108	6a fd		 push	 -3			; fffffffdH
  0010a	53		 push	 ebx
  0010b	e8 00 00 00 00	 call	 _gz_error
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
  00113	83 c8 ff	 or	 eax, -1
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 295  : }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
$LN1@gz_decomp:

; 287  :             return -1;
; 288  :         }
; 289  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

  0011d	c7 43 34 00 00
	00 00		 mov	 DWORD PTR [ebx+52], 0
$LN5@gz_decomp:
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;

  00126	33 c0		 xor	 eax, eax
  00128	5b		 pop	 ebx

; 295  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN25@gz_decomp:

; 264  :             gz_error(state, Z_DATA_ERROR,
; 265  :                       strm->msg == NULL ? "compressed data error" : strm->msg);

  0012d	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00130	85 c0		 test	 eax, eax
  00132	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  00137	0f 45 c8	 cmovne	 ecx, eax
  0013a	51		 push	 ecx
  0013b	6a fd		 push	 -3			; fffffffdH
  0013d	53		 push	 ebx
  0013e	e8 00 00 00 00	 call	 _gz_error
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
  00146	83 c8 ff	 or	 eax, -1
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 295  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
$LN24@gz_decomp:

; 260  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00155	6a fc		 push	 -4			; fffffffcH
  00157	53		 push	 ebx
  00158	e8 00 00 00 00	 call	 _gz_error
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 c8 ff	 or	 eax, -1
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx

; 295  : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
$LN9@gz_decomp:

; 255  :             gz_error(state, Z_STREAM_ERROR,
; 256  :                       "internal error: inflate stream corrupt");

  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  0016f	6a fe		 push	 -2			; fffffffeH
  00171	53		 push	 ebx
  00172	e8 00 00 00 00	 call	 _gz_error
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@gz_decomp:

; 257  :             return -1;

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	83 c8 ff	 or	 eax, -1
  0017f	5b		 pop	 ebx

; 295  : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_head
_TEXT	SEGMENT
_flags$1$ = 8						; size = 4
_state$ = 8						; size = 4
_gz_head PROC						; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 107  :     z_streamp strm = &(state->strm);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]
  00007	56		 push	 esi

; 108  :     int flags;
; 109  :     unsigned len;
; 110  : 
; 111  :     /* allocate read buffers and inflate memory */
; 112  :     if (state->size == 0) {

  00008	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  0000c	57		 push	 edi
  0000d	8d 7b 54	 lea	 edi, DWORD PTR [ebx+84]
  00010	0f 85 c9 00 00
	00		 jne	 $LN22@gz_head

; 113  :         /* allocate buffers */
; 114  :         state->in = malloc(state->want);

  00016	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _malloc

; 115  :         state->out = malloc(state->want << 1);

  0001f	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00022	03 c9		 add	 ecx, ecx
  00024	8b f0		 mov	 esi, eax
  00026	51		 push	 ecx
  00027	89 73 18	 mov	 DWORD PTR [ebx+24], esi
  0002a	e8 00 00 00 00	 call	 _malloc
  0002f	83 c4 08	 add	 esp, 8
  00032	89 43 1c	 mov	 DWORD PTR [ebx+28], eax

; 116  :         if (state->in == NULL || state->out == NULL) {

  00035	85 f6		 test	 esi, esi
  00037	74 71		 je	 SHORT $LN25@gz_head
  00039	85 c0		 test	 eax, eax
  0003b	74 7a		 je	 SHORT $LN24@gz_head

; 123  :         }
; 124  :         state->size = state->want;

  0003d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]

; 125  : 
; 126  :         /* allocate inflate memory */
; 127  :         state->strm.zalloc = Z_NULL;
; 128  :         state->strm.zfree = Z_NULL;
; 129  :         state->strm.opaque = Z_NULL;
; 130  :         state->strm.avail_in = 0;
; 131  :         state->strm.next_in = Z_NULL;
; 132  :         if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */

  00040	6a 38		 push	 56			; 00000038H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45?$AA@
  00047	6a f1		 push	 -15			; fffffff1H
  00049	57		 push	 edi
  0004a	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0004d	c7 43 74 00 00
	00 00		 mov	 DWORD PTR [ebx+116], 0
  00054	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [ebx+120], 0
  0005b	c7 43 7c 00 00
	00 00		 mov	 DWORD PTR [ebx+124], 0
  00062	c7 43 58 00 00
	00 00		 mov	 DWORD PTR [ebx+88], 0
  00069	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0006f	e8 00 00 00 00	 call	 _inflateInit2_
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	85 c0		 test	 eax, eax
  00079	74 64		 je	 SHORT $LN22@gz_head

; 133  :             free(state->out);

  0007b	ff 73 1c	 push	 DWORD PTR [ebx+28]
  0007e	e8 00 00 00 00	 call	 _free

; 134  :             free(state->in);

  00083	ff 73 18	 push	 DWORD PTR [ebx+24]
  00086	e8 00 00 00 00	 call	 _free

; 135  :             state->size = 0;
; 136  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00090	6a fc		 push	 -4			; fffffffcH
  00092	53		 push	 ebx
  00093	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  0009a	e8 00 00 00 00	 call	 _gz_error
  0009f	83 c4 14	 add	 esp, 20			; 00000014H

; 137  :             return -1;

  000a2	83 c8 ff	 or	 eax, -1
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 223  : }

  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN25@gz_head:

; 117  :             if (state->out != NULL)

  000aa	85 c0		 test	 eax, eax
  000ac	74 09		 je	 SHORT $LN24@gz_head

; 118  :                 free(state->out);

  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _free
  000b4	83 c4 04	 add	 esp, 4
$LN24@gz_head:

; 119  :             if (state->in != NULL)

  000b7	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  000ba	85 c0		 test	 eax, eax
  000bc	74 09		 je	 SHORT $LN23@gz_head

; 120  :                 free(state->in);

  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _free
  000c4	83 c4 04	 add	 esp, 4
$LN23@gz_head:

; 121  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000cc	6a fc		 push	 -4			; fffffffcH
  000ce	53		 push	 ebx
  000cf	e8 00 00 00 00	 call	 _gz_error
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN116@gz_head:

; 122  :             return -1;

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	83 c8 ff	 or	 eax, -1
  000dc	5b		 pop	 ebx

; 223  : }

  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
$LN22@gz_head:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     /* get some data in the input buffer */
; 142  :     if (strm->avail_in == 0) {

  000df	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000e2	85 c9		 test	 ecx, ecx
  000e4	75 19		 jne	 SHORT $LN19@gz_head

; 143  :         if (gz_avail(state) == -1)

  000e6	53		 push	 ebx
  000e7	e8 00 00 00 00	 call	 _gz_avail
  000ec	83 c4 04	 add	 esp, 4
  000ef	83 f8 ff	 cmp	 eax, -1
  000f2	74 e3		 je	 SHORT $LN116@gz_head

; 144  :             return -1;
; 145  :         if (strm->avail_in == 0)

  000f4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f7	85 c9		 test	 ecx, ecx
  000f9	0f 84 7b 03 00
	00		 je	 $LN114@gz_head
$LN19@gz_head:

; 146  :             return 0;
; 147  :     }
; 148  : 
; 149  :     /* look for the gzip magic header bytes 31 and 139 */
; 150  :     if (strm->next_in[0] == 31) {

  000ff	8b 07		 mov	 eax, DWORD PTR [edi]
  00101	80 38 1f	 cmp	 BYTE PTR [eax], 31	; 0000001fH
  00104	0f 85 31 03 00
	00		 jne	 $LN2@gz_head

; 151  :         strm->avail_in--;

  0010a	49		 dec	 ecx

; 152  :         strm->next_in++;

  0010b	40		 inc	 eax
  0010c	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0010f	89 07		 mov	 DWORD PTR [edi], eax

; 153  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00111	85 c9		 test	 ecx, ecx
  00113	75 0e		 jne	 SHORT $LN17@gz_head
  00115	53		 push	 ebx
  00116	e8 00 00 00 00	 call	 _gz_avail
  0011b	83 c4 04	 add	 esp, 4
  0011e	83 f8 ff	 cmp	 eax, -1
  00121	74 b4		 je	 SHORT $LN116@gz_head
$LN17@gz_head:

; 154  :             return -1;
; 155  :         if (strm->avail_in && strm->next_in[0] == 139) {

  00123	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00126	85 c9		 test	 ecx, ecx
  00128	0f 84 00 03 00
	00		 je	 $LN16@gz_head
  0012e	8b 07		 mov	 eax, DWORD PTR [edi]
  00130	80 38 8b	 cmp	 BYTE PTR [eax], 139	; 0000008bH
  00133	0f 85 f5 02 00
	00		 jne	 $LN16@gz_head

; 156  :             /* we have a gzip header, woo hoo! */
; 157  :             strm->avail_in--;

  00139	49		 dec	 ecx

; 158  :             strm->next_in++;

  0013a	40		 inc	 eax
  0013b	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0013e	89 07		 mov	 DWORD PTR [edi], eax

; 159  : 
; 160  :             /* skip rest of header */
; 161  :             if (NEXT() != 8) {      /* compression method */

  00140	85 c9		 test	 ecx, ecx
  00142	75 12		 jne	 SHORT $LN30@gz_head
  00144	53		 push	 ebx
  00145	e8 00 00 00 00	 call	 _gz_avail
  0014a	83 c4 04	 add	 esp, 4
  0014d	83 f8 ff	 cmp	 eax, -1
  00150	0f 84 c0 02 00
	00		 je	 $LN98@gz_head
$LN30@gz_head:
  00156	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00159	85 c0		 test	 eax, eax
  0015b	0f 84 b5 02 00
	00		 je	 $LN98@gz_head
  00161	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00164	8b 07		 mov	 eax, DWORD PTR [edi]
  00166	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00169	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0016c	40		 inc	 eax
  0016d	89 07		 mov	 DWORD PTR [edi], eax
  0016f	83 f9 08	 cmp	 ecx, 8
  00172	0f 85 9e 02 00
	00		 jne	 $LN98@gz_head

; 164  :             }
; 165  :             flags = NEXT();

  00178	85 d2		 test	 edx, edx
  0017a	75 12		 jne	 SHORT $LN34@gz_head
  0017c	53		 push	 ebx
  0017d	e8 00 00 00 00	 call	 _gz_avail
  00182	83 c4 04	 add	 esp, 4
  00185	83 f8 ff	 cmp	 eax, -1
  00188	75 04		 jne	 SHORT $LN34@gz_head
  0018a	0b c8		 or	 ecx, eax
  0018c	eb 19		 jmp	 SHORT $LN115@gz_head
$LN34@gz_head:
  0018e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00191	85 c0		 test	 eax, eax
  00193	75 05		 jne	 SHORT $LN35@gz_head
  00195	83 c9 ff	 or	 ecx, -1
  00198	eb 0d		 jmp	 SHORT $LN115@gz_head
$LN35@gz_head:
  0019a	48		 dec	 eax
  0019b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0019e	8b 07		 mov	 eax, DWORD PTR [edi]
  001a0	40		 inc	 eax
  001a1	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  001a5	89 07		 mov	 DWORD PTR [edi], eax
$LN115@gz_head:
  001a7	89 4d 08	 mov	 DWORD PTR _flags$1$[ebp], ecx

; 166  :             if (flags & 0xe0) {     /* reserved flag bits */

  001aa	f6 c1 e0	 test	 cl, -32			; ffffffe0H
  001ad	74 18		 je	 SHORT $LN14@gz_head

; 167  :                 gz_error(state, Z_DATA_ERROR, "unknown header flags set");

  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  001b4	6a fd		 push	 -3			; fffffffdH
  001b6	53		 push	 ebx
  001b7	e8 00 00 00 00	 call	 _gz_error
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  :                 return -1;

  001bf	83 c8 ff	 or	 eax, -1
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5b		 pop	 ebx

; 223  : }

  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
$LN14@gz_head:

; 169  :             }
; 170  :             NEXT();                 /* modification time */

  001c7	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  001cb	75 0e		 jne	 SHORT $LN38@gz_head
  001cd	53		 push	 ebx
  001ce	e8 00 00 00 00	 call	 _gz_avail
  001d3	83 c4 04	 add	 esp, 4
  001d6	83 f8 ff	 cmp	 eax, -1
  001d9	74 0d		 je	 SHORT $LN40@gz_head
$LN38@gz_head:
  001db	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001de	85 c0		 test	 eax, eax
  001e0	74 06		 je	 SHORT $LN40@gz_head
  001e2	48		 dec	 eax
  001e3	ff 07		 inc	 DWORD PTR [edi]
  001e5	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN40@gz_head:

; 171  :             NEXT();

  001e8	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  001ec	75 0e		 jne	 SHORT $LN42@gz_head
  001ee	53		 push	 ebx
  001ef	e8 00 00 00 00	 call	 _gz_avail
  001f4	83 c4 04	 add	 esp, 4
  001f7	83 f8 ff	 cmp	 eax, -1
  001fa	74 0d		 je	 SHORT $LN44@gz_head
$LN42@gz_head:
  001fc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001ff	85 c0		 test	 eax, eax
  00201	74 06		 je	 SHORT $LN44@gz_head
  00203	48		 dec	 eax
  00204	ff 07		 inc	 DWORD PTR [edi]
  00206	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN44@gz_head:

; 172  :             NEXT();

  00209	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0020d	75 0e		 jne	 SHORT $LN46@gz_head
  0020f	53		 push	 ebx
  00210	e8 00 00 00 00	 call	 _gz_avail
  00215	83 c4 04	 add	 esp, 4
  00218	83 f8 ff	 cmp	 eax, -1
  0021b	74 0d		 je	 SHORT $LN48@gz_head
$LN46@gz_head:
  0021d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00220	85 c0		 test	 eax, eax
  00222	74 06		 je	 SHORT $LN48@gz_head
  00224	48		 dec	 eax
  00225	ff 07		 inc	 DWORD PTR [edi]
  00227	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN48@gz_head:

; 173  :             NEXT();

  0022a	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0022e	75 0e		 jne	 SHORT $LN50@gz_head
  00230	53		 push	 ebx
  00231	e8 00 00 00 00	 call	 _gz_avail
  00236	83 c4 04	 add	 esp, 4
  00239	83 f8 ff	 cmp	 eax, -1
  0023c	74 0d		 je	 SHORT $LN52@gz_head
$LN50@gz_head:
  0023e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00241	85 c0		 test	 eax, eax
  00243	74 06		 je	 SHORT $LN52@gz_head
  00245	48		 dec	 eax
  00246	ff 07		 inc	 DWORD PTR [edi]
  00248	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN52@gz_head:

; 174  :             NEXT();                 /* extra flags */

  0024b	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0024f	75 0e		 jne	 SHORT $LN54@gz_head
  00251	53		 push	 ebx
  00252	e8 00 00 00 00	 call	 _gz_avail
  00257	83 c4 04	 add	 esp, 4
  0025a	83 f8 ff	 cmp	 eax, -1
  0025d	74 0d		 je	 SHORT $LN56@gz_head
$LN54@gz_head:
  0025f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00262	85 c0		 test	 eax, eax
  00264	74 06		 je	 SHORT $LN56@gz_head
  00266	48		 dec	 eax
  00267	ff 07		 inc	 DWORD PTR [edi]
  00269	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN56@gz_head:

; 175  :             NEXT();                 /* operating system */

  0026c	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00270	75 0e		 jne	 SHORT $LN58@gz_head
  00272	53		 push	 ebx
  00273	e8 00 00 00 00	 call	 _gz_avail
  00278	83 c4 04	 add	 esp, 4
  0027b	83 f8 ff	 cmp	 eax, -1
  0027e	74 0d		 je	 SHORT $LN60@gz_head
$LN58@gz_head:
  00280	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00283	85 c0		 test	 eax, eax
  00285	74 06		 je	 SHORT $LN60@gz_head
  00287	48		 dec	 eax
  00288	ff 07		 inc	 DWORD PTR [edi]
  0028a	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN60@gz_head:

; 176  :             if (flags & 4) {        /* extra field */

  0028d	8b 45 08	 mov	 eax, DWORD PTR _flags$1$[ebp]
  00290	a8 04		 test	 al, 4
  00292	0f 84 9e 00 00
	00		 je	 $LN102@gz_head

; 177  :                 len = (unsigned)NEXT();

  00298	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0029c	75 12		 jne	 SHORT $LN62@gz_head
  0029e	53		 push	 ebx
  0029f	e8 00 00 00 00	 call	 _gz_avail
  002a4	83 c4 04	 add	 esp, 4
  002a7	83 f8 ff	 cmp	 eax, -1
  002aa	75 04		 jne	 SHORT $LN62@gz_head
  002ac	0b f0		 or	 esi, eax
  002ae	eb 19		 jmp	 SHORT $LN64@gz_head
$LN62@gz_head:
  002b0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002b3	85 c0		 test	 eax, eax
  002b5	75 05		 jne	 SHORT $LN63@gz_head
  002b7	83 ce ff	 or	 esi, -1
  002ba	eb 0d		 jmp	 SHORT $LN64@gz_head
$LN63@gz_head:
  002bc	48		 dec	 eax
  002bd	89 47 04	 mov	 DWORD PTR [edi+4], eax
  002c0	8b 07		 mov	 eax, DWORD PTR [edi]
  002c2	40		 inc	 eax
  002c3	0f b6 70 ff	 movzx	 esi, BYTE PTR [eax-1]
  002c7	89 07		 mov	 DWORD PTR [edi], eax
$LN64@gz_head:

; 178  :                 len += (unsigned)NEXT() << 8;

  002c9	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  002cd	75 12		 jne	 SHORT $LN66@gz_head
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 _gz_avail
  002d5	83 c4 04	 add	 esp, 4
  002d8	83 f8 ff	 cmp	 eax, -1
  002db	75 04		 jne	 SHORT $LN66@gz_head
  002dd	0b c8		 or	 ecx, eax
  002df	eb 19		 jmp	 SHORT $LN68@gz_head
$LN66@gz_head:
  002e1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002e4	85 c0		 test	 eax, eax
  002e6	75 05		 jne	 SHORT $LN67@gz_head
  002e8	83 c9 ff	 or	 ecx, -1
  002eb	eb 0d		 jmp	 SHORT $LN68@gz_head
$LN67@gz_head:
  002ed	48		 dec	 eax
  002ee	89 47 04	 mov	 DWORD PTR [edi+4], eax
  002f1	8b 07		 mov	 eax, DWORD PTR [edi]
  002f3	40		 inc	 eax
  002f4	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  002f8	89 07		 mov	 DWORD PTR [edi], eax
$LN68@gz_head:
  002fa	c1 e1 08	 shl	 ecx, 8
  002fd	03 f1		 add	 esi, ecx

; 179  :                 while (len--)

  002ff	74 32		 je	 SHORT $LN113@gz_head
$LL12@gz_head:

; 180  :                     if (NEXT() < 0)

  00301	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00304	4e		 dec	 esi
  00305	85 c0		 test	 eax, eax
  00307	75 15		 jne	 SHORT $LN107@gz_head
  00309	53		 push	 ebx
  0030a	e8 00 00 00 00	 call	 _gz_avail
  0030f	83 c4 04	 add	 esp, 4
  00312	83 f8 ff	 cmp	 eax, -1
  00315	74 1c		 je	 SHORT $LN113@gz_head
  00317	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0031a	85 c0		 test	 eax, eax
  0031c	74 15		 je	 SHORT $LN113@gz_head
$LN107@gz_head:
  0031e	48		 dec	 eax
  0031f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00322	8b 07		 mov	 eax, DWORD PTR [edi]
  00324	40		 inc	 eax
  00325	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  00329	89 07		 mov	 DWORD PTR [edi], eax
  0032b	85 c9		 test	 ecx, ecx
  0032d	78 04		 js	 SHORT $LN113@gz_head

; 179  :                 while (len--)

  0032f	85 f6		 test	 esi, esi
  00331	75 ce		 jne	 SHORT $LL12@gz_head
$LN113@gz_head:
  00333	8b 45 08	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN102@gz_head:

; 181  :                         break;
; 182  :             }
; 183  :             if (flags & 8)          /* file name */

  00336	a8 08		 test	 al, 8
  00338	74 36		 je	 SHORT $LN104@gz_head
  0033a	8d 9b 00 00 00
	00		 npad	 6
$LL8@gz_head:

; 184  :                 while (NEXT() > 0)

  00340	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00343	85 c0		 test	 eax, eax
  00345	75 15		 jne	 SHORT $LN108@gz_head
  00347	53		 push	 ebx
  00348	e8 00 00 00 00	 call	 _gz_avail
  0034d	83 c4 04	 add	 esp, 4
  00350	83 f8 ff	 cmp	 eax, -1
  00353	74 18		 je	 SHORT $LN111@gz_head
  00355	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00358	85 c0		 test	 eax, eax
  0035a	74 11		 je	 SHORT $LN111@gz_head
$LN108@gz_head:
  0035c	48		 dec	 eax
  0035d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00360	8b 07		 mov	 eax, DWORD PTR [edi]
  00362	40		 inc	 eax
  00363	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  00367	89 07		 mov	 DWORD PTR [edi], eax
  00369	85 c9		 test	 ecx, ecx
  0036b	7f d3		 jg	 SHORT $LL8@gz_head
$LN111@gz_head:
  0036d	8b 45 08	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN104@gz_head:

; 185  :                     ;
; 186  :             if (flags & 16)         /* comment */

  00370	a8 10		 test	 al, 16			; 00000010H
  00372	74 30		 je	 SHORT $LN106@gz_head
$LL5@gz_head:

; 187  :                 while (NEXT() > 0)

  00374	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00377	85 c0		 test	 eax, eax
  00379	75 15		 jne	 SHORT $LN109@gz_head
  0037b	53		 push	 ebx
  0037c	e8 00 00 00 00	 call	 _gz_avail
  00381	83 c4 04	 add	 esp, 4
  00384	83 f8 ff	 cmp	 eax, -1
  00387	74 18		 je	 SHORT $LN112@gz_head
  00389	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0038c	85 c0		 test	 eax, eax
  0038e	74 11		 je	 SHORT $LN112@gz_head
$LN109@gz_head:
  00390	48		 dec	 eax
  00391	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00394	8b 07		 mov	 eax, DWORD PTR [edi]
  00396	40		 inc	 eax
  00397	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  0039b	89 07		 mov	 DWORD PTR [edi], eax
  0039d	85 c9		 test	 ecx, ecx
  0039f	7f d3		 jg	 SHORT $LL5@gz_head
$LN112@gz_head:
  003a1	8b 45 08	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN106@gz_head:

; 188  :                     ;
; 189  :             if (flags & 2) {        /* header crc */

  003a4	a8 02		 test	 al, 2
  003a6	74 42		 je	 SHORT $LN88@gz_head

; 190  :                 NEXT();

  003a8	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  003ac	75 0e		 jne	 SHORT $LN82@gz_head
  003ae	53		 push	 ebx
  003af	e8 00 00 00 00	 call	 _gz_avail
  003b4	83 c4 04	 add	 esp, 4
  003b7	83 f8 ff	 cmp	 eax, -1
  003ba	74 0d		 je	 SHORT $LN84@gz_head
$LN82@gz_head:
  003bc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003bf	85 c0		 test	 eax, eax
  003c1	74 06		 je	 SHORT $LN84@gz_head
  003c3	48		 dec	 eax
  003c4	ff 07		 inc	 DWORD PTR [edi]
  003c6	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN84@gz_head:

; 191  :                 NEXT();

  003c9	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  003cd	75 0e		 jne	 SHORT $LN86@gz_head
  003cf	53		 push	 ebx
  003d0	e8 00 00 00 00	 call	 _gz_avail
  003d5	83 c4 04	 add	 esp, 4
  003d8	83 f8 ff	 cmp	 eax, -1
  003db	74 0d		 je	 SHORT $LN88@gz_head
$LN86@gz_head:
  003dd	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003e0	85 c0		 test	 eax, eax
  003e2	74 06		 je	 SHORT $LN88@gz_head
  003e4	48		 dec	 eax
  003e5	ff 07		 inc	 DWORD PTR [edi]
  003e7	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN88@gz_head:

; 192  :             }
; 193  :             /* an unexpected end of file is not checked for here -- it will be
; 194  :                noticed on the first request for uncompressed data */
; 195  : 
; 196  :             /* set up for decompression */
; 197  :             inflateReset(strm);

  003ea	57		 push	 edi
  003eb	e8 00 00 00 00	 call	 _inflateReset

; 198  :             strm->adler = crc32(0L, Z_NULL, 0);

  003f0	6a 00		 push	 0
  003f2	6a 00		 push	 0
  003f4	6a 00		 push	 0
  003f6	e8 00 00 00 00	 call	 _crc32
  003fb	83 c4 10	 add	 esp, 16			; 00000010H
  003fe	89 47 30	 mov	 DWORD PTR [edi+48], eax
  00401	5f		 pop	 edi
  00402	5e		 pop	 esi

; 199  :             state->how = GZIP;

  00403	c7 43 34 02 00
	00 00		 mov	 DWORD PTR [ebx+52], 2

; 200  :             state->direct = 0;

  0040a	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0

; 222  :     return 0;

  00411	33 c0		 xor	 eax, eax
  00413	5b		 pop	 ebx

; 223  : }

  00414	5d		 pop	 ebp
  00415	c3		 ret	 0
$LN98@gz_head:

; 162  :                 gz_error(state, Z_DATA_ERROR, "unknown compression method");

  00416	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0041b	6a fd		 push	 -3			; fffffffdH
  0041d	53		 push	 ebx
  0041e	e8 00 00 00 00	 call	 _gz_error
  00423	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  :                 return -1;

  00426	83 c8 ff	 or	 eax, -1
  00429	5f		 pop	 edi
  0042a	5e		 pop	 esi
  0042b	5b		 pop	 ebx

; 223  : }

  0042c	5d		 pop	 ebp
  0042d	c3		 ret	 0
$LN16@gz_head:

; 201  :             return 0;
; 202  :         }
; 203  :         else {
; 204  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 205  :             state->out[0] = 31;

  0042e	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00431	c6 00 1f	 mov	 BYTE PTR [eax], 31	; 0000001fH

; 206  :             state->have = 1;

  00434	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [ebx+36], 1
$LN2@gz_head:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 211  :        input to output -- this assumes that the output buffer is larger than
; 212  :        the input buffer, which also assures space for gzungetc() */
; 213  :     state->raw = state->pos;

  0043b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 214  :     state->next = state->out;

  0043e	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00441	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  00444	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx

; 215  :     if (strm->avail_in) {

  00447	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0044a	85 c0		 test	 eax, eax
  0044c	74 1e		 je	 SHORT $LN1@gz_head

; 216  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

  0044e	50		 push	 eax
  0044f	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00452	ff 37		 push	 DWORD PTR [edi]
  00454	03 c1		 add	 eax, ecx
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 _memcpy

; 217  :         state->have += strm->avail_in;

  0045c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0045f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00462	01 43 24	 add	 DWORD PTR [ebx+36], eax

; 218  :         strm->avail_in = 0;

  00465	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN1@gz_head:

; 219  :     }
; 220  :     state->how = COPY;

  0046c	c7 43 34 01 00
	00 00		 mov	 DWORD PTR [ebx+52], 1

; 221  :     state->direct = 1;

  00473	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [ebx+56], 1
$LN114@gz_head:

; 222  :     return 0;

  0047a	5f		 pop	 edi
  0047b	5e		 pop	 esi
  0047c	33 c0		 xor	 eax, eax
  0047e	5b		 pop	 ebx

; 223  : }

  0047f	5d		 pop	 ebp
  00480	c3		 ret	 0
_gz_head ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_next4
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ret$ = 12						; size = 4
_gz_next4 PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 77   :     int ch;
; 78   :     unsigned long val;
; 79   :     z_streamp strm = &(state->strm);

  00004	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  00007	57		 push	 edi

; 80   : 
; 81   :     val = NEXT();

  00008	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0000c	75 12		 jne	 SHORT $LN4@gz_next4
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _gz_avail
  00014	83 c4 04	 add	 esp, 4
  00017	83 f8 ff	 cmp	 eax, -1
  0001a	75 04		 jne	 SHORT $LN4@gz_next4
  0001c	0b f8		 or	 edi, eax
  0001e	eb 1b		 jmp	 SHORT $LN6@gz_next4
$LN4@gz_next4:
  00020	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00023	85 c0		 test	 eax, eax
  00025	75 05		 jne	 SHORT $LN5@gz_next4
  00027	83 cf ff	 or	 edi, -1
  0002a	eb 0f		 jmp	 SHORT $LN6@gz_next4
$LN5@gz_next4:
  0002c	48		 dec	 eax
  0002d	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00030	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00033	40		 inc	 eax
  00034	0f b6 78 ff	 movzx	 edi, BYTE PTR [eax-1]
  00038	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN6@gz_next4:

; 82   :     val += (unsigned)NEXT() << 8;

  0003b	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0003f	75 12		 jne	 SHORT $LN8@gz_next4
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 _gz_avail
  00047	83 c4 04	 add	 esp, 4
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	75 04		 jne	 SHORT $LN8@gz_next4
  0004f	0b c8		 or	 ecx, eax
  00051	eb 1b		 jmp	 SHORT $LN10@gz_next4
$LN8@gz_next4:
  00053	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00056	85 c0		 test	 eax, eax
  00058	75 05		 jne	 SHORT $LN9@gz_next4
  0005a	83 c9 ff	 or	 ecx, -1
  0005d	eb 0f		 jmp	 SHORT $LN10@gz_next4
$LN9@gz_next4:
  0005f	48		 dec	 eax
  00060	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00063	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00066	40		 inc	 eax
  00067	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  0006b	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN10@gz_next4:
  0006e	c1 e1 08	 shl	 ecx, 8
  00071	03 f9		 add	 edi, ecx

; 83   :     val += (unsigned long)NEXT() << 16;

  00073	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00077	75 12		 jne	 SHORT $LN12@gz_next4
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 _gz_avail
  0007f	83 c4 04	 add	 esp, 4
  00082	83 f8 ff	 cmp	 eax, -1
  00085	75 04		 jne	 SHORT $LN12@gz_next4
  00087	0b c8		 or	 ecx, eax
  00089	eb 1b		 jmp	 SHORT $LN14@gz_next4
$LN12@gz_next4:
  0008b	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0008e	85 c0		 test	 eax, eax
  00090	75 05		 jne	 SHORT $LN13@gz_next4
  00092	83 c9 ff	 or	 ecx, -1
  00095	eb 0f		 jmp	 SHORT $LN14@gz_next4
$LN13@gz_next4:
  00097	48		 dec	 eax
  00098	89 46 58	 mov	 DWORD PTR [esi+88], eax
  0009b	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0009e	40		 inc	 eax
  0009f	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  000a3	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN14@gz_next4:
  000a6	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a9	03 f9		 add	 edi, ecx

; 84   :     ch = NEXT();

  000ab	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000af	75 0e		 jne	 SHORT $LN16@gz_next4
  000b1	56		 push	 esi
  000b2	e8 00 00 00 00	 call	 _gz_avail
  000b7	83 c4 04	 add	 esp, 4
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	74 2b		 je	 SHORT $LN20@gz_next4
$LN16@gz_next4:
  000bf	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000c2	85 c0		 test	 eax, eax
  000c4	74 24		 je	 SHORT $LN20@gz_next4
  000c6	48		 dec	 eax
  000c7	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000ca	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000cd	40		 inc	 eax
  000ce	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  000d2	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 85   :     if (ch == -1)

  000d5	83 f9 ff	 cmp	 ecx, -1
  000d8	74 10		 je	 SHORT $LN20@gz_next4

; 87   :     val += (unsigned long)ch << 24;
; 88   :     *ret = val;

  000da	8b 45 0c	 mov	 eax, DWORD PTR _ret$[ebp]
  000dd	c1 e1 18	 shl	 ecx, 24			; 00000018H
  000e0	03 cf		 add	 ecx, edi
  000e2	5f		 pop	 edi
  000e3	89 08		 mov	 DWORD PTR [eax], ecx

; 89   :     return 0;

  000e5	33 c0		 xor	 eax, eax
  000e7	5e		 pop	 esi

; 90   : }

  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN20@gz_next4:
  000ea	5f		 pop	 edi

; 86   :         return -1;

  000eb	83 c8 ff	 or	 eax, -1
  000ee	5e		 pop	 esi

; 90   : }

  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_gz_next4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_avail
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_avail PROC						; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 53   :     z_streamp strm = &(state->strm);

  00004	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]

; 54   : 
; 55   :     if (state->err != Z_OK)

  00007	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0000b	74 06		 je	 SHORT $LN3@gz_avail
$LN6@gz_avail:

; 56   :         return -1;

  0000d	83 c8 ff	 or	 eax, -1
  00010	5e		 pop	 esi

; 64   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN3@gz_avail:

; 57   :     if (state->eof == 0) {

  00013	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00017	75 1e		 jne	 SHORT $LN2@gz_avail

; 58   :         if (gz_load(state, state->in, state->size,
; 59   :                 (unsigned *)&(strm->avail_in)) == -1)

  00019	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  0001c	50		 push	 eax
  0001d	ff 76 10	 push	 DWORD PTR [esi+16]
  00020	ff 76 18	 push	 DWORD PTR [esi+24]
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _gz_load
  00029	83 c4 10	 add	 esp, 16			; 00000010H
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	74 dc		 je	 SHORT $LN6@gz_avail

; 60   :             return -1;
; 61   :         strm->next_in = state->in;

  00031	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00034	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN2@gz_avail:

; 62   :     }
; 63   :     return 0;

  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 64   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gz_load
_TEXT	SEGMENT
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_gz_load PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]
  00007	56		 push	 esi

; 27   :     int ret;
; 28   : 
; 29   :     *have = 0;

  00008	8b 75 14	 mov	 esi, DWORD PTR _have$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 10	 mov	 edi, DWORD PTR _len$[ebp]
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LL6@gz_load:

; 30   :     do {
; 31   :         ret = read(state->fd, buf + *have, len - *have);

  00015	8b c7		 mov	 eax, edi
  00017	2b 06		 sub	 eax, DWORD PTR [esi]
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0001d	03 06		 add	 eax, DWORD PTR [esi]
  0001f	50		 push	 eax
  00020	ff 73 04	 push	 DWORD PTR [ebx+4]
  00023	e8 00 00 00 00	 call	 _read
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   :         if (ret <= 0)

  0002b	85 c0		 test	 eax, eax
  0002d	7e 08		 jle	 SHORT $LN12@gz_load

; 33   :             break;
; 34   :         *have += ret;

  0002f	01 06		 add	 DWORD PTR [esi], eax

; 35   :     } while (*have < len);

  00031	39 3e		 cmp	 DWORD PTR [esi], edi
  00033	72 e0		 jb	 SHORT $LL6@gz_load

; 36   :     if (ret < 0) {

  00035	85 c0		 test	 eax, eax
$LN12@gz_load:
  00037	79 20		 jns	 SHORT $LN2@gz_load

; 37   :         gz_error(state, Z_ERRNO, zstrerror());

  00039	e8 00 00 00 00	 call	 __errno
  0003e	ff 30		 push	 DWORD PTR [eax]
  00040	e8 00 00 00 00	 call	 _strerror
  00045	50		 push	 eax
  00046	6a ff		 push	 -1
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 _gz_error
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 38   :         return -1;

  00051	83 c8 ff	 or	 eax, -1
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 43   : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN2@gz_load:

; 39   :     }
; 40   :     if (ret == 0)

  00059	85 c0		 test	 eax, eax
  0005b	75 07		 jne	 SHORT $LN1@gz_load

; 41   :         state->eof = 1;

  0005d	c7 43 28 01 00
	00 00		 mov	 DWORD PTR [ebx+40], 1
$LN1@gz_load:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 42   :     return 0;

  00066	33 c0		 xor	 eax, eax
  00068	5b		 pop	 ebx

; 43   : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_gz_load ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzclose_r
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_r PROC						; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 630  :     int ret;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 08		 jne	 SHORT $LN3@gzclose_r
$LN6@gzclose_r:

; 635  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5f		 pop	 edi

; 653  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
$LN3@gzclose_r:

; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  00013	81 3f 4f 1c 00
	00		 cmp	 DWORD PTR [edi], 7247	; 00001c4fH
  00019	75 f0		 jne	 SHORT $LN6@gzclose_r

; 640  :         return Z_STREAM_ERROR;
; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  0001b	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0001f	74 1c		 je	 SHORT $LN1@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00021	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _inflateEnd

; 645  :         free(state->out);

  0002a	ff 77 1c	 push	 DWORD PTR [edi+28]
  0002d	e8 00 00 00 00	 call	 _free

; 646  :         free(state->in);

  00032	ff 77 18	 push	 DWORD PTR [edi+24]
  00035	e8 00 00 00 00	 call	 _free
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gzclose_r:

; 647  :     }
; 648  :     gz_error(state, Z_OK, NULL);

  0003d	56		 push	 esi
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 _gz_error

; 649  :     free(state->path);

  00048	ff 77 08	 push	 DWORD PTR [edi+8]
  0004b	e8 00 00 00 00	 call	 _free

; 650  :     ret = close(state->fd);

  00050	ff 77 04	 push	 DWORD PTR [edi+4]
  00053	e8 00 00 00 00	 call	 _close

; 651  :     free(state);

  00058	57		 push	 edi
  00059	8b f0		 mov	 esi, eax
  0005b	e8 00 00 00 00	 call	 _free
  00060	83 c4 18	 add	 esp, 24			; 00000018H

; 652  :     return ret ? Z_ERRNO : Z_OK;

  00063	f7 de		 neg	 esi
  00065	1b f6		 sbb	 esi, esi
  00067	8b c6		 mov	 eax, esi
  00069	5e		 pop	 esi
  0006a	5f		 pop	 edi

; 653  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzdirect
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzdirect PROC						; COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 606  :     gz_statep state;
; 607  : 
; 608  :     /* get internal structure */
; 609  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN3@gzdirect
$LN6@gzdirect:

; 610  :         return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 624  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@gzdirect:

; 611  :     state = (gz_statep)file;
; 612  : 
; 613  :     /* check that we're reading */
; 614  :     if (state->mode != GZ_READ)

  00010	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00016	75 f3		 jne	 SHORT $LN6@gzdirect

; 615  :         return 0;
; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->how == LOOK && state->have == 0)

  00018	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0001c	75 0f		 jne	 SHORT $LN1@gzdirect
  0001e	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00022	75 09		 jne	 SHORT $LN1@gzdirect

; 620  :         (void)gz_head(state);

  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 _gz_head
  0002a	83 c4 04	 add	 esp, 4
$LN1@gzdirect:

; 621  : 
; 622  :     /* return 1 if reading direct, 0 if decompressing a gzip stream */
; 623  :     return state->direct;

  0002d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00030	5e		 pop	 esi

; 624  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_gzdirect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzungetc
_TEXT	SEGMENT
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc PROC						; COMDAT

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure */
; 489  :     if (file == NULL)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN11@gzungetc
$LN20@gzungetc:

; 490  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN11@gzungetc:

; 491  :     state = (gz_statep)file;
; 492  : 
; 493  :     /* check that we're reading and that there's no error */
; 494  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00011	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00017	75 f2		 jne	 SHORT $LN20@gzungetc
  00019	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001d	75 ec		 jne	 SHORT $LN20@gzungetc

; 495  :         return -1;
; 496  : 
; 497  :     /* process a skip request */
; 498  :     if (state->seek) {

  0001f	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00023	74 18		 je	 SHORT $LN7@gzungetc

; 499  :         state->seek = 0;
; 500  :         if (gz_skip(state, state->skip) == -1)

  00025	ff 76 44	 push	 DWORD PTR [esi+68]
  00028	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 _gz_skip
  00035	83 c4 08	 add	 esp, 8
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	74 ce		 je	 SHORT $LN20@gzungetc
$LN7@gzungetc:
  0003d	53		 push	 ebx

; 501  :             return -1;
; 502  :     }
; 503  : 
; 504  :     /* can't push EOF */
; 505  :     if (c < 0)

  0003e	8b 5d 08	 mov	 ebx, DWORD PTR _c$[ebp]
  00041	85 db		 test	 ebx, ebx
  00043	78 3d		 js	 SHORT $LN18@gzungetc

; 506  :         return -1;
; 507  : 
; 508  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 509  :     if (state->have == 0) {

  00045	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]

; 510  :         state->have = 1;
; 511  :         state->next = state->out + (state->size << 1) - 1;

  00048	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0004b	85 c9		 test	 ecx, ecx
  0004d	75 1c		 jne	 SHORT $LN5@gzungetc
  0004f	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00052	c7 46 24 01 00
	00 00		 mov	 DWORD PTR [esi+36], 1
  00059	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0005c	49		 dec	 ecx
  0005d	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 512  :         state->next[0] = c;

  00060	88 19		 mov	 BYTE PTR [ecx], bl

; 513  :         state->pos--;

  00062	ff 4e 0c	 dec	 DWORD PTR [esi+12]

; 514  :         return c;

  00065	8b c3		 mov	 eax, ebx
  00067	5b		 pop	 ebx
  00068	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@gzungetc:

; 515  :     }
; 516  : 
; 517  :     /* if no room, give up (must have already done a gzungetc()) */
; 518  :     if (state->have == (state->size << 1)) {

  0006b	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  0006e	3b c8		 cmp	 ecx, eax
  00070	75 17		 jne	 SHORT $LN4@gzungetc

; 519  :         gz_error(state, Z_BUF_ERROR, "out of room to push characters");

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  00077	6a fb		 push	 -5			; fffffffbH
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 _gz_error
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@gzungetc:

; 520  :         return -1;

  00082	5b		 pop	 ebx
  00083	83 c8 ff	 or	 eax, -1
  00086	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN4@gzungetc:

; 521  :     }
; 522  : 
; 523  :     /* slide output data if needed and insert byte before existing data */
; 524  :     if (state->next == state->out) {

  00089	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008c	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  0008f	75 1e		 jne	 SHORT $LN3@gzungetc

; 525  :         unsigned char *src = state->out + state->have;

  00091	03 c8		 add	 ecx, eax

; 526  :         unsigned char *dest = state->out + (state->size << 1);

  00093	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]

; 527  :         while (src > state->out)

  00096	3b c8		 cmp	 ecx, eax
  00098	76 12		 jbe	 SHORT $LN1@gzungetc
  0009a	8d 9b 00 00 00
	00		 npad	 6
$LL2@gzungetc:

; 528  :             *--dest = *--src;

  000a0	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  000a3	49		 dec	 ecx
  000a4	4a		 dec	 edx
  000a5	88 02		 mov	 BYTE PTR [edx], al
  000a7	3b 4e 1c	 cmp	 ecx, DWORD PTR [esi+28]
  000aa	77 f4		 ja	 SHORT $LL2@gzungetc
$LN1@gzungetc:

; 529  :         state->next = dest;

  000ac	89 56 20	 mov	 DWORD PTR [esi+32], edx
$LN3@gzungetc:

; 530  :     }
; 531  :     state->have++;
; 532  :     state->next--;

  000af	ff 4e 20	 dec	 DWORD PTR [esi+32]
  000b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000b5	ff 46 24	 inc	 DWORD PTR [esi+36]

; 533  :     state->next[0] = c;

  000b8	88 18		 mov	 BYTE PTR [eax], bl
  000ba	ff 4e 0c	 dec	 DWORD PTR [esi+12]
  000bd	8b c3		 mov	 eax, ebx
  000bf	5b		 pop	 ebx
  000c0	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzgetc
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_gzgetc	PROC						; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 456  :     int ret;
; 457  :     unsigned char buf[1];
; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure */
; 461  :     if (file == NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 45		 je	 SHORT $LN2@gzgetc

; 462  :         return -1;
; 463  :     state = (gz_statep)file;
; 464  : 
; 465  :     /* check that we're reading and that there's no error */
; 466  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000a	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [edx], 7247	; 00001c4fH
  00010	75 3d		 jne	 SHORT $LN2@gzgetc
  00012	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00016	75 37		 jne	 SHORT $LN2@gzgetc

; 468  : 
; 469  :     /* try output buffer (no need to check for skip request) */
; 470  :     if (state->have) {

  00018	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0001b	85 c0		 test	 eax, eax
  0001d	74 16		 je	 SHORT $LN1@gzgetc

; 471  :         state->have--;
; 472  :         state->pos++;

  0001f	ff 42 0c	 inc	 DWORD PTR [edx+12]
  00022	48		 dec	 eax
  00023	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 473  :         return *(state->next)++;

  00026	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00029	40		 inc	 eax
  0002a	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  0002d	89 42 20	 mov	 DWORD PTR [edx+32], eax
  00030	0f b6 c1	 movzx	 eax, cl

; 479  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN1@gzgetc:

; 474  :     }
; 475  : 
; 476  :     /* nothing there -- try gzread() */
; 477  :     ret = gzread(file, buf, 1);

  00035	6a 01		 push	 1
  00037	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  0003a	50		 push	 eax
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _gzread
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 478  :     return ret < 1 ? -1 : buf[0];

  00044	83 f8 01	 cmp	 eax, 1
  00047	7c 06		 jl	 SHORT $LN2@gzgetc
  00049	0f b6 45 0b	 movzx	 eax, BYTE PTR _buf$[ebp]

; 479  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN2@gzgetc:

; 467  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 479  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzgets
_TEXT	SEGMENT
_eol$1$ = -8						; size = 4
_str$1$ = -4						; size = 4
_left$1$ = 8						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzgets	PROC						; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 544  :     unsigned left, n;
; 545  :     char *str;
; 546  :     unsigned char *eol;
; 547  :     gz_statep state;
; 548  : 
; 549  :     /* check parameters and get internal structure */
; 550  :     if (file == NULL || buf == NULL || len < 1)

  00009	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  0000c	85 ff		 test	 edi, edi
  0000e	0f 84 dd 00 00
	00		 je	 $LN15@gzgets
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _buf$[ebp]
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 d2 00 00
	00		 je	 $LN15@gzgets
  0001f	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  00022	83 fe 01	 cmp	 esi, 1
  00025	0f 8c c6 00 00
	00		 jl	 $LN15@gzgets

; 552  :     state = (gz_statep)file;
; 553  : 
; 554  :     /* check that we're reading and that there's no error */
; 555  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0002b	81 3f 4f 1c 00
	00		 cmp	 DWORD PTR [edi], 7247	; 00001c4fH
  00031	0f 85 ba 00 00
	00		 jne	 $LN15@gzgets
  00037	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0003b	0f 85 b0 00 00
	00		 jne	 $LN15@gzgets

; 556  :         return NULL;
; 557  : 
; 558  :     /* process a skip request */
; 559  :     if (state->seek) {

  00041	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  00045	74 1c		 je	 SHORT $LN11@gzgets

; 560  :         state->seek = 0;
; 561  :         if (gz_skip(state, state->skip) == -1)

  00047	ff 77 44	 push	 DWORD PTR [edi+68]
  0004a	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 _gz_skip
  00057	83 c4 08	 add	 esp, 8
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	0f 84 8e 00 00
	00		 je	 $LN15@gzgets
$LN11@gzgets:

; 562  :             return NULL;
; 563  :     }
; 564  : 
; 565  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 566  :        append a terminating zero to the string (we don't check for a zero in
; 567  :        the contents, let the user worry about that) */
; 568  :     str = buf;
; 569  :     left = (unsigned)len - 1;

  00063	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00066	89 5d fc	 mov	 DWORD PTR _str$1$[ebp], ebx
  00069	89 45 08	 mov	 DWORD PTR _left$1$[ebp], eax

; 570  :     if (left) do {

  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 86 00 00
	00		 je	 $LN25@gzgets
$LL9@gzgets:

; 571  :         /* assure that something is in the output buffer */
; 572  :         if (state->have == 0) {

  00074	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  00077	85 f6		 test	 esi, esi
  00079	75 18		 jne	 SHORT $LN4@gzgets

; 573  :             if (gz_make(state) == -1)

  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 _gz_make
  00081	83 c4 04	 add	 esp, 4
  00084	83 f8 ff	 cmp	 eax, -1
  00087	74 68		 je	 SHORT $LN15@gzgets

; 574  :                 return NULL;            /* error */
; 575  :             if (state->have == 0) {     /* end of file */

  00089	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  0008c	85 f6		 test	 esi, esi
  0008e	74 5a		 je	 SHORT $LN23@gzgets
  00090	8b 45 08	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN4@gzgets:

; 577  :                     return NULL;
; 578  :                 break;                  /* got something -- return it */
; 579  :             }
; 580  :         }
; 581  : 
; 582  :         /* look for end-of-line in current output buffer */
; 583  :         n = state->have > left ? left : state->have;

  00093	3b f0		 cmp	 esi, eax
  00095	0f 47 f0	 cmova	 esi, eax

; 584  :         eol = memchr(state->next, '\n', n);

  00098	56		 push	 esi
  00099	6a 0a		 push	 10			; 0000000aH
  0009b	ff 77 20	 push	 DWORD PTR [edi+32]
  0009e	e8 00 00 00 00	 call	 _memchr
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 45 f8	 mov	 DWORD PTR _eol$1$[ebp], eax

; 585  :         if (eol != NULL)

  000a9	85 c0		 test	 eax, eax
  000ab	74 06		 je	 SHORT $LN2@gzgets

; 586  :             n = (unsigned)(eol - state->next) + 1;

  000ad	8b f0		 mov	 esi, eax
  000af	2b 77 20	 sub	 esi, DWORD PTR [edi+32]
  000b2	46		 inc	 esi
$LN2@gzgets:

; 587  : 
; 588  :         /* copy through end-of-line, or remainder if not found */
; 589  :         memcpy(buf, state->next, n);

  000b3	56		 push	 esi
  000b4	ff 77 20	 push	 DWORD PTR [edi+32]
  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 _memcpy

; 590  :         state->have -= n;
; 591  :         state->next += n;
; 592  :         state->pos += n;
; 593  :         left -= n;

  000bd	8b 45 08	 mov	 eax, DWORD PTR _left$1$[ebp]
  000c0	29 77 24	 sub	 DWORD PTR [edi+36], esi
  000c3	01 77 20	 add	 DWORD PTR [edi+32], esi
  000c6	01 77 0c	 add	 DWORD PTR [edi+12], esi
  000c9	2b c6		 sub	 eax, esi
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 594  :         buf += n;

  000ce	03 de		 add	 ebx, esi
  000d0	89 45 08	 mov	 DWORD PTR _left$1$[ebp], eax

; 595  :     } while (left && eol == NULL);

  000d3	85 c0		 test	 eax, eax
  000d5	74 06		 je	 SHORT $LN1@gzgets
  000d7	83 7d f8 00	 cmp	 DWORD PTR _eol$1$[ebp], 0
  000db	74 97		 je	 SHORT $LL9@gzgets
$LN1@gzgets:
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _str$1$[ebp]
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  000e2	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000e5	5b		 pop	 ebx

; 599  :     return str;
; 600  : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN23@gzgets:

; 576  :                 if (buf == str)         /* got bupkus */

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _str$1$[ebp]
  000ed	3b d8		 cmp	 ebx, eax
  000ef	75 0b		 jne	 SHORT $LN7@gzgets
$LN15@gzgets:
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi

; 551  :         return NULL;

  000f3	33 c0		 xor	 eax, eax
  000f5	5b		 pop	 ebx

; 599  :     return str;
; 600  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
$LN25@gzgets:
  000fa	8b c3		 mov	 eax, ebx
$LN7@gzgets:
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  000fe	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00101	5b		 pop	 ebx

; 599  :     return str;
; 600  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzread.c
;	COMDAT _gzread
_TEXT	SEGMENT
_got$1$ = -4						; size = 4
_n$ = 8							; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzread	PROC						; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 367  :     unsigned got, n;
; 368  :     gz_statep state;
; 369  :     z_streamp strm;
; 370  : 
; 371  :     /* get internal structure */
; 372  :     if (file == NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	75 08		 jne	 SHORT $LN22@gzread
$LN20@gzread:

; 373  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	5e		 pop	 esi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN22@gzread:

; 374  :     state = (gz_statep)file;
; 375  :     strm = &(state->strm);
; 376  : 
; 377  :     /* check that we're reading and that there's no error */
; 378  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00014	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  0001a	75 f0		 jne	 SHORT $LN20@gzread
  0001c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00020	75 ea		 jne	 SHORT $LN20@gzread

; 379  :         return -1;
; 380  : 
; 381  :     /* since an int is returned, make sure len fits in one, otherwise return
; 382  :        with an error (this avoids the flaw in the interface) */
; 383  :     if ((int)len < 0) {

  00022	53		 push	 ebx
  00023	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00026	85 db		 test	 ebx, ebx
  00028	79 19		 jns	 SHORT $LN35@gzread

; 384  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0002f	6a fb		 push	 -5			; fffffffbH
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _gz_error
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gzread:

; 385  :         return -1;

  0003a	5b		 pop	 ebx
  0003b	83 c8 ff	 or	 eax, -1
  0003e	5e		 pop	 esi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN35@gzread:

; 386  :     }
; 387  : 
; 388  :     /* if len is zero, avoid unnecessary operations */
; 389  :     if (len == 0)

  00043	75 08		 jne	 SHORT $LN18@gzread

; 390  :         return 0;

  00045	5b		 pop	 ebx
  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN18@gzread:

; 391  : 
; 392  :     /* process a skip request */
; 393  :     if (state->seek) {

  0004d	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00051	74 18		 je	 SHORT $LN16@gzread

; 394  :         state->seek = 0;
; 395  :         if (gz_skip(state, state->skip) == -1)

  00053	ff 76 44	 push	 DWORD PTR [esi+68]
  00056	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 _gz_skip
  00063	83 c4 08	 add	 esp, 8
  00066	83 f8 ff	 cmp	 eax, -1
  00069	74 cf		 je	 SHORT $LN36@gzread
$LN16@gzread:

; 396  :             return -1;
; 397  :     }
; 398  : 
; 399  :     /* get len bytes to buf, or less than len if at the end */
; 400  :     got = 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	89 45 fc	 mov	 DWORD PTR _got$1$[ebp], eax
  00070	57		 push	 edi
$LL15@gzread:

; 401  :     do {
; 402  :         /* first just try copying data from the output buffer */
; 403  :         if (state->have) {

  00071	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00074	85 ff		 test	 edi, edi
  00076	74 20		 je	 SHORT $LN12@gzread

; 404  :             n = state->have > len ? len : state->have;
; 405  :             memcpy(buf, state->next, n);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0007b	3b fb		 cmp	 edi, ebx
  0007d	0f 47 fb	 cmova	 edi, ebx
  00080	57		 push	 edi
  00081	ff 76 20	 push	 DWORD PTR [esi+32]
  00084	89 7d 08	 mov	 DWORD PTR _n$[ebp], edi
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memcpy

; 406  :             state->next += n;

  0008d	01 7e 20	 add	 DWORD PTR [esi+32], edi
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  :             state->have -= n;

  00093	29 7e 24	 sub	 DWORD PTR [esi+36], edi
  00096	eb 65		 jmp	 SHORT $LN2@gzread
$LN12@gzread:

; 408  :         }
; 409  : 
; 410  :         /* output buffer empty -- return if we're at the end of the input */
; 411  :         else if (state->eof && strm->avail_in == 0)

  00098	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0009c	74 0a		 je	 SHORT $LN10@gzread
  0009e	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000a2	0f 84 8a 00 00
	00		 je	 $LN34@gzread
$LN10@gzread:

; 412  :             break;
; 413  : 
; 414  :         /* need output data -- for small len or new stream load up our output
; 415  :            buffer */
; 416  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000a8	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 60		 je	 SHORT $LN7@gzread
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	03 c0		 add	 eax, eax
  000b4	3b d8		 cmp	 ebx, eax
  000b6	72 57		 jb	 SHORT $LN7@gzread

; 420  :             continue;       /* no progress yet -- go back to memcpy() above */
; 421  :             /* the copy above assures that we will leave with space in the
; 422  :                output buffer, allowing at least one gzungetc() to succeed */
; 423  :         }
; 424  : 
; 425  :         /* large len -- read directly into user buffer */
; 426  :         else if (state->how == COPY) {      /* read directly */

  000b8	83 f9 01	 cmp	 ecx, 1
  000bb	75 1c		 jne	 SHORT $LN4@gzread

; 427  :             if (gz_load(state, buf, len, &n) == -1)

  000bd	8d 45 08	 lea	 eax, DWORD PTR _n$[ebp]
  000c0	50		 push	 eax
  000c1	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	56		 push	 esi
  000c7	e8 00 00 00 00	 call	 _gz_load
  000cc	83 c4 10	 add	 esp, 16			; 00000010H
  000cf	83 f8 ff	 cmp	 eax, -1
  000d2	74 5b		 je	 SHORT $LN31@gzread

; 428  :                 return -1;
; 429  :         }
; 430  : 
; 431  :         /* large len -- decompress directly into user buffer */
; 432  :         else {  /* state->how == GZIP */

  000d4	8b 7d 08	 mov	 edi, DWORD PTR _n$[ebp]
  000d7	eb 24		 jmp	 SHORT $LN2@gzread
$LN4@gzread:

; 433  :             strm->avail_out = len;
; 434  :             strm->next_out = buf;

  000d9	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 435  :             if (gz_decomp(state) == -1)

  000dc	56		 push	 esi
  000dd	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  000e0	89 46 60	 mov	 DWORD PTR [esi+96], eax
  000e3	e8 00 00 00 00	 call	 _gz_decomp
  000e8	83 c4 04	 add	 esp, 4
  000eb	83 f8 ff	 cmp	 eax, -1
  000ee	74 3f		 je	 SHORT $LN31@gzread

; 436  :                 return -1;
; 437  :             n = state->have;

  000f0	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  000f3	89 7d 08	 mov	 DWORD PTR _n$[ebp], edi

; 438  :             state->have = 0;

  000f6	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$LN2@gzread:

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;
; 443  :         buf = (char *)buf + n;
; 444  :         got += n;

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _got$1$[ebp]
  00100	01 7d 0c	 add	 DWORD PTR _buf$[ebp], edi
  00103	03 c7		 add	 eax, edi
  00105	2b df		 sub	 ebx, edi

; 445  :         state->pos += n;

  00107	01 7e 0c	 add	 DWORD PTR [esi+12], edi
  0010a	89 45 fc	 mov	 DWORD PTR _got$1$[ebp], eax
  0010d	eb 11		 jmp	 SHORT $LN14@gzread
$LN7@gzread:

; 417  :             /* get more output, looking for header if required */
; 418  :             if (gz_make(state) == -1)

  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 _gz_make
  00115	83 c4 04	 add	 esp, 4
  00118	83 f8 ff	 cmp	 eax, -1
  0011b	74 12		 je	 SHORT $LN31@gzread
  0011d	8b 45 fc	 mov	 eax, DWORD PTR _got$1$[ebp]
$LN14@gzread:

; 446  :     } while (len);

  00120	85 db		 test	 ebx, ebx
  00122	0f 85 49 ff ff
	ff		 jne	 $LL15@gzread
  00128	5f		 pop	 edi
  00129	5b		 pop	 ebx
  0012a	5e		 pop	 esi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
$LN31@gzread:

; 419  :                 return -1;

  0012f	83 c8 ff	 or	 eax, -1
$LN34@gzread:
  00132	5f		 pop	 edi
  00133	5b		 pop	 ebx
  00134	5e		 pop	 esi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
_gzread	ENDP
_TEXT	ENDS
END
