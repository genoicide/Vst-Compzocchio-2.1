; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
CONST	ENDS
PUBLIC	_inflate
PUBLIC	_inflateEnd
PUBLIC	_inflateSetDictionary
PUBLIC	_inflateSync
PUBLIC	_inflateCopy
PUBLIC	_inflateReset
PUBLIC	_inflateReset2
PUBLIC	_inflatePrime
PUBLIC	_inflateMark
PUBLIC	_inflateGetHeader
PUBLIC	_inflateInit_
PUBLIC	_inflateInit2_
PUBLIC	_inflateSyncPoint
PUBLIC	_inflateUndermine
PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
EXTRN	_adler32:PROC
EXTRN	_crc32:PROC
EXTRN	_zcalloc:PROC
EXTRN	_zcfree:PROC
EXTRN	_inflate_table:PROC
EXTRN	_inflate_fast:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _have$[ebp]
  00006	56		 push	 esi
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	57		 push	 edi

; 1331 :     next = 0;
; 1332 :     while (next < len && got < 4) {

  0000a	8b 7d 10	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	85 ff		 test	 edi, edi
  00011	74 49		 je	 SHORT $LN12@syncsearch
  00013	53		 push	 ebx
$LL6@syncsearch:
  00014	83 f8 04	 cmp	 eax, 4
  00017	73 37		 jae	 SHORT $LN13@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0001c	83 f8 02	 cmp	 eax, 2
  0001f	8a 1c 0e	 mov	 bl, BYTE PTR [esi+ecx]
  00022	1b d2		 sbb	 edx, edx
  00024	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  0002a	0f b6 cb	 movzx	 ecx, bl
  0002d	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  00033	3b ca		 cmp	 ecx, edx
  00035	75 03		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00037	40		 inc	 eax
  00038	eb 11		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  0003a	84 db		 test	 bl, bl
  0003c	74 04		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  0003e	33 c0		 xor	 eax, eax

; 1337 :         else

  00040	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	2b c8		 sub	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
$LN1@syncsearch:

; 1339 :         next++;

  0004b	46		 inc	 esi
  0004c	3b f7		 cmp	 esi, edi
  0004e	72 c4		 jb	 SHORT $LL6@syncsearch
$LN13@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _have$[ebp]
  00053	5b		 pop	 ebx
  00054	89 01		 mov	 DWORD PTR [ecx], eax
  00056	5f		 pop	 edi

; 1342 :     return next;

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 1343 : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN12@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  0005c	89 01		 mov	 DWORD PTR [ecx], eax
  0005e	5f		 pop	 edi

; 1342 :     return next;

  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi

; 1343 : }

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_out$ = 12						; size = 4
_updatewindow PROC					; COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  0000a	57		 push	 edi

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0000b	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0000f	bf 01 00 00 00	 mov	 edi, 1
  00014	75 24		 jne	 SHORT $LN9@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00016	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00019	8b c7		 mov	 eax, edi
  0001b	d3 e0		 shl	 eax, cl
  0001d	57		 push	 edi
  0001e	50		 push	 eax
  0001f	ff 72 28	 push	 DWORD PTR [edx+40]
  00022	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00025	ff d0		 call	 eax
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 372  :         if (state->window == Z_NULL) return 1;

  0002d	85 c0		 test	 eax, eax
  0002f	75 06		 jne	 SHORT $LN13@updatewind
  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 406  : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN13@updatewind:
  00037	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
$LN9@updatewind:

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  0003a	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0003e	75 16		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  00040	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00043	d3 e7		 shl	 edi, cl

; 378  :         state->wnext = 0;

  00045	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 379  :         state->whave = 0;

  0004c	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  00053	89 7e 28	 mov	 DWORD PTR [esi+40], edi
$LN8@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;
; 384  :     if (copy >= state->wsize) {

  00056	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  00059	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005c	53		 push	 ebx
  0005d	8b 5d 0c	 mov	 ebx, DWORD PTR _out$[ebp]
  00060	2b 5a 10	 sub	 ebx, DWORD PTR [edx+16]
  00063	3b df		 cmp	 ebx, edi
  00065	72 23		 jb	 SHORT $LN7@updatewind
  00067	57		 push	 edi
  00068	2b c7		 sub	 eax, edi
  0006a	50		 push	 eax
  0006b	ff 76 34	 push	 DWORD PTR [esi+52]
  0006e	e8 00 00 00 00	 call	 _memcpy

; 386  :         state->wnext = 0;
; 387  :         state->whave = state->wsize;

  00073	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  00079	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0007c	5b		 pop	 ebx
  0007d	5f		 pop	 edi
  0007e	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 403  :         }
; 404  :     }
; 405  :     return 0;

  00085	33 c0		 xor	 eax, eax
  00087	5e		 pop	 esi

; 406  : }

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN7@updatewind:

; 388  :     }
; 389  :     else {
; 390  :         dist = state->wsize - state->wnext;

  0008a	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 391  :         if (dist > copy) dist = copy;

  0008d	3b fb		 cmp	 edi, ebx
  0008f	0f 47 fb	 cmova	 edi, ebx

; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  00092	2b c3		 sub	 eax, ebx
  00094	57		 push	 edi
  00095	50		 push	 eax
  00096	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00099	03 46 30	 add	 eax, DWORD PTR [esi+48]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _memcpy
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  :         copy -= dist;

  000a5	2b df		 sub	 ebx, edi

; 394  :         if (copy) {

  000a7	74 25		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000ac	53		 push	 ebx
  000ad	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 34	 push	 DWORD PTR [esi+52]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 396  :             state->wnext = copy;
; 397  :             state->whave = state->wsize;

  000bb	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  000c4	5b		 pop	 ebx

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  000c5	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000c8	5f		 pop	 edi

; 403  :         }
; 404  :     }
; 405  :     return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5e		 pop	 esi

; 406  : }

  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN4@updatewind:

; 398  :         }
; 399  :         else {
; 400  :             state->wnext += dist;

  000ce	01 7e 30	 add	 DWORD PTR [esi+48], edi

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000d4	33 d2		 xor	 edx, edx
  000d6	3b 46 28	 cmp	 eax, DWORD PTR [esi+40]
  000d9	0f 44 c2	 cmove	 eax, edx
  000dc	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  000df	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000e2	3b 46 28	 cmp	 eax, DWORD PTR [esi+40]
  000e5	73 05		 jae	 SHORT $LN1@updatewind
  000e7	03 c7		 add	 eax, edi
  000e9	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN1@updatewind:

; 403  :         }
; 404  :     }
; 405  :     return 0;

  000ec	5b		 pop	 ebx
  000ed	5f		 pop	 edi
  000ee	33 c0		 xor	 eax, eax
  000f0	5e		 pop	 esi

; 406  : }

  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 278  :     state->lenbits = 9;

  0000d	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 279  :     state->distcode = distfix;

  00014	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 280  :     state->distbits = 5;

  0001b	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 281  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateUndermine
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine PROC					; COMDAT

; 1456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 18		 je	 SHORT $LN1@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 11		 je	 SHORT $LN1@inflateUnd

; 1460 :     state = (struct inflate_state FAR *)strm->state;
; 1461 :     state->sane = !subvert;
; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1466 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1467 : #endif
; 1468 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN1@inflateUnd:

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1467 : #endif
; 1468 : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateSyncPoint
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint PROC					; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1d		 je	 SHORT $LN1@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 16		 je	 SHORT $LN1@inflateSyn

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0d		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 07		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1404 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN5@inflateSyn:

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  00023	33 c0		 xor	 eax, eax

; 1404 : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@inflateSyn:

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00027	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1404 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateInit2_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_ PROC					; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 a0 00 00
	00		 je	 $LN6@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 97 00 00
	00		 jne	 $LN6@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 8d 00 00
	00		 jne	 $LN6@inflateIni

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 06		 jne	 SHORT $LN5@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 199  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN5@inflateIni:

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 182  :     if (strm->zalloc == (alloc_func)0) {

  0002f	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00033	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003a	75 0e		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  0003c	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 184  :         strm->opaque = (voidpf)0;

  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0004a	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  0004e	75 07		 jne	 SHORT $LN3@inflateIni
  00050	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN3@inflateIni:

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00057	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005a	57		 push	 edi
  0005b	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00060	6a 01		 push	 1
  00062	ff 76 28	 push	 DWORD PTR [esi+40]
  00065	ff d0		 call	 eax
  00067	8b f8		 mov	 edi, eax
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006c	85 ff		 test	 edi, edi
  0006e	75 07		 jne	 SHORT $LN2@inflateIni
  00070	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi

; 199  : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
$LN2@inflateIni:
  00077	53		 push	 ebx

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;
; 192  :     state->window = Z_NULL;
; 193  :     ret = inflateReset2(strm, windowBits);

  00078	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007b	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0007e	56		 push	 esi
  0007f	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  00086	e8 00 00 00 00	 call	 _inflateReset2
  0008b	8b d8		 mov	 ebx, eax
  0008d	83 c4 08	 add	 esp, 8

; 194  :     if (ret != Z_OK) {

  00090	85 db		 test	 ebx, ebx
  00092	74 13		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  00094	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00097	57		 push	 edi
  00098	ff 76 28	 push	 DWORD PTR [esi+40]
  0009b	ff d1		 call	 ecx
  0009d	83 c4 08	 add	 esp, 8

; 196  :         strm->state = Z_NULL;

  000a0	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  000a7	8b c3		 mov	 eax, ebx
  000a9	5b		 pop	 ebx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi

; 199  : }

  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  000ae	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 199  : }

  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
_inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_ PROC					; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 207  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateGetHeader
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader PROC					; COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1e		 je	 SHORT $LN2@inflateGet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 17		 je	 SHORT $LN2@inflateGet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 41 08 02	 test	 BYTE PTR [ecx+8], 2
  00015	74 11		 je	 SHORT $LN2@inflateGet

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1307 :     head->done = 0;

  0001d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1308 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1309 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN2@inflateGet:

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00028	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1309 : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateMark
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark PROC					; COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 48		 je	 SHORT $LN1@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 41		 je	 SHORT $LN1@inflateMar

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 10		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1480 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN7@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00028	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002b	75 16		 jne	 SHORT $LN5@inflateMar
  0002d	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00033	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00036	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0003f	03 c1		 add	 eax, ecx

; 1480 : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN5@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00043	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00049	33 c9		 xor	 ecx, ecx
  0004b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0004e	03 c1		 add	 eax, ecx

; 1480 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN1@inflateMar:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00052	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1480 : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflatePrime
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime PROC					; COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 56		 je	 SHORT $LN4@inflatePri
  0000a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 4f		 je	 SHORT $LN4@inflatePri

; 217  :     state = (struct inflate_state FAR *)strm->state;
; 218  :     if (bits < 0) {

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	79 12		 jns	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00018	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 220  :         state->bits = 0;

  0001f	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 221  :         return Z_OK;

  00026	33 c0		 xor	 eax, eax

; 228  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN3@inflatePri:
  0002a	56		 push	 esi
  0002b	57		 push	 edi

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0002c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002f	7f 26		 jg	 SHORT $LN1@inflatePri
  00031	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  00034	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00037	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003a	77 1b		 ja	 SHORT $LN1@inflatePri

; 224  :     value &= (1L << bits) - 1;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d3 e0		 shl	 eax, cl

; 225  :     state->hold += value << state->bits;

  00043	8b ce		 mov	 ecx, esi

; 226  :     state->bits += bits;

  00045	89 7a 3c	 mov	 DWORD PTR [edx+60], edi
  00048	5f		 pop	 edi
  00049	48		 dec	 eax
  0004a	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004d	5e		 pop	 esi
  0004e	d3 e0		 shl	 eax, cl
  00050	01 42 38	 add	 DWORD PTR [edx+56], eax

; 227  :     return Z_OK;

  00053	33 c0		 xor	 eax, eax

; 228  : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN1@inflatePri:
  00057	5f		 pop	 edi

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00058	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005d	5e		 pop	 esi

; 228  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN4@inflatePri:

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00060	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 228  : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateReset2
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2 PROC					; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 c0		 test	 eax, eax
  00009	74 72		 je	 SHORT $LN7@inflateRes
  0000b	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0000e	85 ff		 test	 edi, edi
  00010	74 6b		 je	 SHORT $LN7@inflateRes

; 139  :     state = (struct inflate_state FAR *)strm->state;
; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN6@inflateRes

; 143  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 144  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 145  :     }
; 146  :     else {

  0001f	eb 0e		 jmp	 SHORT $LN4@inflateRes
$LN6@inflateRes:

; 147  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN4@inflateRes

; 150  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN4@inflateRes:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 14		 je	 SHORT $LN3@inflateRes
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 05		 jl	 SHORT $LN2@inflateRes
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7e 0a		 jle	 SHORT $LN3@inflateRes
$LN2@inflateRes:
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 156  :         return Z_STREAM_ERROR;

  0003f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00044	5f		 pop	 edi

; 166  : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN3@inflateRes:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00047	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 1b		 je	 SHORT $LN1@inflateRes
  0004e	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00051	74 16		 je	 SHORT $LN1@inflateRes

; 158  :         ZFREE(strm, state->window);

  00053	51		 push	 ecx
  00054	ff 70 28	 push	 DWORD PTR [eax+40]
  00057	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0005a	ff d0		 call	 eax
  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	83 c4 08	 add	 esp, 8

; 159  :         state->window = Z_NULL;

  00062	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN1@inflateRes:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;
; 164  :     state->wbits = (unsigned)windowBits;
; 165  :     return inflateReset(strm);

  00069	50		 push	 eax
  0006a	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0006d	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00070	e8 00 00 00 00	 call	 _inflateReset
  00075	83 c4 04	 add	 esp, 4
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	5f		 pop	 edi

; 166  : }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN7@inflateRes:

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00082	5f		 pop	 edi

; 166  : }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateReset
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 9a 00 00
	00		 je	 $LN1@inflateRes
  0000e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 8f 00 00
	00		 je	 $LN1@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00019	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00020	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 111  :     strm->msg = Z_NULL;

  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  00035	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 113  :     state->mode = HEAD;
; 114  :     state->last = 0;
; 115  :     state->havedict = 0;
; 116  :     state->dmax = 32768U;
; 117  :     state->head = Z_NULL;
; 118  :     state->wsize = 0;
; 119  :     state->whave = 0;
; 120  :     state->wnext = 0;
; 121  :     state->hold = 0;
; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  0003c	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00042	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00045	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00048	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  0004b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00051	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00058	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0005f	c7 41 14 00 80
	00 00		 mov	 DWORD PTR [ecx+20], 32768 ; 00008000H
  00066	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0006d	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00074	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  0007b	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  00082	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  00089	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 124  :     state->sane = 1;

  00090	c7 81 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7104], 1

; 125  :     state->back = -1;

  0009a	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  000a4	33 c0		 xor	 eax, eax

; 128  : }

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN1@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000a8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 128  : }

  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateCopy
_TEXT	SEGMENT
_copy$1$ = -8						; size = 4
_window$1$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy PROC					; COMDAT

; 1409 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00006	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	0f 84 31 01 00
	00		 je	 $LN6@inflateCop
  00012	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00015	85 f6		 test	 esi, esi
  00017	0f 84 26 01 00
	00		 je	 $LN6@inflateCop
  0001d	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00020	85 db		 test	 ebx, ebx
  00022	0f 84 1b 01 00
	00		 je	 $LN6@inflateCop
  00028	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 10 01 00
	00		 je	 $LN6@inflateCop
  00033	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00037	0f 84 06 01 00
	00		 je	 $LN6@inflateCop

; 1419 :     state = (struct inflate_state FAR *)source->state;
; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0003d	57		 push	 edi
  0003e	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00043	6a 01		 push	 1
  00045	ff 76 28	 push	 DWORD PTR [esi+40]
  00048	ff d0		 call	 eax
  0004a	8b f8		 mov	 edi, eax
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	89 7d f8	 mov	 DWORD PTR _copy$1$[ebp], edi

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00052	85 ff		 test	 edi, edi
  00054	74 38		 je	 SHORT $LN11@inflateCop

; 1425 :     window = Z_NULL;
; 1426 :     if (state->window != Z_NULL) {

  00056	83 7b 34 00	 cmp	 DWORD PTR [ebx+52], 0
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00061	74 37		 je	 SHORT $LN3@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  00063	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	d3 e0		 shl	 eax, cl
  0006d	6a 01		 push	 1
  0006f	50		 push	 eax
  00070	ff 76 28	 push	 DWORD PTR [esi+40]
  00073	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00076	ff d0		 call	 eax
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 fc	 mov	 DWORD PTR _window$1$[ebp], eax

; 1429 :         if (window == Z_NULL) {

  0007e	85 c0		 test	 eax, eax
  00080	75 18		 jne	 SHORT $LN3@inflateCop

; 1430 :             ZFREE(source, copy);

  00082	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00085	57		 push	 edi
  00086	ff 76 28	 push	 DWORD PTR [esi+40]
  00089	ff d0		 call	 eax
  0008b	83 c4 08	 add	 esp, 8
$LN11@inflateCop:

; 1431 :             return Z_MEM_ERROR;

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00095	5b		 pop	 ebx

; 1451 : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
$LN3@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  0009a	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
  0009d	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  000a2	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000a7	f3 a5		 rep movsd
  000a9	8b 75 f8	 mov	 esi, DWORD PTR _copy$1$[ebp]
  000ac	53		 push	 ebx
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 _memcpy

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  000b3	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000b6	8d 83 30 05 00
	00		 lea	 eax, DWORD PTR [ebx+1328]
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	3b c8		 cmp	 ecx, eax
  000c1	72 38		 jb	 SHORT $LN2@inflateCop
  000c3	8d 83 bc 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7100]
  000c9	3b c8		 cmp	 ecx, eax
  000cb	77 2e		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000cd	2b cb		 sub	 ecx, ebx
  000cf	8d 81 d0 fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1328]
  000d5	c1 f8 02	 sar	 eax, 2
  000d8	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000dd	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e0	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e3	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  000e6	2b c3		 sub	 eax, ebx
  000e8	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  000ed	c1 f8 02	 sar	 eax, 2
  000f0	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000f5	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f8	89 46 50	 mov	 DWORD PTR [esi+80], eax
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  000fb	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]

; 1444 :     if (window != Z_NULL) {

  000fe	8b 7d fc	 mov	 edi, DWORD PTR _window$1$[ebp]
  00101	2b c3		 sub	 eax, ebx
  00103	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00108	c1 f8 02	 sar	 eax, 2
  0010b	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00110	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00113	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00116	85 ff		 test	 edi, edi
  00118	74 17		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  0011a	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	d3 e0		 shl	 eax, cl

; 1446 :         zmemcpy(window, state->window, wsize);

  00124	50		 push	 eax
  00125	ff 73 34	 push	 DWORD PTR [ebx+52]
  00128	57		 push	 edi
  00129	e8 00 00 00 00	 call	 _memcpy
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;
; 1449 :     dest->state = (struct internal_state FAR *)copy;

  00131	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00134	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  00137	5f		 pop	 edi
  00138	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  0013b	5e		 pop	 esi

; 1450 :     return Z_OK;

  0013c	33 c0		 xor	 eax, eax
  0013e	5b		 pop	 ebx

; 1451 : }

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
$LN6@inflateCop:
  00143	5e		 pop	 esi

; 1418 :         return Z_STREAM_ERROR;

  00144	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00149	5b		 pop	 ebx

; 1451 : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
_inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateSync
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync PROC					; COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 c6 00 00
	00		 je	 $LN6@inflateSyn
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 bb 00 00
	00		 je	 $LN6@inflateSyn

; 1355 :     state = (struct inflate_state FAR *)strm->state;
; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 0f		 jne	 SHORT $LN5@inflateSyn
  00021	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00025	73 09		 jae	 SHORT $LN5@inflateSyn
  00027	5f		 pop	 edi
  00028	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0002d	5b		 pop	 ebx

; 1386 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN5@inflateSyn:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  00030	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00033	56		 push	 esi
  00034	74 50		 je	 SHORT $LN4@inflateSyn

; 1360 :         state->mode = SYNC;
; 1361 :         state->hold <<= state->bits & 7;

  00036	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  00039	8b ca		 mov	 ecx, edx
  0003b	83 e1 07	 and	 ecx, 7
  0003e	d3 67 38	 shl	 DWORD PTR [edi+56], cl

; 1362 :         state->bits -= state->bits & 7;

  00041	2b d1		 sub	 edx, ecx

; 1363 :         len = 0;

  00043	33 c9		 xor	 ecx, ecx
  00045	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  0004b	89 57 3c	 mov	 DWORD PTR [edi+60], edx

; 1364 :         while (state->bits >= 8) {

  0004e	83 fa 08	 cmp	 edx, 8
  00051	72 1c		 jb	 SHORT $LN2@inflateSyn
  00053	8b 77 38	 mov	 esi, DWORD PTR [edi+56]
$LL3@inflateSyn:

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  00056	8a 47 38	 mov	 al, BYTE PTR [edi+56]
  00059	88 44 0d 08	 mov	 BYTE PTR _buf$[ebp+ecx], al

; 1366 :             state->hold >>= 8;

  0005d	c1 ee 08	 shr	 esi, 8

; 1367 :             state->bits -= 8;

  00060	83 ea 08	 sub	 edx, 8
  00063	41		 inc	 ecx
  00064	89 77 38	 mov	 DWORD PTR [edi+56], esi
  00067	83 fa 08	 cmp	 edx, 8
  0006a	73 ea		 jae	 SHORT $LL3@inflateSyn
  0006c	89 57 3c	 mov	 DWORD PTR [edi+60], edx
$LN2@inflateSyn:

; 1368 :         }
; 1369 :         state->have = 0;
; 1370 :         syncsearch(&(state->have), buf, len);

  0006f	51		 push	 ecx
  00070	8d 4d 08	 lea	 ecx, DWORD PTR _buf$[ebp]
  00073	8d 47 68	 lea	 eax, DWORD PTR [edi+104]
  00076	51		 push	 ecx
  00077	50		 push	 eax
  00078	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0007e	e8 00 00 00 00	 call	 _syncsearch
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@inflateSyn:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00086	ff 73 04	 push	 DWORD PTR [ebx+4]
  00089	8d 77 68	 lea	 esi, DWORD PTR [edi+104]
  0008c	ff 33		 push	 DWORD PTR [ebx]
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 _syncsearch

; 1375 :     strm->avail_in -= len;

  00094	29 43 04	 sub	 DWORD PTR [ebx+4], eax

; 1376 :     strm->next_in += len;

  00097	01 03		 add	 DWORD PTR [ebx], eax

; 1377 :     strm->total_in += len;

  00099	01 43 08	 add	 DWORD PTR [ebx+8], eax
  0009c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  000a2	83 3e 04	 cmp	 DWORD PTR [esi], 4
  000a5	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000a8	74 0a		 je	 SHORT $LN1@inflateSyn
  000aa	5e		 pop	 esi
  000ab	5f		 pop	 edi
  000ac	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b1	5b		 pop	 ebx

; 1386 : }

  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN1@inflateSyn:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  000b4	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1382 :     inflateReset(strm);

  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 _inflateReset

; 1383 :     strm->total_in = in;  strm->total_out = out;

  000bd	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000c0	83 c4 04	 add	 esp, 4
  000c3	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000c6	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000c9	5e		 pop	 esi

; 1384 :     state->mode = TYPE;

  000ca	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000d0	5f		 pop	 edi

; 1385 :     return Z_OK;

  000d1	33 c0		 xor	 eax, eax
  000d3	5b		 pop	 ebx

; 1386 : }

  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN6@inflateSyn:
  000d6	5f		 pop	 edi

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000d7	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000dc	5b		 pop	 ebx

; 1386 : }

  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateSetDictionary
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary PROC				; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	0f 84 c4 00 00
	00		 je	 $LN7@inflateSet
  00010	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 b9 00 00
	00		 je	 $LN7@inflateSet

; 1262 :     state = (struct inflate_state FAR *)strm->state;
; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  0001b	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001f	53		 push	 ebx
  00020	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  00023	74 0f		 je	 SHORT $LN6@inflateSet
  00025	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00028	74 0f		 je	 SHORT $LN11@inflateSet

; 1264 :         return Z_STREAM_ERROR;

  0002a	5b		 pop	 ebx
  0002b	5f		 pop	 edi
  0002c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00031	5e		 pop	 esi

; 1292 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN6@inflateSet:

; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  00034	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00037	75 27		 jne	 SHORT $LN4@inflateSet
$LN11@inflateSet:

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	e8 00 00 00 00	 call	 _adler32

; 1269 :         id = adler32(id, dictionary, dictLength);

  00044	53		 push	 ebx
  00045	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _adler32
  0004e	83 c4 18	 add	 esp, 24			; 00000018H

; 1270 :         if (id != state->check)

  00051	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  00054	74 0a		 je	 SHORT $LN4@inflateSet

; 1271 :             return Z_DATA_ERROR;

  00056	5b		 pop	 ebx
  00057	5f		 pop	 edi
  00058	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0005d	5e		 pop	 esi

; 1292 : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN4@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  00060	ff 77 10	 push	 DWORD PTR [edi+16]
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 _updatewindow
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	74 10		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  00070	5b		 pop	 ebx
  00071	5f		 pop	 edi
  00072	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH

; 1277 :         return Z_MEM_ERROR;

  00078	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007d	5e		 pop	 esi

; 1292 : }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  00080	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00083	3b d9		 cmp	 ebx, ecx
  00085	76 28		 jbe	 SHORT $LN2@inflateSet

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  00087	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  0008a	2b c1		 sub	 eax, ecx
  0008c	51		 push	 ecx
  0008d	03 c3		 add	 eax, ebx
  0008f	50		 push	 eax
  00090	ff 76 34	 push	 DWORD PTR [esi+52]
  00093	e8 00 00 00 00	 call	 _memcpy

; 1282 :         state->whave = state->wsize;

  00098	8b 46 28	 mov	 eax, DWORD PTR [esi+40]

; 1283 :     }
; 1284 :     else {
; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000a1	5b		 pop	 ebx
  000a2	5f		 pop	 edi

; 1288 :     }
; 1289 :     state->havedict = 1;

  000a3	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000aa	33 c0		 xor	 eax, eax
  000ac	5e		 pop	 esi

; 1292 : }

  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN2@inflateSet:

; 1283 :     }
; 1284 :     else {
; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  000af	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000b2	53		 push	 ebx
  000b3	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  000b6	2b c3		 sub	 eax, ebx
  000b8	03 c1		 add	 eax, ecx
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1287 :         state->whave = dictLength;

  000c3	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  000c6	5b		 pop	 ebx
  000c7	5f		 pop	 edi

; 1288 :     }
; 1289 :     state->havedict = 1;

  000c8	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000cf	33 c0		 xor	 eax, eax
  000d1	5e		 pop	 esi

; 1292 : }

  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN7@inflateSet:
  000d4	5f		 pop	 edi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000d5	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000da	5e		 pop	 esi

; 1292 : }

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflateEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd PROC					; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 38		 je	 SHORT $LN2@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 31		 je	 SHORT $LN2@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2a		 je	 SHORT $LN2@inflateEnd

; 1244 :     state = (struct inflate_state FAR *)strm->state;
; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN1@inflateEnd
  00020	50		 push	 eax
  00021	ff 76 28	 push	 DWORD PTR [esi+40]
  00024	ff d1		 call	 ecx
  00026	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  00029	ff 76 1c	 push	 DWORD PTR [esi+28]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff 76 28	 push	 DWORD PTR [esi+40]
  00032	ff d0		 call	 eax
  00034	83 c4 08	 add	 esp, 8

; 1247 :     strm->state = Z_NULL;

  00037	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 1250 : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  00043	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00048	5e		 pop	 esi

; 1250 : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inflate.c
;	COMDAT _inflate
_TEXT	SEGMENT
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
_copy$9$ = -52						; size = 4
tv2857 = -52						; size = 4
tv2807 = -52						; size = 4
tv2806 = -52						; size = 4
tv2799 = -52						; size = 4
tv2786 = -52						; size = 4
tv2779 = -52						; size = 4
tv2777 = -52						; size = 4
tv2768 = -52						; size = 4
tv2767 = -52						; size = 4
tv2766 = -52						; size = 4
tv2755 = -52						; size = 4
tv2754 = -52						; size = 4
tv2752 = -52						; size = 4
tv2716 = -52						; size = 4
_copy$7$ = -52						; size = 4
_copy$4$ = -52						; size = 4
_copy$3$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_len$5$ = -52						; size = 4
_len$1$ = -52						; size = 4
_from$1$ = -48						; size = 4
_copy$8$ = -48						; size = 4
tv2782 = -48						; size = 4
tv2780 = -48						; size = 4
tv2753 = -48						; size = 4
_copy$1$ = -48						; size = 4
_len$4$ = -48						; size = 4
_len$3$ = -48						; size = 4
_len$2$ = -48						; size = 4
_last$ = -48						; size = 4
_here$ = -48						; size = 4
_ret$1$ = -44						; size = 4
_copy$11$ = -40						; size = 4
tv2870 = -40						; size = 4
tv2809 = -40						; size = 4
tv2776 = -40						; size = 4
tv2775 = -40						; size = 4
tv2211 = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2781 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
tv2737 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate PROC						; COMDAT

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 ee 15 00
	00		 je	 $LN506@inflate
  00011	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00014	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 e0 15 00
	00		 je	 $LN506@inflate
  0001f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00023	0f 84 d6 15 00
	00		 je	 $LN506@inflate
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 0a		 jne	 SHORT $LN507@inflate
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	0f 85 c7 15 00
	00		 jne	 $LN506@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;
; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00038	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  0003b	75 06		 jne	 SHORT $LN504@inflate
  0003d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN504@inflate:

; 618  :     LOAD();

  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	53		 push	 ebx
  00047	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004a	89 55 e0	 mov	 DWORD PTR _put$1$[ebp], edx
  0004d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00050	56		 push	 esi
  00051	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00054	89 55 e8	 mov	 DWORD PTR _left$1$[ebp], edx
  00057	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005a	57		 push	 edi
  0005b	8b 38		 mov	 edi, DWORD PTR [eax]

; 619  :     in = have;
; 620  :     out = left;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  00060	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 621  :     ret = Z_OK;

  00063	33 c0		 xor	 eax, eax
  00065	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0006d	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00070	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00073	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00076	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00079	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0007c	0f 87 20 14 00
	00		 ja	 $LN11@inflate
$LL501@inflate:
  00082	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN855@inflate[eax*4]
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  00089	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008c	89 45 cc	 mov	 DWORD PTR tv2857[ebp], eax
  0008f	85 c0		 test	 eax, eax
  00091	75 0b		 jne	 SHORT $LN495@inflate

; 626  :                 state->mode = TYPEDO;

  00093	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH

; 627  :                 break;

  00099	e9 f9 13 00 00	 jmp	 $LN498@inflate
$LN495@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  0009e	83 fe 10	 cmp	 esi, 16			; 00000010H
  000a1	73 2d		 jae	 SHORT $LN494@inflate
$LL492@inflate:
  000a3	85 db		 test	 ebx, ebx
  000a5	0f 84 4b 14 00
	00		 je	 $LN809@inflate
  000ab	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000ae	8b ce		 mov	 ecx, esi
  000b0	d3 e0		 shl	 eax, cl
  000b2	83 c6 08	 add	 esi, 8
  000b5	4b		 dec	 ebx
  000b6	47		 inc	 edi
  000b7	03 d0		 add	 edx, eax
  000b9	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  000bc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000bf	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000c2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000c5	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c8	72 d9		 jb	 SHORT $LL492@inflate
  000ca	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000cd	8b 45 cc	 mov	 eax, DWORD PTR tv2857[ebp]
$LN494@inflate:

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000d0	a8 02		 test	 al, 2
  000d2	74 4b		 je	 SHORT $LN486@inflate
  000d4	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000da	75 43		 jne	 SHORT $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 _crc32
  000e7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 633  :                 CRC2(state->check, hold);

  000ea	6a 02		 push	 2
  000ec	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  000ef	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  000f2	50		 push	 eax
  000f3	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  000f9	ff 71 18	 push	 DWORD PTR [ecx+24]
  000fc	e8 00 00 00 00	 call	 _crc32
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 634  :                 INITBITS();

  00104	33 d2		 xor	 edx, edx
  00106	83 c4 18	 add	 esp, 24			; 00000018H
  00109	33 f6		 xor	 esi, esi
  0010b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0010e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00111	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 635  :                 state->mode = FLAGS;

  00114	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 636  :                 break;

  0011a	e9 78 13 00 00	 jmp	 $LN498@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */
; 639  :             if (state->head != Z_NULL)

  0011f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00122	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00129	85 c0		 test	 eax, eax
  0012b	74 07		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  0012d	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  00134	f6 41 08 01	 test	 BYTE PTR [ecx+8], 1
  00138	0f 84 b8 00 00
	00		 je	 $LN477@inflate
  0013e	0f b6 ca	 movzx	 ecx, dl
  00141	8b c2		 mov	 eax, edx
  00143	c1 e1 08	 shl	 ecx, 8
  00146	c1 e8 08	 shr	 eax, 8
  00149	03 c1		 add	 eax, ecx
  0014b	33 d2		 xor	 edx, edx
  0014d	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00152	f7 f1		 div	 ecx

; 652  :                 state->mode = BAD;

  00154	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00157	85 d2		 test	 edx, edx
  00159	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0015c	0f 85 94 00 00
	00		 jne	 $LN477@inflate

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  00162	8b c2		 mov	 eax, edx
  00164	24 0f		 and	 al, 15			; 0000000fH
  00166	3c 08		 cmp	 al, 8
  00168	74 0f		 je	 SHORT $LN475@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  0016a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0016d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 653  :                 break;

  00174	e9 18 13 00 00	 jmp	 $LN848@inflate
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);

  00179	c1 ea 04	 shr	 edx, 4

; 656  :             len = BITS(4) + 8;

  0017c	8b c2		 mov	 eax, edx
  0017e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00181	83 ee 04	 sub	 esi, 4
  00184	83 c0 08	 add	 eax, 8

; 657  :             if (state->wbits == 0)

  00187	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0018b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0018e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00191	89 45 cc	 mov	 DWORD PTR _len$1$[ebp], eax
  00194	75 4c		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  00196	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN470@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  00199	8b 4d cc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	d3 e0		 shl	 eax, cl
  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001a6	6a 00		 push	 0
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001af	e8 00 00 00 00	 call	 _adler32
  001b4	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001b7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001ba	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001bd	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001c0	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001c3	c1 ea 08	 shr	 edx, 8
  001c6	f7 d2		 not	 edx
  001c8	83 e2 02	 and	 edx, 2
  001cb	83 ca 09	 or	 edx, 9
  001ce	89 11		 mov	 DWORD PTR [ecx], edx

; 668  :             INITBITS();

  001d0	33 d2		 xor	 edx, edx
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d5	33 f6		 xor	 esi, esi
  001d7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001da	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 669  :             break;

  001dd	e9 b5 12 00 00	 jmp	 $LN498@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  001e2	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  001e5	76 b2		 jbe	 SHORT $LN470@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  001e7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001ea	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 661  :                 state->mode = BAD;
; 662  :                 break;

  001f1	e9 9b 12 00 00	 jmp	 $LN848@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  001f6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001f9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 647  :                 state->mode = BAD;
; 648  :                 break;

  00200	e9 8c 12 00 00	 jmp	 $LN848@inflate
$LN465@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00205	83 fe 10	 cmp	 esi, 16			; 00000010H
  00208	73 30		 jae	 SHORT $LN464@inflate
  0020a	8d 9b 00 00 00
	00		 npad	 6
$LL462@inflate:
  00210	85 db		 test	 ebx, ebx
  00212	0f 84 de 12 00
	00		 je	 $LN809@inflate
  00218	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0021b	8b ce		 mov	 ecx, esi
  0021d	d3 e0		 shl	 eax, cl
  0021f	83 c6 08	 add	 esi, 8
  00222	4b		 dec	 ebx
  00223	47		 inc	 edi
  00224	03 d0		 add	 edx, eax
  00226	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00229	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0022c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0022f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00232	83 fe 10	 cmp	 esi, 16			; 00000010H
  00235	72 d9		 jb	 SHORT $LL462@inflate
  00237	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN464@inflate:

; 673  :             state->flags = (int)(hold);

  0023a	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0023d	80 fa 08	 cmp	 dl, 8
  00240	74 0f		 je	 SHORT $LN456@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  00242	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00245	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 676  :                 state->mode = BAD;
; 677  :                 break;

  0024c	e9 40 12 00 00	 jmp	 $LN848@inflate
$LN456@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  00251	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00257	74 0f		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  00259	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0025c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 681  :                 state->mode = BAD;
; 682  :                 break;

  00263	e9 29 12 00 00	 jmp	 $LN848@inflate
$LN455@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00268	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0026b	85 f6		 test	 esi, esi
  0026d	74 0a		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  0026f	8b c2		 mov	 eax, edx
  00271	c1 e8 08	 shr	 eax, 8
  00274	83 e0 01	 and	 eax, 1
  00277	89 06		 mov	 DWORD PTR [esi], eax
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00279	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00280	74 20		 je	 SHORT $LN450@inflate
  00282	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00285	6a 02		 push	 2
  00287	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0028a	c1 ea 08	 shr	 edx, 8
  0028d	50		 push	 eax
  0028e	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00291	ff 71 18	 push	 DWORD PTR [ecx+24]
  00294	e8 00 00 00 00	 call	 _crc32
  00299	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0029c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN450@inflate:

; 687  :             INITBITS();

  002a2	33 d2		 xor	 edx, edx
  002a4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002a7	33 f6		 xor	 esi, esi

; 688  :             state->mode = TIME;

  002a9	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  002af	eb 05		 jmp	 SHORT $LL442@inflate
$LN445@inflate:
  002b1	83 fe 20	 cmp	 esi, 32			; 00000020H
  002b4	73 27		 jae	 SHORT $LN444@inflate
$LL442@inflate:
  002b6	85 db		 test	 ebx, ebx
  002b8	0f 84 38 12 00
	00		 je	 $LN809@inflate
  002be	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002c1	8b ce		 mov	 ecx, esi
  002c3	d3 e0		 shl	 eax, cl
  002c5	4b		 dec	 ebx
  002c6	47		 inc	 edi
  002c7	83 c6 08	 add	 esi, 8
  002ca	03 d0		 add	 edx, eax
  002cc	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  002cf	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002d2	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  002d5	83 fe 20	 cmp	 esi, 32			; 00000020H
  002d8	72 dc		 jb	 SHORT $LL442@inflate
  002da	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN444@inflate:

; 691  :             if (state->head != Z_NULL)

  002dd	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002e0	85 c0		 test	 eax, eax
  002e2	74 03		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  002e4	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  002e7	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  002ee	74 30		 je	 SHORT $LN432@inflate
  002f0	8b c2		 mov	 eax, edx
  002f2	c1 e8 08	 shr	 eax, 8
  002f5	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002f8	8b c2		 mov	 eax, edx
  002fa	c1 e8 10	 shr	 eax, 16			; 00000010H
  002fd	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00300	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00303	6a 04		 push	 4
  00305	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00308	c1 ea 18	 shr	 edx, 24			; 00000018H
  0030b	50		 push	 eax
  0030c	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0030f	ff 71 18	 push	 DWORD PTR [ecx+24]
  00312	e8 00 00 00 00	 call	 _crc32
  00317	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0031a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN432@inflate:

; 694  :             INITBITS();

  00320	33 d2		 xor	 edx, edx
  00322	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00325	33 f6		 xor	 esi, esi

; 695  :             state->mode = OS;

  00327	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  0032d	eb 05		 jmp	 SHORT $LL424@inflate
$LN427@inflate:
  0032f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00332	73 27		 jae	 SHORT $LN426@inflate
$LL424@inflate:
  00334	85 db		 test	 ebx, ebx
  00336	0f 84 ba 11 00
	00		 je	 $LN809@inflate
  0033c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0033f	8b ce		 mov	 ecx, esi
  00341	d3 e0		 shl	 eax, cl
  00343	4b		 dec	 ebx
  00344	47		 inc	 edi
  00345	83 c6 08	 add	 esi, 8
  00348	03 d0		 add	 edx, eax
  0034a	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  0034d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00350	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00353	83 fe 10	 cmp	 esi, 16			; 00000010H
  00356	72 dc		 jb	 SHORT $LL424@inflate
  00358	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN426@inflate:

; 698  :             if (state->head != Z_NULL) {

  0035b	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0035e	85 f6		 test	 esi, esi
  00360	74 17		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  00362	0f b6 c2	 movzx	 eax, dl
  00365	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 700  :                 state->head->os = (int)(hold >> 8);

  00368	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0036b	8b ca		 mov	 ecx, edx
  0036d	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00370	c1 e9 08	 shr	 ecx, 8
  00373	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00376	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00379	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00380	74 20		 je	 SHORT $LN414@inflate
  00382	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00385	6a 02		 push	 2
  00387	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0038a	c1 ea 08	 shr	 edx, 8
  0038d	50		 push	 eax
  0038e	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00391	ff 71 18	 push	 DWORD PTR [ecx+24]
  00394	e8 00 00 00 00	 call	 _crc32
  00399	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN414@inflate:

; 703  :             INITBITS();

  003a2	33 d2		 xor	 edx, edx
  003a4	33 f6		 xor	 esi, esi
  003a6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003a9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             state->mode = EXLEN;

  003ac	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  003b2	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  003b9	74 70		 je	 SHORT $LN409@inflate

; 707  :                 NEEDBITS(16);

  003bb	83 fe 10	 cmp	 esi, 16			; 00000010H
  003be	73 27		 jae	 SHORT $LN407@inflate
$LL405@inflate:
  003c0	85 db		 test	 ebx, ebx
  003c2	0f 84 2e 11 00
	00		 je	 $LN809@inflate
  003c8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003cb	8b ce		 mov	 ecx, esi
  003cd	d3 e0		 shl	 eax, cl
  003cf	4b		 dec	 ebx
  003d0	47		 inc	 edi
  003d1	83 c6 08	 add	 esi, 8
  003d4	03 d0		 add	 edx, eax
  003d6	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  003d9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003dc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  003df	83 fe 10	 cmp	 esi, 16			; 00000010H
  003e2	72 dc		 jb	 SHORT $LL405@inflate
  003e4	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN407@inflate:

; 708  :                 state->length = (unsigned)(hold);
; 709  :                 if (state->head != Z_NULL)

  003e7	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  003ea	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  003ed	85 c0		 test	 eax, eax
  003ef	74 03		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  003f1	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  003f4	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  003fb	74 20		 je	 SHORT $LN395@inflate
  003fd	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00400	6a 02		 push	 2
  00402	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00405	c1 ea 08	 shr	 edx, 8
  00408	50		 push	 eax
  00409	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0040c	ff 71 18	 push	 DWORD PTR [ecx+24]
  0040f	e8 00 00 00 00	 call	 _crc32
  00414	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00417	83 c4 0c	 add	 esp, 12			; 0000000cH
  0041a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN395@inflate:

; 712  :                 INITBITS();

  0041d	33 f6		 xor	 esi, esi
  0041f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00426	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  00429	eb 0e		 jmp	 SHORT $LN390@inflate
$LN409@inflate:
  0042b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0042e	85 c0		 test	 eax, eax
  00430	74 07		 je	 SHORT $LN390@inflate

; 715  :                 state->head->extra = Z_NULL;

  00432	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN390@inflate:

; 716  :             state->mode = EXTRA;

  00439	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  0043f	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  00446	0f 84 90 00 00
	00		 je	 $LN383@inflate

; 719  :                 copy = state->length;

  0044c	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 720  :                 if (copy > have) copy = have;

  0044f	3b c3		 cmp	 eax, ebx
  00451	8b d0		 mov	 edx, eax
  00453	0f 47 d3	 cmova	 edx, ebx
  00456	89 45 d0	 mov	 DWORD PTR _copy$1$[ebp], eax
  00459	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx

; 721  :                 if (copy) {

  0045c	85 d2		 test	 edx, edx
  0045e	74 72		 je	 SHORT $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  00460	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00463	85 c0		 test	 eax, eax
  00465	74 3f		 je	 SHORT $LN385@inflate
  00467	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0046a	89 7d d8	 mov	 DWORD PTR tv2809[ebp], edi
  0046d	85 ff		 test	 edi, edi
  0046f	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00472	74 32		 je	 SHORT $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  00474	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00477	2b 4d d0	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  0047a	89 4d d0	 mov	 DWORD PTR _len$2$[ebp], ecx

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  0047d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00480	8b 45 d0	 mov	 eax, DWORD PTR _len$2$[ebp]
  00483	03 c2		 add	 eax, edx
  00485	3b c1		 cmp	 eax, ecx
  00487	8b 45 d0	 mov	 eax, DWORD PTR _len$2$[ebp]
  0048a	76 04		 jbe	 SHORT $LN510@inflate
  0048c	2b c8		 sub	 ecx, eax
  0048e	eb 02		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  00490	8b ca		 mov	 ecx, edx
$LN511@inflate:
  00492	03 45 d8	 add	 eax, DWORD PTR tv2809[ebp]
  00495	51		 push	 ecx
  00496	57		 push	 edi
  00497	50		 push	 eax
  00498	e8 00 00 00 00	 call	 _memcpy
  0049d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004a0	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  004a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  004a6	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  004ad	74 13		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  004af	52		 push	 edx
  004b0	57		 push	 edi
  004b1	ff 71 18	 push	 DWORD PTR [ecx+24]
  004b4	e8 00 00 00 00	 call	 _crc32
  004b9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004bf	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN384@inflate:

; 731  :                     have -= copy;

  004c2	8b 45 cc	 mov	 eax, DWORD PTR _copy$2$[ebp]
  004c5	2b d8		 sub	 ebx, eax

; 732  :                     next += copy;

  004c7	03 f8		 add	 edi, eax

; 733  :                     state->length -= copy;

  004c9	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  004cc	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  004cf	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  004d2	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  004d6	0f 85 1a 10 00
	00		 jne	 $LN809@inflate
$LN383@inflate:

; 736  :             }
; 737  :             state->length = 0;

  004dc	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 738  :             state->mode = NAME;

  004e3	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  004e9	f7 41 10 00 08
	00 00		 test	 DWORD PTR [ecx+16], 2048 ; 00000800H
  004f0	0f 84 7e 00 00
	00		 je	 $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  004f6	85 db		 test	 ebx, ebx
  004f8	0f 84 f8 0f 00
	00		 je	 $LN809@inflate

; 742  :                 copy = 0;

  004fe	33 d2		 xor	 edx, edx
$LL379@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00500	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00504	89 45 d0	 mov	 DWORD PTR _len$3$[ebp], eax

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00507	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0050a	42		 inc	 edx
  0050b	85 c0		 test	 eax, eax
  0050d	74 1e		 je	 SHORT $LN378@inflate
  0050f	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00512	85 f6		 test	 esi, esi
  00514	74 17		 je	 SHORT $LN378@inflate
  00516	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00519	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  0051c	73 0f		 jae	 SHORT $LN378@inflate

; 748  :                         state->head->name[state->length++] = len;

  0051e	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00521	8b 5d d0	 mov	 ebx, DWORD PTR _len$3$[ebp]
  00524	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  00527	ff 41 40	 inc	 DWORD PTR [ecx+64]
  0052a	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN378@inflate:

; 749  :                 } while (len && copy < have);

  0052d	8b 45 d0	 mov	 eax, DWORD PTR _len$3$[ebp]
  00530	85 c0		 test	 eax, eax
  00532	74 04		 je	 SHORT $LN375@inflate
  00534	3b d3		 cmp	 edx, ebx
  00536	72 c8		 jb	 SHORT $LL379@inflate
$LN375@inflate:

; 750  :                 if (state->flags & 0x0200)

  00538	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0053f	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00542	89 55 cc	 mov	 DWORD PTR _copy$3$[ebp], edx
  00545	74 19		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  00547	52		 push	 edx
  00548	57		 push	 edi
  00549	ff 71 18	 push	 DWORD PTR [ecx+24]
  0054c	e8 00 00 00 00	 call	 _crc32
  00551	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00554	8b 55 cc	 mov	 edx, DWORD PTR _copy$3$[ebp]
  00557	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0055a	8b 45 d0	 mov	 eax, DWORD PTR _len$3$[ebp]
  0055d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN374@inflate:

; 752  :                 have -= copy;

  00560	2b da		 sub	 ebx, edx

; 753  :                 next += copy;

  00562	03 fa		 add	 edi, edx
  00564	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00567	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 754  :                 if (len) goto inf_leave;

  0056a	85 c0		 test	 eax, eax
  0056c	0f 85 84 0f 00
	00		 jne	 $LN809@inflate

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  00572	eb 0e		 jmp	 SHORT $LN371@inflate
$LN381@inflate:
  00574	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00577	85 c0		 test	 eax, eax
  00579	74 07		 je	 SHORT $LN371@inflate

; 757  :                 state->head->name = Z_NULL;

  0057b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN371@inflate:

; 758  :             state->length = 0;

  00582	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 759  :             state->mode = COMMENT;

  00589	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  0058f	f7 41 10 00 10
	00 00		 test	 DWORD PTR [ecx+16], 4096 ; 00001000H
  00596	0f 84 7e 00 00
	00		 je	 $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  0059c	85 db		 test	 ebx, ebx
  0059e	0f 84 52 0f 00
	00		 je	 $LN809@inflate

; 763  :                 copy = 0;

  005a4	33 d2		 xor	 edx, edx
$LL367@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  005a6	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  005aa	89 45 d0	 mov	 DWORD PTR _len$4$[ebp], eax

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  005ad	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  005b0	42		 inc	 edx
  005b1	85 c0		 test	 eax, eax
  005b3	74 1e		 je	 SHORT $LN366@inflate
  005b5	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  005b8	85 f6		 test	 esi, esi
  005ba	74 17		 je	 SHORT $LN366@inflate
  005bc	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  005bf	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  005c2	73 0f		 jae	 SHORT $LN366@inflate

; 769  :                         state->head->comment[state->length++] = len;

  005c4	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  005c7	8b 5d d0	 mov	 ebx, DWORD PTR _len$4$[ebp]
  005ca	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  005cd	ff 41 40	 inc	 DWORD PTR [ecx+64]
  005d0	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN366@inflate:

; 770  :                 } while (len && copy < have);

  005d3	8b 45 d0	 mov	 eax, DWORD PTR _len$4$[ebp]
  005d6	85 c0		 test	 eax, eax
  005d8	74 04		 je	 SHORT $LN363@inflate
  005da	3b d3		 cmp	 edx, ebx
  005dc	72 c8		 jb	 SHORT $LL367@inflate
$LN363@inflate:

; 771  :                 if (state->flags & 0x0200)

  005de	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  005e5	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005e8	89 55 cc	 mov	 DWORD PTR _copy$4$[ebp], edx
  005eb	74 19		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  005ed	52		 push	 edx
  005ee	57		 push	 edi
  005ef	ff 71 18	 push	 DWORD PTR [ecx+24]
  005f2	e8 00 00 00 00	 call	 _crc32
  005f7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005fa	8b 55 cc	 mov	 edx, DWORD PTR _copy$4$[ebp]
  005fd	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00600	8b 45 d0	 mov	 eax, DWORD PTR _len$4$[ebp]
  00603	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN362@inflate:

; 773  :                 have -= copy;

  00606	2b da		 sub	 ebx, edx

; 774  :                 next += copy;

  00608	03 fa		 add	 edi, edx
  0060a	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  0060d	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 775  :                 if (len) goto inf_leave;

  00610	85 c0		 test	 eax, eax
  00612	0f 85 de 0e 00
	00		 jne	 $LN809@inflate

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00618	eb 0e		 jmp	 SHORT $LN359@inflate
$LN369@inflate:
  0061a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0061d	85 c0		 test	 eax, eax
  0061f	74 07		 je	 SHORT $LN359@inflate

; 778  :                 state->head->comment = Z_NULL;

  00621	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN359@inflate:
  00628	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 779  :             state->mode = HCRC;

  0062b	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00631	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00638	74 53		 je	 SHORT $LN344@inflate

; 782  :                 NEEDBITS(16);

  0063a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0063d	73 2b		 jae	 SHORT $LN355@inflate
  0063f	90		 npad	 1
$LL353@inflate:
  00640	85 db		 test	 ebx, ebx
  00642	0f 84 ae 0e 00
	00		 je	 $LN809@inflate
  00648	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0064b	8b ce		 mov	 ecx, esi
  0064d	d3 e0		 shl	 eax, cl
  0064f	83 c6 08	 add	 esi, 8
  00652	4b		 dec	 ebx
  00653	47		 inc	 edi
  00654	03 d0		 add	 edx, eax
  00656	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00659	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0065c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0065f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00662	83 fe 10	 cmp	 esi, 16			; 00000010H
  00665	72 d9		 jb	 SHORT $LL353@inflate
  00667	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN355@inflate:

; 783  :                 if (hold != (state->check & 0xffff)) {

  0066a	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  0066e	3b d0		 cmp	 edx, eax
  00670	74 0f		 je	 SHORT $LN346@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  00672	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00675	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 785  :                     state->mode = BAD;
; 786  :                     break;

  0067c	e9 10 0e 00 00	 jmp	 $LN848@inflate
$LN346@inflate:

; 787  :                 }
; 788  :                 INITBITS();

  00681	33 f6		 xor	 esi, esi
  00683	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0068a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN344@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  0068d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00690	85 d2		 test	 edx, edx
  00692	74 16		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00694	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00697	c1 f8 09	 sar	 eax, 9
  0069a	83 e0 01	 and	 eax, 1
  0069d	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 792  :                 state->head->done = 1;

  006a0	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  006a3	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006aa	6a 00		 push	 0
  006ac	6a 00		 push	 0
  006ae	6a 00		 push	 0
  006b0	e8 00 00 00 00	 call	 _crc32
  006b5	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006b8	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  006bb	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  006be	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 795  :             state->mode = TYPE;
; 796  :             break;

  006c1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  006c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  006c7	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
  006cd	e9 c5 0d 00 00	 jmp	 $LN498@inflate
$LN341@inflate:

; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  006d2	83 fe 20	 cmp	 esi, 32			; 00000020H
  006d5	73 24		 jae	 SHORT $LN340@inflate
$LL338@inflate:
  006d7	85 db		 test	 ebx, ebx
  006d9	0f 84 17 0e 00
	00		 je	 $LN809@inflate
  006df	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  006e2	8b ce		 mov	 ecx, esi
  006e4	d3 e0		 shl	 eax, cl
  006e6	4b		 dec	 ebx
  006e7	47		 inc	 edi
  006e8	83 c6 08	 add	 esi, 8
  006eb	03 d0		 add	 edx, eax
  006ed	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  006f0	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  006f3	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  006f6	83 fe 20	 cmp	 esi, 32			; 00000020H
  006f9	72 dc		 jb	 SHORT $LL338@inflate
$LN340@inflate:

; 800  :             strm->adler = state->check = REVERSE(hold);

  006fb	8b ca		 mov	 ecx, edx
  006fd	8b c2		 mov	 eax, edx
  006ff	c1 e0 10	 shl	 eax, 16			; 00000010H
  00702	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00708	03 c8		 add	 ecx, eax
  0070a	8b c2		 mov	 eax, edx
  0070c	c1 e8 08	 shr	 eax, 8
  0070f	c1 e1 08	 shl	 ecx, 8
  00712	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00717	c1 ea 18	 shr	 edx, 24			; 00000018H
  0071a	03 c1		 add	 eax, ecx
  0071c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0071f	03 c2		 add	 eax, edx
  00721	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00724	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00727	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 801  :             INITBITS();

  0072a	33 d2		 xor	 edx, edx
  0072c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0072f	33 f6		 xor	 esi, esi

; 802  :             state->mode = DICT;

  00731	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  00737	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0073b	0f 84 6d 0d 00
	00		 je	 $LN589@inflate

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00741	6a 00		 push	 0
  00743	6a 00		 push	 0
  00745	6a 00		 push	 0
  00747	e8 00 00 00 00	 call	 _adler32
  0074c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0074f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00752	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00755	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00758	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0075b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 809  :             state->mode = TYPE;

  0075e	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
$LN324@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00764	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00767	83 f8 05	 cmp	 eax, 5
  0076a	0f 84 86 0d 00
	00		 je	 $LN809@inflate
  00770	83 f8 06	 cmp	 eax, 6
  00773	0f 84 7d 0d 00
	00		 je	 $LN809@inflate
$LN323@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  00779	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0077d	74 1d		 je	 SHORT $LN316@inflate

; 814  :                 BYTEBITS();

  0077f	8b ce		 mov	 ecx, esi
  00781	83 e1 07	 and	 ecx, 7
  00784	d3 ea		 shr	 edx, cl
  00786	2b f1		 sub	 esi, ecx

; 815  :                 state->mode = CHECK;

  00788	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0078b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0078e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00791	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH

; 816  :                 break;

  00797	e9 fb 0c 00 00	 jmp	 $LN498@inflate
$LN316@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  0079c	83 fe 03	 cmp	 esi, 3
  0079f	73 27		 jae	 SHORT $LN315@inflate
$LL313@inflate:
  007a1	85 db		 test	 ebx, ebx
  007a3	0f 84 4d 0d 00
	00		 je	 $LN809@inflate
  007a9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007ac	8b ce		 mov	 ecx, esi
  007ae	d3 e0		 shl	 eax, cl
  007b0	4b		 dec	 ebx
  007b1	47		 inc	 edi
  007b2	83 c6 08	 add	 esi, 8
  007b5	03 d0		 add	 edx, eax
  007b7	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  007ba	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007bd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  007c0	83 fe 03	 cmp	 esi, 3
  007c3	72 dc		 jb	 SHORT $LL313@inflate
  007c5	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN315@inflate:

; 819  :             state->last = BITS(1);

  007c8	8b c2		 mov	 eax, edx
  007ca	83 e0 01	 and	 eax, 1

; 820  :             DROPBITS(1);

  007cd	d1 ea		 shr	 edx, 1
  007cf	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 821  :             switch (BITS(2)) {

  007d2	8b c2		 mov	 eax, edx
  007d4	83 e0 03	 and	 eax, 3
  007d7	83 f8 03	 cmp	 eax, 3
  007da	77 68		 ja	 SHORT $LN294@inflate
  007dc	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN856@inflate[eax*4]
$LN302@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  007e3	c1 ea 02	 shr	 edx, 2
  007e6	83 ee 03	 sub	 esi, 3
  007e9	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  007ef	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007f2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  007f5	e9 9d 0c 00 00	 jmp	 $LN498@inflate
$LN301@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;
; 826  :                 break;
; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  007fa	51		 push	 ecx
  007fb	e8 00 00 00 00	 call	 _fixedtables
  00800	83 c4 04	 add	 esp, 4

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */
; 832  :                 if (flush == Z_TREES) {

  00803	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00807	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  0080d	75 35		 jne	 SHORT $LN294@inflate

; 833  :                     DROPBITS(2);

  0080f	c1 ea 02	 shr	 edx, 2
  00812	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00815	83 ee 03	 sub	 esi, 3

; 834  :                     goto inf_leave;

  00818	e9 d9 0c 00 00	 jmp	 $LN809@inflate
$LN296@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  0081d	c1 ea 02	 shr	 edx, 2
  00820	83 ee 03	 sub	 esi, 3
  00823	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H
  00829	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0082c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  0082f	e9 63 0c 00 00	 jmp	 $LN498@inflate
$LN295@inflate:

; 835  :                 }
; 836  :                 break;
; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;
; 841  :                 break;
; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  00834	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00837	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 844  :                 state->mode = BAD;

  0083e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN294@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  00844	c1 ea 02	 shr	 edx, 2
  00847	83 ee 03	 sub	 esi, 3
  0084a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0084d	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  00850	e9 42 0c 00 00	 jmp	 $LN498@inflate
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  00855	8b ce		 mov	 ecx, esi
  00857	83 e1 07	 and	 ecx, 7
  0085a	d3 ea		 shr	 edx, cl
  0085c	2b f1		 sub	 esi, ecx
  0085e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00861	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 850  :             NEEDBITS(32);

  00864	83 fe 20	 cmp	 esi, 32			; 00000020H
  00867	73 2e		 jae	 SHORT $LN286@inflate
  00869	8d a4 24 00 00
	00 00		 npad	 7
$LL284@inflate:
  00870	85 db		 test	 ebx, ebx
  00872	0f 84 7e 0c 00
	00		 je	 $LN809@inflate
  00878	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0087b	8b ce		 mov	 ecx, esi
  0087d	d3 e0		 shl	 eax, cl
  0087f	83 c6 08	 add	 esi, 8
  00882	4b		 dec	 ebx
  00883	47		 inc	 edi
  00884	03 d0		 add	 edx, eax
  00886	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00889	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0088c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0088f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00892	83 fe 20	 cmp	 esi, 32			; 00000020H
  00895	72 d9		 jb	 SHORT $LL284@inflate
$LN286@inflate:

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00897	8b c2		 mov	 eax, edx
  00899	8b ca		 mov	 ecx, edx
  0089b	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  008a1	f7 d0		 not	 eax
  008a3	c1 e8 10	 shr	 eax, 16			; 00000010H
  008a6	89 4d cc	 mov	 DWORD PTR tv2799[ebp], ecx
  008a9	3b c8		 cmp	 ecx, eax

; 853  :                 state->mode = BAD;

  008ab	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  008ae	74 0f		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  008b0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  008b3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 854  :                 break;

  008ba	e9 d2 0b 00 00	 jmp	 $LN848@inflate
$LN278@inflate:

; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  008bf	8b 45 cc	 mov	 eax, DWORD PTR tv2799[ebp]

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  008c2	33 d2		 xor	 edx, edx
  008c4	33 f6		 xor	 esi, esi

; 860  :             state->mode = COPY_;
; 861  :             if (flush == Z_TREES) goto inf_leave;

  008c6	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008ca	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  008cd	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008d0	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  008d3	c7 01 0e 00 00
	00		 mov	 DWORD PTR [ecx], 14	; 0000000eH
  008d9	0f 84 17 0c 00
	00		 je	 $LN809@inflate
$LN274@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  008df	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  008e5	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 866  :             if (copy) {

  008e8	85 c0		 test	 eax, eax
  008ea	0f 84 10 07 00
	00		 je	 $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  008f0	3b c3		 cmp	 eax, ebx
  008f2	0f 47 c3	 cmova	 eax, ebx

; 868  :                 if (copy > left) copy = left;

  008f5	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  008f8	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  008fc	89 45 cc	 mov	 DWORD PTR _copy$7$[ebp], eax

; 869  :                 if (copy == 0) goto inf_leave;

  008ff	85 c0		 test	 eax, eax
  00901	0f 84 ef 0b 00
	00		 je	 $LN809@inflate

; 870  :                 zmemcpy(put, next, copy);

  00907	50		 push	 eax
  00908	57		 push	 edi
  00909	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  0090c	e8 00 00 00 00	 call	 _memcpy

; 871  :                 have -= copy;

  00911	8b 45 cc	 mov	 eax, DWORD PTR _copy$7$[ebp]

; 872  :                 next += copy;
; 873  :                 left -= copy;
; 874  :                 put += copy;
; 875  :                 state->length -= copy;

  00914	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00917	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  0091a	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax

; 876  :                 break;

  0091d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00920	2b d8		 sub	 ebx, eax
  00922	03 f8		 add	 edi, eax
  00924	83 c4 0c	 add	 esp, 12			; 0000000cH
  00927	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  0092a	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  0092d	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00930	e9 62 0b 00 00	 jmp	 $LN498@inflate
$LN266@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;
; 880  :             break;
; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  00935	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00938	73 2d		 jae	 SHORT $LN265@inflate
  0093a	8d 9b 00 00 00
	00		 npad	 6
$LL263@inflate:
  00940	85 db		 test	 ebx, ebx
  00942	0f 84 ae 0b 00
	00		 je	 $LN809@inflate
  00948	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0094b	8b ce		 mov	 ecx, esi
  0094d	d3 e0		 shl	 eax, cl
  0094f	4b		 dec	 ebx
  00950	47		 inc	 edi
  00951	83 c6 08	 add	 esi, 8
  00954	03 d0		 add	 edx, eax
  00956	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00959	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0095c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0095f	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00962	72 dc		 jb	 SHORT $LL263@inflate
  00964	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN265@inflate:

; 883  :             state->nlen = BITS(5) + 257;

  00967	8b c2		 mov	 eax, edx
  00969	83 e0 1f	 and	 eax, 31			; 0000001fH
  0096c	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00971	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 884  :             DROPBITS(5);

  00974	c1 ea 05	 shr	 edx, 5

; 885  :             state->ndist = BITS(5) + 1;

  00977	8b c2		 mov	 eax, edx
  00979	83 e0 1f	 and	 eax, 31			; 0000001fH
  0097c	40		 inc	 eax

; 886  :             DROPBITS(5);

  0097d	c1 ea 05	 shr	 edx, 5
  00980	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 887  :             state->ncode = BITS(4) + 4;

  00983	8b c2		 mov	 eax, edx
  00985	83 e0 0f	 and	 eax, 15			; 0000000fH
  00988	83 c0 04	 add	 eax, 4

; 888  :             DROPBITS(4);

  0098b	c1 ea 04	 shr	 edx, 4
  0098e	83 ee 0e	 sub	 esi, 14			; 0000000eH

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  00991	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  00998	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  0099b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009a1	0f 87 f6 00 00
	00		 ja	 $LN247@inflate
  009a7	83 79 64 1e	 cmp	 DWORD PTR [ecx+100], 30	; 0000001eH
  009ab	0f 87 ec 00 00
	00		 ja	 $LN247@inflate

; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  009b1	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 898  :             state->mode = LENLENS;

  009b8	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN533@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  009be	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  009c1	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  009c4	73 65		 jae	 SHORT $LN535@inflate
$LL245@inflate:

; 901  :                 NEEDBITS(3);

  009c6	83 fe 03	 cmp	 esi, 3
  009c9	73 29		 jae	 SHORT $LN242@inflate
  009cb	eb 03 8d 49 00	 npad	 5
$LL240@inflate:
  009d0	85 db		 test	 ebx, ebx
  009d2	0f 84 1e 0b 00
	00		 je	 $LN809@inflate
  009d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  009db	8b ce		 mov	 ecx, esi
  009dd	d3 e0		 shl	 eax, cl
  009df	4b		 dec	 ebx
  009e0	47		 inc	 edi
  009e1	83 c6 08	 add	 esi, 8
  009e4	03 d0		 add	 edx, eax
  009e6	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  009e9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  009ec	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  009ef	83 fe 03	 cmp	 esi, 3
  009f2	72 dc		 jb	 SHORT $LL240@inflate
$LN242@inflate:

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  009f4	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  009f7	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  009fa	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  009fd	8b ca		 mov	 ecx, edx
  009ff	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a07	83 e1 07	 and	 ecx, 7
  00a0a	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  00a0f	8b cf		 mov	 ecx, edi
  00a11	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a14	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a17	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]

; 903  :                 DROPBITS(3);

  00a1a	c1 ea 03	 shr	 edx, 3
  00a1d	83 ee 03	 sub	 esi, 3
  00a20	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a23	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a26	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a29	72 9b		 jb	 SHORT $LL245@inflate
$LN535@inflate:

; 904  :             }
; 905  :             while (state->have < 19)

  00a2b	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a2f	73 1b		 jae	 SHORT $LN230@inflate
$LL231@inflate:

; 906  :                 state->lens[order[state->have++]] = 0;

  00a31	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a34	33 d2		 xor	 edx, edx
  00a36	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a3e	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00a43	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a46	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a4a	72 e5		 jb	 SHORT $LL231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;

  00a4c	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00a52	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]

; 908  :             state->lencode = (code const FAR *)(state->next);

  00a55	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00a58	89 02		 mov	 DWORD PTR [edx], eax

; 909  :             state->lenbits = 7;
; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  00a5a	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a5d	05 f0 02 00 00	 add	 eax, 752		; 000002f0H
  00a62	50		 push	 eax
  00a63	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a66	83 c1 54	 add	 ecx, 84			; 00000054H
  00a69	51		 push	 ecx
  00a6a	52		 push	 edx
  00a6b	6a 13		 push	 19			; 00000013H
  00a6d	83 c0 70	 add	 eax, 112		; 00000070H
  00a70	50		 push	 eax
  00a71	6a 00		 push	 0
  00a73	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
  00a79	e8 00 00 00 00	 call	 _inflate_table

; 914  :                 state->mode = BAD;

  00a7e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 915  :                 break;

  00a81	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00a84	83 c4 18	 add	 esp, 24			; 00000018H
  00a87	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00a8a	85 c0		 test	 eax, eax
  00a8c	74 1e		 je	 SHORT $LN229@inflate

; 912  :             if (ret) {
; 913  :                 strm->msg = (char *)"invalid code lengths set";

  00a8e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a91	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 915  :                 break;

  00a98	e9 f4 09 00 00	 jmp	 $LN848@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  00a9d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00aa0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 892  :                 state->mode = BAD;
; 893  :                 break;

  00aa7	e9 e5 09 00 00	 jmp	 $LN848@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  00aac	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 919  :             state->mode = CODELENS;

  00ab3	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$LN536@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00ab9	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00abc	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00abf	89 45 d8	 mov	 DWORD PTR tv2211[ebp], eax
  00ac2	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00ac5	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00ac8	39 45 d8	 cmp	 DWORD PTR tv2211[ebp], eax
  00acb	0f 83 3d 02 00
	00		 jae	 $LN226@inflate
$LL227@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  00ad1	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00ad4	b8 01 00 00 00	 mov	 eax, 1
  00ad9	d3 e0		 shl	 eax, cl
  00adb	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00ade	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ae1	89 4d ec	 mov	 DWORD PTR tv2781[ebp], ecx
  00ae4	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00ae7	89 45 cc	 mov	 DWORD PTR tv2779[ebp], eax
  00aea	8b c1		 mov	 eax, ecx
  00aec	8b 4d cc	 mov	 ecx, DWORD PTR tv2779[ebp]
  00aef	23 c2		 and	 eax, edx
  00af1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  00af4	8b c8		 mov	 ecx, eax
  00af6	c1 e9 08	 shr	 ecx, 8
  00af9	0f b6 c9	 movzx	 ecx, cl
  00afc	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00aff	3b ce		 cmp	 ecx, esi
  00b01	76 39		 jbe	 SHORT $LN564@inflate
$LL225@inflate:

; 925  :                     PULLBYTE();

  00b03	85 db		 test	 ebx, ebx
  00b05	0f 84 eb 09 00
	00		 je	 $LN809@inflate
  00b0b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00b0e	8b ce		 mov	 ecx, esi
  00b10	d3 e0		 shl	 eax, cl
  00b12	8b 4d cc	 mov	 ecx, DWORD PTR tv2779[ebp]
  00b15	4b		 dec	 ebx
  00b16	47		 inc	 edi
  00b17	03 d0		 add	 edx, eax
  00b19	8b 45 ec	 mov	 eax, DWORD PTR tv2781[ebp]
  00b1c	23 c2		 and	 eax, edx
  00b1e	83 c6 08	 add	 esi, 8
  00b21	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00b24	8b c8		 mov	 ecx, eax
  00b26	c1 e9 08	 shr	 ecx, 8
  00b29	0f b6 c9	 movzx	 ecx, cl
  00b2c	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00b2f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00b32	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00b35	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00b38	3b ce		 cmp	 ecx, esi
  00b3a	77 c7		 ja	 SHORT $LL225@inflate
$LN564@inflate:

; 926  :                 }
; 927  :                 if (here.val < 16) {

  00b3c	8b c8		 mov	 ecx, eax
  00b3e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00b41	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00b44	73 58		 jae	 SHORT $LN218@inflate

; 928  :                     NEEDBITS(here.bits);

  00b46	8b c8		 mov	 ecx, eax
  00b48	c1 e9 08	 shr	 ecx, 8
  00b4b	0f b6 c9	 movzx	 ecx, cl
  00b4e	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00b51	3b f1		 cmp	 esi, ecx
  00b53	73 25		 jae	 SHORT $LN216@inflate
$LL214@inflate:
  00b55	85 db		 test	 ebx, ebx
  00b57	0f 84 99 09 00
	00		 je	 $LN809@inflate
  00b5d	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00b60	8b ce		 mov	 ecx, esi
  00b62	d3 e2		 shl	 edx, cl
  00b64	4b		 dec	 ebx
  00b65	47		 inc	 edi
  00b66	83 c6 08	 add	 esi, 8
  00b69	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00b6c	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00b6f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00b72	3b 75 cc	 cmp	 esi, DWORD PTR $T1[ebp]
  00b75	72 de		 jb	 SHORT $LL214@inflate
  00b77	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN216@inflate:

; 929  :                     DROPBITS(here.bits);
; 930  :                     state->lens[state->have++] = here.val;

  00b7a	8b 7d d8	 mov	 edi, DWORD PTR tv2211[ebp]
  00b7d	0f b6 cc	 movzx	 ecx, ah
  00b80	66 8b 45 d2	 mov	 ax, WORD PTR _here$[ebp+2]
  00b84	d3 ea		 shr	 edx, cl
  00b86	2b f1		 sub	 esi, ecx
  00b88	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b8b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00b8e	66 89 44 79 70	 mov	 WORD PTR [ecx+edi*2+112], ax
  00b93	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00b96	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 931  :                 }
; 932  :                 else {

  00b99	e9 58 01 00 00	 jmp	 $LN853@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  00b9e	66 8b 4d d2	 mov	 cx, WORD PTR _here$[ebp+2]
  00ba2	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00ba6	75 6c		 jne	 SHORT $LN204@inflate

; 934  :                         NEEDBITS(here.bits + 2);

  00ba8	0f b6 cc	 movzx	 ecx, ah
  00bab	89 4d cc	 mov	 DWORD PTR tv2768[ebp], ecx
  00bae	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00bb1	3b f0		 cmp	 esi, eax
  00bb3	73 29		 jae	 SHORT $LN202@inflate
$LL200@inflate:
  00bb5	85 db		 test	 ebx, ebx
  00bb7	0f 84 39 09 00
	00		 je	 $LN809@inflate
  00bbd	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00bc0	8b ce		 mov	 ecx, esi
  00bc2	d3 e0		 shl	 eax, cl
  00bc4	8b 4d cc	 mov	 ecx, DWORD PTR tv2768[ebp]
  00bc7	4b		 dec	 ebx
  00bc8	47		 inc	 edi
  00bc9	03 d0		 add	 edx, eax
  00bcb	83 c6 08	 add	 esi, 8
  00bce	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00bd1	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bd4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00bd7	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00bda	3b f0		 cmp	 esi, eax
  00bdc	72 d7		 jb	 SHORT $LL200@inflate
$LN202@inflate:

; 935  :                         DROPBITS(here.bits);

  00bde	d3 ea		 shr	 edx, cl
  00be0	2b f1		 sub	 esi, ecx

; 936  :                         if (state->have == 0) {

  00be2	8b 4d d8	 mov	 ecx, DWORD PTR tv2211[ebp]
  00be5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00be8	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00beb	85 c9		 test	 ecx, ecx
  00bed	0f 84 3d 01 00
	00		 je	 $LN570@inflate

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];

  00bf3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bf6	0f b7 4c 48 6e	 movzx	 ecx, WORD PTR [eax+ecx*2+110]
  00bfb	89 4d cc	 mov	 DWORD PTR _len$5$[ebp], ecx

; 942  :                         copy = 3 + BITS(2);

  00bfe	8b ca		 mov	 ecx, edx
  00c00	83 e1 03	 and	 ecx, 3
  00c03	83 c1 03	 add	 ecx, 3

; 943  :                         DROPBITS(2);

  00c06	c1 ea 02	 shr	 edx, 2
  00c09	89 4d d0	 mov	 DWORD PTR _copy$8$[ebp], ecx
  00c0c	83 ee 02	 sub	 esi, 2

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  00c0f	e9 a9 00 00 00	 jmp	 $LN849@inflate
$LN204@inflate:
  00c14	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  00c18	0f b6 cc	 movzx	 ecx, ah
  00c1b	75 4a		 jne	 SHORT $LN169@inflate

; 946  :                         NEEDBITS(here.bits + 3);

  00c1d	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c20	89 4d cc	 mov	 DWORD PTR tv2767[ebp], ecx
  00c23	3b f0		 cmp	 esi, eax
  00c25	73 29		 jae	 SHORT $LN184@inflate
$LL182@inflate:
  00c27	85 db		 test	 ebx, ebx
  00c29	0f 84 c7 08 00
	00		 je	 $LN809@inflate
  00c2f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c32	8b ce		 mov	 ecx, esi
  00c34	d3 e0		 shl	 eax, cl
  00c36	8b 4d cc	 mov	 ecx, DWORD PTR tv2767[ebp]
  00c39	4b		 dec	 ebx
  00c3a	47		 inc	 edi
  00c3b	03 d0		 add	 edx, eax
  00c3d	83 c6 08	 add	 esi, 8
  00c40	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c43	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c46	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c49	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c4c	3b f0		 cmp	 esi, eax
  00c4e	72 d7		 jb	 SHORT $LL182@inflate
$LN184@inflate:

; 947  :                         DROPBITS(here.bits);

  00c50	d3 ea		 shr	 edx, cl

; 948  :                         len = 0;
; 949  :                         copy = 3 + BITS(3);

  00c52	8b c2		 mov	 eax, edx
  00c54	83 e0 07	 and	 eax, 7
  00c57	83 c0 03	 add	 eax, 3
  00c5a	89 45 d0	 mov	 DWORD PTR _copy$8$[ebp], eax

; 950  :                         DROPBITS(3);

  00c5d	c1 ea 03	 shr	 edx, 3
  00c60	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 951  :                     }
; 952  :                     else {

  00c65	eb 48		 jmp	 SHORT $LN850@inflate
$LN169@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  00c67	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00c6a	89 4d cc	 mov	 DWORD PTR tv2766[ebp], ecx
  00c6d	3b f0		 cmp	 esi, eax
  00c6f	73 29		 jae	 SHORT $LN168@inflate
$LL166@inflate:
  00c71	85 db		 test	 ebx, ebx
  00c73	0f 84 7d 08 00
	00		 je	 $LN809@inflate
  00c79	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c7c	8b ce		 mov	 ecx, esi
  00c7e	d3 e0		 shl	 eax, cl
  00c80	8b 4d cc	 mov	 ecx, DWORD PTR tv2766[ebp]
  00c83	4b		 dec	 ebx
  00c84	47		 inc	 edi
  00c85	03 d0		 add	 edx, eax
  00c87	83 c6 08	 add	 esi, 8
  00c8a	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00c8d	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c90	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c93	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c96	3b f0		 cmp	 esi, eax
  00c98	72 d7		 jb	 SHORT $LL166@inflate
$LN168@inflate:

; 954  :                         DROPBITS(here.bits);

  00c9a	d3 ea		 shr	 edx, cl

; 955  :                         len = 0;
; 956  :                         copy = 11 + BITS(7);

  00c9c	8b c2		 mov	 eax, edx
  00c9e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00ca1	83 c0 0b	 add	 eax, 11			; 0000000bH
  00ca4	89 45 d0	 mov	 DWORD PTR _copy$8$[ebp], eax

; 957  :                         DROPBITS(7);

  00ca7	c1 ea 07	 shr	 edx, 7
  00caa	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN850@inflate:
  00caf	2b c1		 sub	 eax, ecx
  00cb1	03 f0		 add	 esi, eax
  00cb3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00cb6	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
$LN849@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  00cbd	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00cc0	03 48 60	 add	 ecx, DWORD PTR [eax+96]
  00cc3	8b 45 d0	 mov	 eax, DWORD PTR _copy$8$[ebp]
  00cc6	03 45 d8	 add	 eax, DWORD PTR tv2211[ebp]
  00cc9	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00ccc	3b c1		 cmp	 eax, ecx
  00cce	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cd1	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cd4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cd7	77 69		 ja	 SHORT $LN571@inflate

; 961  :                         state->mode = BAD;
; 962  :                         break;
; 963  :                     }
; 964  :                     while (copy--)

  00cd9	83 7d d0 00	 cmp	 DWORD PTR _copy$8$[ebp], 0
  00cdd	74 1a		 je	 SHORT $LN614@inflate
  00cdf	8b 7d d0	 mov	 edi, DWORD PTR _copy$8$[ebp]
  00ce2	8b 5d cc	 mov	 ebx, DWORD PTR _len$5$[ebp]
$LL153@inflate:

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  00ce5	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00ce8	66 89 5c 41 70	 mov	 WORD PTR [ecx+eax*2+112], bx
  00ced	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00cf0	4f		 dec	 edi
  00cf1	75 f2		 jne	 SHORT $LL153@inflate
  00cf3	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN853@inflate:
  00cf6	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LN614@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00cf9	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00cfc	89 45 d8	 mov	 DWORD PTR tv2211[ebp], eax
  00cff	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00d02	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00d05	39 45 d8	 cmp	 DWORD PTR tv2211[ebp], eax
  00d08	0f 82 c3 fd ff
	ff		 jb	 $LL227@inflate
$LN226@inflate:

; 966  :                 }
; 967  :             }
; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  00d0e	83 39 1d	 cmp	 DWORD PTR [ecx], 29	; 0000001dH
  00d11	0f 84 80 07 00
	00		 je	 $LN498@inflate

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  00d17	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00d1f	75 30		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d21	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d24	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 975  :                 state->mode = BAD;
; 976  :                 break;

  00d2b	e9 61 07 00 00	 jmp	 $LN848@inflate
$LN570@inflate:

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  00d30	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 938  :                             state->mode = BAD;

  00d33	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d36	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 939  :                             break;

  00d3d	e9 4f 07 00 00	 jmp	 $LN848@inflate
$LN571@inflate:

; 960  :                         strm->msg = (char *)"invalid bit length repeat";

  00d42	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d45	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 966  :                 }
; 967  :             }
; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  00d4c	e9 40 07 00 00	 jmp	 $LN848@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;

  00d51	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]
  00d54	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]

; 983  :             state->lencode = (code const FAR *)(state->next);
; 984  :             state->lenbits = 9;
; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  00d5a	8d b9 f0 02 00
	00		 lea	 edi, DWORD PTR [ecx+752]
  00d60	57		 push	 edi
  00d61	89 02		 mov	 DWORD PTR [edx], eax
  00d63	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00d66	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00d69	50		 push	 eax
  00d6a	52		 push	 edx
  00d6b	ff 71 60	 push	 DWORD PTR [ecx+96]
  00d6e	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  00d74	8d 41 70	 lea	 eax, DWORD PTR [ecx+112]
  00d77	50		 push	 eax
  00d78	6a 01		 push	 1
  00d7a	89 55 cc	 mov	 DWORD PTR tv2786[ebp], edx
  00d7d	89 7d d0	 mov	 DWORD PTR tv2782[ebp], edi
  00d80	e8 00 00 00 00	 call	 _inflate_table

; 987  :             if (ret) {

  00d85	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";
; 989  :                 state->mode = BAD;

  00d88	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d8b	83 c4 18	 add	 esp, 24			; 00000018H
  00d8e	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00d91	85 c0		 test	 eax, eax
  00d93	74 12		 je	 SHORT $LN149@inflate

; 990  :                 break;

  00d95	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d98	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00d9b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00da2	e9 ea 06 00 00	 jmp	 $LN848@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  00da7	8b 55 cc	 mov	 edx, DWORD PTR tv2786[ebp]

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  00daa	ff 75 d0	 push	 DWORD PTR tv2782[ebp]
  00dad	8b 02		 mov	 eax, DWORD PTR [edx]
  00daf	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00db2	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00db5	50		 push	 eax
  00db6	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  00dbc	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00dbf	52		 push	 edx
  00dc0	ff 71 64	 push	 DWORD PTR [ecx+100]
  00dc3	83 c0 38	 add	 eax, 56			; 00000038H
  00dc6	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00dc9	50		 push	 eax
  00dca	6a 02		 push	 2
  00dcc	e8 00 00 00 00	 call	 _inflate_table

; 996  :             if (ret) {
; 997  :                 strm->msg = (char *)"invalid distances set";
; 998  :                 state->mode = BAD;

  00dd1	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dd4	83 c4 18	 add	 esp, 24			; 00000018H
  00dd7	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00dda	85 c0		 test	 eax, eax
  00ddc	74 12		 je	 SHORT $LN148@inflate

; 999  :                 break;

  00dde	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00de1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00de4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00deb	e9 a1 06 00 00	 jmp	 $LN848@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;
; 1003 :             if (flush == Z_TREES) goto inf_leave;

  00df0	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00df4	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00dfa	0f 84 f6 06 00
	00		 je	 $LN809@inflate
  00e00	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN147@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  00e03	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  00e09	83 fb 06	 cmp	 ebx, 6
  00e0c	0f 82 77 00 00
	00		 jb	 $LN144@inflate
  00e12	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00e19	0f 82 6a 00 00
	00		 jb	 $LN144@inflate

; 1008 :                 RESTORE();

  00e1f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e22	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1009 :                 inflate_fast(strm, out);

  00e25	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  00e28	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00e2b	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00e2e	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00e31	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e34	89 38		 mov	 DWORD PTR [eax], edi
  00e36	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00e39	50		 push	 eax
  00e3a	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  00e3d	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00e40	e8 00 00 00 00	 call	 _inflate_fast

; 1010 :                 LOAD();

  00e45	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e48	83 c4 08	 add	 esp, 8
  00e4b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00e4e	8b 38		 mov	 edi, DWORD PTR [eax]
  00e50	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00e53	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00e56	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e59	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00e5c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e5f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 1011 :                 if (state->mode == TYPE)

  00e62	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  00e65	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00e68	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00e6b	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00e6e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00e71	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00e74	0f 85 1d 06 00
	00		 jne	 $LN498@inflate

; 1012 :                     state->back = -1;

  00e7a	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1013 :                 break;

  00e84	e9 0e 06 00 00	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;

  00e89	c7 81 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7108], 0

; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  00e93	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00e96	b8 01 00 00 00	 mov	 eax, 1
  00e9b	d3 e0		 shl	 eax, cl
  00e9d	48		 dec	 eax
  00e9e	89 45 d0	 mov	 DWORD PTR tv2780[ebp], eax
  00ea1	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ea4	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00ea7	8b 45 d0	 mov	 eax, DWORD PTR tv2780[ebp]
  00eaa	23 c2		 and	 eax, edx
  00eac	89 4d cc	 mov	 DWORD PTR tv2777[ebp], ecx
  00eaf	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  00eb2	8b c8		 mov	 ecx, eax
  00eb4	c1 e9 08	 shr	 ecx, 8
  00eb7	0f b6 c9	 movzx	 ecx, cl
  00eba	3b ce		 cmp	 ecx, esi
  00ebc	76 38		 jbe	 SHORT $LN572@inflate
  00ebe	8b ff		 npad	 2
$LL136@inflate:

; 1019 :                 PULLBYTE();

  00ec0	85 db		 test	 ebx, ebx
  00ec2	0f 84 2e 06 00
	00		 je	 $LN809@inflate
  00ec8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00ecb	8b ce		 mov	 ecx, esi
  00ecd	d3 e0		 shl	 eax, cl
  00ecf	8b 4d cc	 mov	 ecx, DWORD PTR tv2777[ebp]
  00ed2	4b		 dec	 ebx
  00ed3	47		 inc	 edi
  00ed4	03 d0		 add	 edx, eax
  00ed6	8b 45 d0	 mov	 eax, DWORD PTR tv2780[ebp]
  00ed9	23 c2		 and	 eax, edx
  00edb	83 c6 08	 add	 esi, 8
  00ede	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ee1	8b c8		 mov	 ecx, eax
  00ee3	c1 e9 08	 shr	 ecx, 8
  00ee6	0f b6 c9	 movzx	 ecx, cl
  00ee9	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  00eec	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00eef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00ef2	3b ce		 cmp	 ecx, esi
  00ef4	77 ca		 ja	 SHORT $LL136@inflate
$LN572@inflate:

; 1020 :             }
; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  00ef6	84 c0		 test	 al, al
  00ef8	0f 84 bc 00 00
	00		 je	 $LN118@inflate
  00efe	a8 f0		 test	 al, 240			; 000000f0H
  00f00	0f 85 b4 00 00
	00		 jne	 $LN118@inflate

; 1022 :                 last = here;
; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  00f06	8b c8		 mov	 ecx, eax
  00f08	c1 e9 08	 shr	 ecx, 8
  00f0b	0f b6 f9	 movzx	 edi, cl
  00f0e	89 4d d8	 mov	 DWORD PTR tv2776[ebp], ecx
  00f11	0f b6 c8	 movzx	 ecx, al
  00f14	03 cf		 add	 ecx, edi
  00f16	bb 01 00 00 00	 mov	 ebx, 1
  00f1b	d3 e3		 shl	 ebx, cl
  00f1d	8b cf		 mov	 ecx, edi
  00f1f	8b d0		 mov	 edx, eax
  00f21	c1 e8 10	 shr	 eax, 16			; 00000010H
  00f24	4b		 dec	 ebx
  00f25	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00f28	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  00f2b	d3 eb		 shr	 ebx, cl
  00f2d	8b 4d cc	 mov	 ecx, DWORD PTR tv2777[ebp]
  00f30	03 d8		 add	 ebx, eax
  00f32	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00f35	8b c8		 mov	 ecx, eax
  00f37	c1 e9 08	 shr	 ecx, 8
  00f3a	0f b6 f9	 movzx	 edi, cl
  00f3d	8b 4d d8	 mov	 ecx, DWORD PTR tv2776[ebp]
  00f40	0f b6 c9	 movzx	 ecx, cl
  00f43	03 f9		 add	 edi, ecx
  00f45	3b fe		 cmp	 edi, esi
  00f47	76 5b		 jbe	 SHORT $LN121@inflate
  00f49	8d a4 24 00 00
	00 00		 npad	 7
$LL128@inflate:

; 1027 :                     PULLBYTE();

  00f50	8b 45 fc	 mov	 eax, DWORD PTR _have$1$[ebp]
  00f53	85 c0		 test	 eax, eax
  00f55	0f 84 9e 05 00
	00		 je	 $inf_leave$857
  00f5b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00f5e	48		 dec	 eax
  00f5f	89 45 fc	 mov	 DWORD PTR _have$1$[ebp], eax
  00f62	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00f65	8b ce		 mov	 ecx, esi
  00f67	d3 e0		 shl	 eax, cl
  00f69	43		 inc	 ebx
  00f6a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00f6d	0f b6 de	 movzx	 ebx, dh
  00f70	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00f73	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  00f77	0f b6 ca	 movzx	 ecx, dl
  00f7a	03 cb		 add	 ecx, ebx
  00f7c	bf 01 00 00 00	 mov	 edi, 1
  00f81	d3 e7		 shl	 edi, cl
  00f83	8b cb		 mov	 ecx, ebx
  00f85	83 c6 08	 add	 esi, 8
  00f88	4f		 dec	 edi
  00f89	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  00f8c	d3 ef		 shr	 edi, cl
  00f8e	03 f8		 add	 edi, eax
  00f90	8b 45 cc	 mov	 eax, DWORD PTR tv2777[ebp]
  00f93	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00f96	8b c8		 mov	 ecx, eax
  00f98	c1 e9 08	 shr	 ecx, 8
  00f9b	0f b6 c9	 movzx	 ecx, cl
  00f9e	03 cb		 add	 ecx, ebx
  00fa0	3b ce		 cmp	 ecx, esi
  00fa2	77 ac		 ja	 SHORT $LL128@inflate
$LN121@inflate:

; 1028 :                 }
; 1029 :                 DROPBITS(last.bits);
; 1030 :                 state->back += last.bits;

  00fa4	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00fa7	0f b6 ce	 movzx	 ecx, dh
  00faa	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00fad	d3 ea		 shr	 edx, cl
  00faf	89 8b c4 1b 00
	00		 mov	 DWORD PTR [ebx+7108], ecx
  00fb5	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00fb8	2b f1		 sub	 esi, ecx
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);
; 1033 :             state->back += here.bits;

  00fba	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00fbd	8b c8		 mov	 ecx, eax
  00fbf	c1 e9 08	 shr	 ecx, 8
  00fc2	0f b6 c9	 movzx	 ecx, cl
  00fc5	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
  00fcb	d3 ea		 shr	 edx, cl
  00fcd	2b f1		 sub	 esi, ecx

; 1034 :             state->length = (unsigned)here.val;

  00fcf	8b c8		 mov	 ecx, eax
  00fd1	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00fd4	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1035 :             if ((int)(here.op) == 0) {

  00fd7	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  00fda	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00fdd	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fe0	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00fe3	84 c0		 test	 al, al
  00fe5	75 0b		 jne	 SHORT $LN115@inflate
  00fe7	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1040 :                 break;

  00fed	e9 a5 04 00 00	 jmp	 $LN498@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  00ff2	a8 20		 test	 al, 32			; 00000020H
  00ff4	74 15		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  00ff6	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1
$LN271@inflate:

; 1045 :                 state->mode = TYPE;

  01000	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1046 :                 break;

  01006	e9 8c 04 00 00	 jmp	 $LN498@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  0100b	a8 40		 test	 al, 64			; 00000040H
  0100d	74 0f		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  0100f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01012	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1050 :                 state->mode = BAD;
; 1051 :                 break;

  01019	e9 73 04 00 00	 jmp	 $LN848@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  0101e	0f b6 c0	 movzx	 eax, al
  01021	83 e0 0f	 and	 eax, 15			; 0000000fH
  01024	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1054 :             state->mode = LENEXT;

  01027	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  0102d	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01030	89 45 cc	 mov	 DWORD PTR tv2755[ebp], eax
  01033	85 c0		 test	 eax, eax
  01035	74 55		 je	 SHORT $LN111@inflate

; 1057 :                 NEEDBITS(state->extra);

  01037	3b f0		 cmp	 esi, eax
  01039	73 29		 jae	 SHORT $LN109@inflate
  0103b	eb 03 8d 49 00	 npad	 5
$LL107@inflate:
  01040	85 db		 test	 ebx, ebx
  01042	0f 84 ae 04 00
	00		 je	 $LN809@inflate
  01048	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0104b	8b ce		 mov	 ecx, esi
  0104d	d3 e0		 shl	 eax, cl
  0104f	4b		 dec	 ebx
  01050	47		 inc	 edi
  01051	83 c6 08	 add	 esi, 8
  01054	03 d0		 add	 edx, eax
  01056	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  01059	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0105c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0105f	3b 75 cc	 cmp	 esi, DWORD PTR tv2755[ebp]
  01062	72 dc		 jb	 SHORT $LL107@inflate
$LN109@inflate:

; 1058 :                 state->length += BITS(state->extra);

  01064	8b 4d cc	 mov	 ecx, DWORD PTR tv2755[ebp]
  01067	b8 01 00 00 00	 mov	 eax, 1
  0106c	d3 e0		 shl	 eax, cl
  0106e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01071	48		 dec	 eax
  01072	23 c2		 and	 eax, edx
  01074	01 41 40	 add	 DWORD PTR [ecx+64], eax

; 1059 :                 DROPBITS(state->extra);

  01077	8b 45 cc	 mov	 eax, DWORD PTR tv2755[ebp]
  0107a	8b c8		 mov	 ecx, eax
  0107c	d3 ea		 shr	 edx, cl

; 1060 :                 state->back += state->extra;

  0107e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01081	2b f0		 sub	 esi, eax
  01083	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
  01089	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  0108c	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0108f	89 81 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], eax

; 1064 :             state->mode = DIST;

  01095	c7 01 16 00 00
	00		 mov	 DWORD PTR [ecx], 22	; 00000016H
$LN546@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  0109b	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  0109e	b8 01 00 00 00	 mov	 eax, 1
  010a3	d3 e0		 shl	 eax, cl
  010a5	48		 dec	 eax
  010a6	89 45 d0	 mov	 DWORD PTR tv2753[ebp], eax
  010a9	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  010ac	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  010af	8b 45 d0	 mov	 eax, DWORD PTR tv2753[ebp]
  010b2	23 c2		 and	 eax, edx
  010b4	89 4d cc	 mov	 DWORD PTR tv2752[ebp], ecx
  010b7	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  010ba	8b c8		 mov	 ecx, eax
  010bc	c1 e9 08	 shr	 ecx, 8
  010bf	0f b6 c9	 movzx	 ecx, cl
  010c2	3b ce		 cmp	 ecx, esi
  010c4	76 36		 jbe	 SHORT $LN577@inflate
$LL97@inflate:

; 1069 :                 PULLBYTE();

  010c6	85 db		 test	 ebx, ebx
  010c8	0f 84 28 04 00
	00		 je	 $LN809@inflate
  010ce	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  010d1	8b ce		 mov	 ecx, esi
  010d3	d3 e0		 shl	 eax, cl
  010d5	8b 4d cc	 mov	 ecx, DWORD PTR tv2752[ebp]
  010d8	4b		 dec	 ebx
  010d9	47		 inc	 edi
  010da	03 d0		 add	 edx, eax
  010dc	8b 45 d0	 mov	 eax, DWORD PTR tv2753[ebp]
  010df	23 c2		 and	 eax, edx
  010e1	83 c6 08	 add	 esi, 8
  010e4	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  010e7	8b c8		 mov	 ecx, eax
  010e9	c1 e9 08	 shr	 ecx, 8
  010ec	0f b6 c9	 movzx	 ecx, cl
  010ef	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  010f2	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  010f5	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  010f8	3b ce		 cmp	 ecx, esi
  010fa	77 ca		 ja	 SHORT $LL97@inflate
$LN577@inflate:

; 1070 :             }
; 1071 :             if ((here.op & 0xf0) == 0) {

  010fc	a8 f0		 test	 al, 240			; 000000f0H
  010fe	0f 85 b5 00 00
	00		 jne	 $LN811@inflate

; 1072 :                 last = here;
; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  01104	8b c8		 mov	 ecx, eax
  01106	c1 e9 08	 shr	 ecx, 8
  01109	0f b6 f9	 movzx	 edi, cl
  0110c	89 4d d8	 mov	 DWORD PTR tv2775[ebp], ecx
  0110f	0f b6 c8	 movzx	 ecx, al
  01112	03 cf		 add	 ecx, edi
  01114	bb 01 00 00 00	 mov	 ebx, 1
  01119	d3 e3		 shl	 ebx, cl
  0111b	8b cf		 mov	 ecx, edi
  0111d	8b d0		 mov	 edx, eax
  0111f	c1 e8 10	 shr	 eax, 16			; 00000010H
  01122	4b		 dec	 ebx
  01123	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  01126	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  01129	d3 eb		 shr	 ebx, cl
  0112b	8b 4d cc	 mov	 ecx, DWORD PTR tv2752[ebp]
  0112e	03 d8		 add	 ebx, eax
  01130	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01133	8b c8		 mov	 ecx, eax
  01135	c1 e9 08	 shr	 ecx, 8
  01138	0f b6 f9	 movzx	 edi, cl
  0113b	8b 4d d8	 mov	 ecx, DWORD PTR tv2775[ebp]
  0113e	0f b6 c9	 movzx	 ecx, cl
  01141	03 f9		 add	 edi, ecx
  01143	3b fe		 cmp	 edi, esi
  01145	76 5d		 jbe	 SHORT $LN82@inflate
  01147	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL89@inflate:

; 1077 :                     PULLBYTE();

  01150	8b 45 fc	 mov	 eax, DWORD PTR _have$1$[ebp]
  01153	85 c0		 test	 eax, eax
  01155	0f 84 9e 03 00
	00		 je	 $inf_leave$857
  0115b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0115e	48		 dec	 eax
  0115f	89 45 fc	 mov	 DWORD PTR _have$1$[ebp], eax
  01162	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01165	8b ce		 mov	 ecx, esi
  01167	d3 e0		 shl	 eax, cl
  01169	43		 inc	 ebx
  0116a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0116d	0f b6 de	 movzx	 ebx, dh
  01170	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01173	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  01177	0f b6 ca	 movzx	 ecx, dl
  0117a	03 cb		 add	 ecx, ebx
  0117c	bf 01 00 00 00	 mov	 edi, 1
  01181	d3 e7		 shl	 edi, cl
  01183	8b cb		 mov	 ecx, ebx
  01185	83 c6 08	 add	 esi, 8
  01188	4f		 dec	 edi
  01189	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0118c	d3 ef		 shr	 edi, cl
  0118e	03 f8		 add	 edi, eax
  01190	8b 45 cc	 mov	 eax, DWORD PTR tv2752[ebp]
  01193	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01196	8b c8		 mov	 ecx, eax
  01198	c1 e9 08	 shr	 ecx, 8
  0119b	0f b6 c9	 movzx	 ecx, cl
  0119e	03 cb		 add	 ecx, ebx
  011a0	3b ce		 cmp	 ecx, esi
  011a2	77 ac		 ja	 SHORT $LL89@inflate
$LN82@inflate:

; 1078 :                 }
; 1079 :                 DROPBITS(last.bits);
; 1080 :                 state->back += last.bits;

  011a4	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  011a7	0f b6 ce	 movzx	 ecx, dh
  011aa	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  011ad	d3 ea		 shr	 edx, cl
  011af	2b f1		 sub	 esi, ecx
  011b1	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  011b7	eb 03		 jmp	 SHORT $LN79@inflate
$LN811@inflate:
  011b9	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN79@inflate:

; 1087 :                 break;

  011bc	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  011bf	8b c8		 mov	 ecx, eax
  011c1	c1 e9 08	 shr	 ecx, 8
  011c4	0f b6 c9	 movzx	 ecx, cl
  011c7	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  011cd	d3 ea		 shr	 edx, cl
  011cf	2b f1		 sub	 esi, ecx
  011d1	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  011d4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  011d7	a8 40		 test	 al, 64			; 00000040H
  011d9	74 15		 je	 SHORT $LN76@inflate

; 1081 :             }
; 1082 :             DROPBITS(here.bits);
; 1083 :             state->back += here.bits;
; 1084 :             if (here.op & 64) {
; 1085 :                 strm->msg = (char *)"invalid distance code";
; 1086 :                 state->mode = BAD;

  011db	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  011de	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1087 :                 break;

  011e1	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
  011e4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  011eb	e9 a1 02 00 00	 jmp	 $LN848@inflate
$LN76@inflate:

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  011f0	8b c8		 mov	 ecx, eax
  011f2	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 1090 :             state->extra = (unsigned)(here.op) & 15;

  011f5	0f b6 c0	 movzx	 eax, al
  011f8	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  011fb	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  011fe	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01201	83 e0 0f	 and	 eax, 15			; 0000000fH
  01204	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1091 :             state->mode = DISTEXT;

  01207	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  0120d	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01210	89 45 cc	 mov	 DWORD PTR tv2754[ebp], eax
  01213	85 c0		 test	 eax, eax
  01215	74 58		 je	 SHORT $LN74@inflate

; 1094 :                 NEEDBITS(state->extra);

  01217	3b f0		 cmp	 esi, eax
  01219	73 29		 jae	 SHORT $LN72@inflate
  0121b	eb 03 8d 49 00	 npad	 5
$LL70@inflate:
  01220	85 db		 test	 ebx, ebx
  01222	0f 84 ce 02 00
	00		 je	 $LN809@inflate
  01228	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0122b	8b ce		 mov	 ecx, esi
  0122d	d3 e0		 shl	 eax, cl
  0122f	4b		 dec	 ebx
  01230	47		 inc	 edi
  01231	83 c6 08	 add	 esi, 8
  01234	03 d0		 add	 edx, eax
  01236	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  01239	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0123c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0123f	3b 75 cc	 cmp	 esi, DWORD PTR tv2754[ebp]
  01242	72 dc		 jb	 SHORT $LL70@inflate
$LN72@inflate:

; 1095 :                 state->offset += BITS(state->extra);

  01244	8b 4d cc	 mov	 ecx, DWORD PTR tv2754[ebp]
  01247	b8 01 00 00 00	 mov	 eax, 1
  0124c	d3 e0		 shl	 eax, cl
  0124e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01251	48		 dec	 eax
  01252	23 c2		 and	 eax, edx
  01254	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1096 :                 DROPBITS(state->extra);

  01257	8b 45 cc	 mov	 eax, DWORD PTR tv2754[ebp]
  0125a	8b c8		 mov	 ecx, eax
  0125c	d3 ea		 shr	 edx, cl

; 1097 :                 state->back += state->extra;

  0125e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01261	2b f0		 sub	 esi, eax
  01263	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
  01269	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0126c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  0126f	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  01275	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01279	0f 84 77 02 00
	00		 je	 $LN809@inflate

; 1110 :             copy = out - left;

  0127f	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01282	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01285	89 45 cc	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1111 :             if (state->offset > copy) {         /* copy from window */

  01288	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0128b	3b 45 cc	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  0128e	76 4e		 jbe	 SHORT $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  01290	2b 45 cc	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1113 :                 if (copy > state->whave) {

  01293	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  01296	76 18		 jbe	 SHORT $LN57@inflate

; 1114 :                     if (state->sane) {

  01298	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  0129f	74 0f		 je	 SHORT $LN57@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  012a1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  012a4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1116 :                         state->mode = BAD;
; 1117 :                         break;

  012ab	e9 e1 01 00 00	 jmp	 $LN848@inflate
$LN57@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  012b0	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  012b3	76 10		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;
; 1135 :                     from = state->window + (state->wsize - copy);

  012b5	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  012b8	2b 41 30	 sub	 eax, DWORD PTR [ecx+48]
  012bb	03 79 28	 add	 edi, DWORD PTR [ecx+40]
  012be	2b f8		 sub	 edi, eax
  012c0	89 7d d0	 mov	 DWORD PTR _from$1$[ebp], edi

; 1136 :                 }
; 1137 :                 else

  012c3	eb 0b		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  012c5	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  012c8	2b d8		 sub	 ebx, eax
  012ca	03 59 30	 add	 ebx, DWORD PTR [ecx+48]
  012cd	89 5d d0	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN55@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  012d0	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  012d3	89 7d cc	 mov	 DWORD PTR tv2716[ebp], edi
  012d6	3b c7		 cmp	 eax, edi
  012d8	76 13		 jbe	 SHORT $LN53@inflate
  012da	8b c7		 mov	 eax, edi

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  012dc	eb 0f		 jmp	 SHORT $LN53@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;

  012de	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  012e1	89 5d d0	 mov	 DWORD PTR _from$1$[ebp], ebx
  012e4	29 45 d0	 sub	 DWORD PTR _from$1$[ebp], eax

; 1143 :                 copy = state->length;

  012e7	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  012ea	89 45 cc	 mov	 DWORD PTR tv2716[ebp], eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  012ed	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  012f0	3b c3		 cmp	 eax, ebx
  012f2	0f 47 c3	 cmova	 eax, ebx

; 1146 :             left -= copy;

  012f5	2b d8		 sub	 ebx, eax
  012f7	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx

; 1147 :             state->length -= copy;

  012fa	8b 5d cc	 mov	 ebx, DWORD PTR tv2716[ebp]
  012fd	2b d8		 sub	 ebx, eax
  012ff	89 59 40	 mov	 DWORD PTR [ecx+64], ebx

; 1150 :             } while (--copy);

  01302	8b 5d d0	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01305	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01308	89 45 d8	 mov	 DWORD PTR _copy$11$[ebp], eax
  0130b	2b d9		 sub	 ebx, ecx
  0130d	8b f8		 mov	 edi, eax
  0130f	90		 npad	 1
$LL51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  01310	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01313	88 01		 mov	 BYTE PTR [ecx], al
  01315	41		 inc	 ecx

; 1150 :             } while (--copy);

  01316	4f		 dec	 edi
  01317	75 f7		 jne	 SHORT $LL51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  01319	8b 5d fc	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0131c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0131f	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  01322	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01325	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  01329	0f 85 68 01 00
	00		 jne	 $LN498@inflate
  0132f	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 1152 :             break;

  01335	e9 5d 01 00 00	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  0133a	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0133e	0f 84 b2 01 00
	00		 je	 $LN809@inflate

; 1155 :             *put++ = (unsigned char)(state->length);

  01344	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  01347	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  0134a	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1156 :             left--;

  0134d	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01350	88 07		 mov	 BYTE PTR [edi], al

; 1157 :             state->mode = LEN;
; 1158 :             break;

  01352	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01355	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  0135b	e9 37 01 00 00	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  01360	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  01364	0f 84 cf 00 00
	00		 je	 $LN30@inflate

; 1161 :                 NEEDBITS(32);

  0136a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0136d	73 2b		 jae	 SHORT $LN42@inflate
  0136f	90		 npad	 1
$LL40@inflate:
  01370	85 db		 test	 ebx, ebx
  01372	0f 84 7e 01 00
	00		 je	 $LN809@inflate
  01378	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0137b	8b ce		 mov	 ecx, esi
  0137d	d3 e0		 shl	 eax, cl
  0137f	83 c6 08	 add	 esi, 8
  01382	4b		 dec	 ebx
  01383	47		 inc	 edi
  01384	03 d0		 add	 edx, eax
  01386	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  01389	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0138c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0138f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01392	83 fe 20	 cmp	 esi, 32			; 00000020H
  01395	72 d9		 jb	 SHORT $LL40@inflate
  01397	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN42@inflate:

; 1162 :                 out -= left;

  0139a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0139d	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1163 :                 strm->total_out += out;

  013a0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  013a3	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  013a6	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1164 :                 state->total += out;

  013a9	8b c7		 mov	 eax, edi
  013ab	01 41 1c	 add	 DWORD PTR [ecx+28], eax

; 1165 :                 if (out)

  013ae	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013b1	85 c0		 test	 eax, eax
  013b3	74 2f		 je	 SHORT $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  013b5	50		 push	 eax
  013b6	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  013b9	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  013bc	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  013c0	50		 push	 eax
  013c1	ff 71 18	 push	 DWORD PTR [ecx+24]
  013c4	74 07		 je	 SHORT $LN512@inflate
  013c6	e8 00 00 00 00	 call	 _crc32
  013cb	eb 05		 jmp	 SHORT $LN851@inflate
$LN512@inflate:
  013cd	e8 00 00 00 00	 call	 _adler32
$LN851@inflate:
  013d2	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013d5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  013d8	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  013db	89 42 30	 mov	 DWORD PTR [edx+48], eax
  013de	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  013e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@inflate:

; 1168 :                 out = left;
; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  013e4	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  013e8	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  013eb	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  013ee	8b c2		 mov	 eax, edx
  013f0	75 2c		 jne	 SHORT $LN515@inflate
  013f2	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  013f7	89 45 d8	 mov	 DWORD PTR tv2870[ebp], eax
  013fa	8b c2		 mov	 eax, edx
  013fc	c1 e0 10	 shl	 eax, 16			; 00000010H
  013ff	01 45 d8	 add	 DWORD PTR tv2870[ebp], eax
  01402	c1 65 d8 08	 shl	 DWORD PTR tv2870[ebp], 8
  01406	8b c2		 mov	 eax, edx
  01408	c1 e8 08	 shr	 eax, 8
  0140b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01410	01 45 d8	 add	 DWORD PTR tv2870[ebp], eax
  01413	8b c2		 mov	 eax, edx
  01415	c1 e8 18	 shr	 eax, 24			; 00000018H
  01418	01 45 d8	 add	 DWORD PTR tv2870[ebp], eax
  0141b	8b 45 d8	 mov	 eax, DWORD PTR tv2870[ebp]
$LN515@inflate:
  0141e	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  01421	74 0c		 je	 SHORT $LN32@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  01423	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01426	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1175 :                     state->mode = BAD;
; 1176 :                     break;

  0142d	eb 62		 jmp	 SHORT $LN848@inflate
$LN32@inflate:

; 1177 :                 }
; 1178 :                 INITBITS();

  0142f	33 d2		 xor	 edx, edx
  01431	33 f6		 xor	 esi, esi
  01433	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01436	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN30@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  01439	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  0143f	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  01443	0f 84 97 00 00
	00		 je	 $LN15@inflate
  01449	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0144d	0f 84 8d 00 00
	00		 je	 $LN15@inflate

; 1185 :                 NEEDBITS(32);

  01453	83 fe 20	 cmp	 esi, 32			; 00000020H
  01456	73 2a		 jae	 SHORT $LN26@inflate
$LL24@inflate:
  01458	85 db		 test	 ebx, ebx
  0145a	0f 84 96 00 00
	00		 je	 $LN809@inflate
  01460	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01463	8b ce		 mov	 ecx, esi
  01465	d3 e0		 shl	 eax, cl
  01467	83 c6 08	 add	 esi, 8
  0146a	4b		 dec	 ebx
  0146b	47		 inc	 edi
  0146c	03 d0		 add	 edx, eax
  0146e	89 5d fc	 mov	 DWORD PTR _have$1$[ebp], ebx
  01471	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01474	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01477	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0147a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0147d	72 d9		 jb	 SHORT $LL24@inflate
  0147f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN26@inflate:

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  01482	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01485	74 50		 je	 SHORT $LN17@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  01487	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0148a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
$LN848@inflate:

; 1188 :                     state->mode = BAD;

  01491	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN498@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  01497	8b 01		 mov	 eax, DWORD PTR [ecx]
  01499	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0149c	0f 86 e0 eb ff
	ff		 jbe	 $LL501@inflate
$LN11@inflate:
  014a2	5f		 pop	 edi
  014a3	5e		 pop	 esi

; 1201 :             goto inf_leave;
; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;
; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  014a4	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  014a9	5b		 pop	 ebx

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  014aa	8b e5		 mov	 esp, ebp
  014ac	5d		 pop	 ebp
  014ad	c3		 ret	 0
$LN589@inflate:

; 805  :                 RESTORE();

  014ae	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014b1	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  014b4	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  014b7	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  014ba	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  014bd	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014c0	89 38		 mov	 DWORD PTR [eax], edi
  014c2	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  014c5	5f		 pop	 edi
  014c6	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  014c9	5e		 pop	 esi
  014ca	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 806  :                 return Z_NEED_DICT;

  014cd	b8 02 00 00 00	 mov	 eax, 2
  014d2	5b		 pop	 ebx

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  014d3	8b e5		 mov	 esp, ebp
  014d5	5d		 pop	 ebp
  014d6	c3		 ret	 0
$LN17@inflate:

; 1189 :                     break;
; 1190 :                 }
; 1191 :                 INITBITS();

  014d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  014de	33 f6		 xor	 esi, esi
$LN15@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  014e0	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  014e6	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1198 :             goto inf_leave;

  014ed	eb 07		 jmp	 SHORT $LN809@inflate
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  014ef	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
$LN809@inflate:
  014f6	8b 45 fc	 mov	 eax, DWORD PTR _have$1$[ebp]
$inf_leave$857:

; 1207 :         }
; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  014f9	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  014fc	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  014ff	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01502	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  01505	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01508	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0150b	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  0150e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  01511	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  01514	89 0f		 mov	 DWORD PTR [edi], ecx

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  01516	83 7b 28 00	 cmp	 DWORD PTR [ebx+40], 0
  0151a	89 73 3c	 mov	 DWORD PTR [ebx+60], esi
  0151d	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  01520	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  01523	75 0a		 jne	 SHORT $LN6@inflate
  01525	83 3b 1a	 cmp	 DWORD PTR [ebx], 26	; 0000001aH
  01528	7d 25		 jge	 SHORT $LN5@inflate
  0152a	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  0152d	74 20		 je	 SHORT $LN5@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  0152f	56		 push	 esi
  01530	57		 push	 edi
  01531	e8 00 00 00 00	 call	 _updatewindow
  01536	83 c4 08	 add	 esp, 8
  01539	85 c0		 test	 eax, eax
  0153b	74 12		 je	 SHORT $LN5@inflate

; 1219 :             state->mode = MEM;

  0153d	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH
$LN12@inflate:
  01543	5f		 pop	 edi
  01544	5e		 pop	 esi

; 1220 :             return Z_MEM_ERROR;

  01545	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0154a	5b		 pop	 ebx

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  0154b	8b e5		 mov	 esp, ebp
  0154d	5d		 pop	 ebp
  0154e	c3		 ret	 0
$LN5@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;

  0154f	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  01552	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1223 :     out -= strm->avail_out;

  01555	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1224 :     strm->total_in += in;

  01558	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1225 :     strm->total_out += out;

  0155b	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1226 :     state->total += out;

  0155e	01 73 1c	 add	 DWORD PTR [ebx+28], esi

; 1227 :     if (state->wrap && out)

  01561	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  01565	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  01568	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  0156b	74 29		 je	 SHORT $LN4@inflate
  0156d	85 f6		 test	 esi, esi
  0156f	74 25		 je	 SHORT $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  01571	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01574	56		 push	 esi
  01575	2b c6		 sub	 eax, esi
  01577	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  0157b	50		 push	 eax
  0157c	ff 73 18	 push	 DWORD PTR [ebx+24]
  0157f	74 07		 je	 SHORT $LN516@inflate
  01581	e8 00 00 00 00	 call	 _crc32
  01586	eb 05		 jmp	 SHORT $LN852@inflate
$LN516@inflate:
  01588	e8 00 00 00 00	 call	 _adler32
$LN852@inflate:
  0158d	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  01590	83 c4 0c	 add	 esp, 12			; 0000000cH
  01593	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  01596	8b 13		 mov	 edx, DWORD PTR [ebx]
  01598	83 fa 13	 cmp	 edx, 19			; 00000013H
  0159b	74 09		 je	 SHORT $LN518@inflate
  0159d	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  015a0	74 04		 je	 SHORT $LN518@inflate
  015a2	33 f6		 xor	 esi, esi
  015a4	eb 05		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  015a6	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN519@inflate:
  015ab	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  015ae	f7 d9		 neg	 ecx
  015b0	1b c9		 sbb	 ecx, ecx
  015b2	33 c0		 xor	 eax, eax
  015b4	83 e1 40	 and	 ecx, 64			; 00000040H
  015b7	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  015ba	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2737[ebp], 128 ; 00000080H
  015c1	0f 44 45 08	 cmove	 eax, DWORD PTR tv2737[ebp]
  015c5	03 ce		 add	 ecx, esi
  015c7	03 c1		 add	 eax, ecx
  015c9	03 43 3c	 add	 eax, DWORD PTR [ebx+60]
  015cc	89 47 2c	 mov	 DWORD PTR [edi+44], eax

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  015cf	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  015d2	85 c0		 test	 eax, eax
  015d4	75 05		 jne	 SHORT $LN1@inflate
  015d6	39 45 dc	 cmp	 DWORD PTR _out$1$[ebp], eax
  015d9	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  015db	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  015df	75 14		 jne	 SHORT $LN815@inflate
$LN2@inflate:
  015e1	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  015e4	5f		 pop	 edi
  015e5	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  015ea	85 c0		 test	 eax, eax
  015ec	5e		 pop	 esi
  015ed	0f 44 c1	 cmove	 eax, ecx
  015f0	5b		 pop	 ebx

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  015f1	8b e5		 mov	 esp, ebp
  015f3	5d		 pop	 ebp
  015f4	c3		 ret	 0
$LN815@inflate:
  015f5	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  015f8	5f		 pop	 edi
  015f9	5e		 pop	 esi
  015fa	5b		 pop	 ebx
  015fb	8b e5		 mov	 esp, ebp
  015fd	5d		 pop	 ebp
  015fe	c3		 ret	 0
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  015ff	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  01604	8b e5		 mov	 esp, ebp
  01606	5d		 pop	 ebp
  01607	c3		 ret	 0
$LN855@inflate:
  01608	00 00 00 00	 DD	 $LN497@inflate
  0160c	00 00 00 00	 DD	 $LN465@inflate
  01610	00 00 00 00	 DD	 $LN445@inflate
  01614	00 00 00 00	 DD	 $LN427@inflate
  01618	00 00 00 00	 DD	 $LN410@inflate
  0161c	00 00 00 00	 DD	 $LN389@inflate
  01620	00 00 00 00	 DD	 $LN382@inflate
  01624	00 00 00 00	 DD	 $LN370@inflate
  01628	00 00 00 00	 DD	 $LN358@inflate
  0162c	00 00 00 00	 DD	 $LN341@inflate
  01630	00 00 00 00	 DD	 $LN329@inflate
  01634	00 00 00 00	 DD	 $LN324@inflate
  01638	00 00 00 00	 DD	 $LN323@inflate
  0163c	00 00 00 00	 DD	 $LN290@inflate
  01640	00 00 00 00	 DD	 $LN274@inflate
  01644	00 00 00 00	 DD	 $LN272@inflate
  01648	00 00 00 00	 DD	 $LN266@inflate
  0164c	00 00 00 00	 DD	 $LN533@inflate
  01650	00 00 00 00	 DD	 $LN536@inflate
  01654	00 00 00 00	 DD	 $LN147@inflate
  01658	00 00 00 00	 DD	 $LN145@inflate
  0165c	00 00 00 00	 DD	 $LN112@inflate
  01660	00 00 00 00	 DD	 $LN546@inflate
  01664	00 00 00 00	 DD	 $LN75@inflate
  01668	00 00 00 00	 DD	 $LN61@inflate
  0166c	00 00 00 00	 DD	 $LN47@inflate
  01670	00 00 00 00	 DD	 $LN45@inflate
  01674	00 00 00 00	 DD	 $LN29@inflate
  01678	00 00 00 00	 DD	 $LN14@inflate
  0167c	00 00 00 00	 DD	 $LN13@inflate
  01680	00 00 00 00	 DD	 $LN12@inflate
$LN856@inflate:
  01684	00 00 00 00	 DD	 $LN302@inflate
  01688	00 00 00 00	 DD	 $LN301@inflate
  0168c	00 00 00 00	 DD	 $LN296@inflate
  01690	00 00 00 00	 DD	 $LN295@inflate
_inflate ENDP
_TEXT	ENDS
END
