; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -60						; size = 4
_beg$1$ = -56						; size = 4
_end$1$ = -52						; size = 4
_last$1$ = -48						; size = 4
_window$1$ = -44					; size = 4
_wsize$1$ = -40						; size = 4
_dcode$1$ = -36						; size = 4
_lcode$1$ = -32						; size = 4
_bits$1$ = -28						; size = 4
_wnext$1$ = -24						; size = 4
_dmask$1$ = -20						; size = 4
_lmask$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_dist$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_strm$ = 8						; size = 4
_hold$1$ = 12						; size = 4
_start$ = 12						; size = 4
_inflate_fast PROC					; COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 71   :     struct inflate_state FAR *state;
; 72   :     unsigned char FAR *in;      /* local strm->next_in */
; 73   :     unsigned char FAR *last;    /* while in < last, enough input available */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  00006	53		 push	 ebx

; 101  :     out = strm->next_out - OFF;
; 102  :     beg = out - (start - strm->avail_out);

  00007	56		 push	 esi

; 116  :     dmask = (1U << state->distbits) - 1;

  00008	57		 push	 edi

; 71   :     struct inflate_state FAR *state;
; 72   :     unsigned char FAR *in;      /* local strm->next_in */
; 73   :     unsigned char FAR *last;    /* while in < last, enough input available */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  00009	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0000c	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 99   :     in = strm->next_in - OFF;

  0000f	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 100  :     last = in + (strm->avail_in - 5);

  00011	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00014	83 c0 fb	 add	 eax, -5			; fffffffbH
  00017	4b		 dec	 ebx
  00018	03 c3		 add	 eax, ebx
  0001a	89 45 d0	 mov	 DWORD PTR _last$1$[ebp], eax

; 101  :     out = strm->next_out - OFF;
; 102  :     beg = out - (start - strm->avail_out);

  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00023	8b d0		 mov	 edx, eax
  00025	2b 55 0c	 sub	 edx, DWORD PTR _start$[ebp]

; 103  :     end = out + (strm->avail_out - 257);

  00028	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0002d	4e		 dec	 esi
  0002e	03 c6		 add	 eax, esi
  00030	89 45 cc	 mov	 DWORD PTR _end$1$[ebp], eax

; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;

  00033	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00036	89 45 d8	 mov	 DWORD PTR _wsize$1$[ebp], eax

; 108  :     whave = state->whave;

  00039	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003c	89 45 c4	 mov	 DWORD PTR _whave$1$[ebp], eax

; 109  :     wnext = state->wnext;

  0003f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00042	89 45 e8	 mov	 DWORD PTR _wnext$1$[ebp], eax

; 110  :     window = state->window;

  00045	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00048	89 45 d4	 mov	 DWORD PTR _window$1$[ebp], eax

; 111  :     hold = state->hold;
; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  0004b	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0004e	89 45 e0	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 114  :     dcode = state->distcode;

  00051	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00054	89 45 dc	 mov	 DWORD PTR _dcode$1$[ebp], eax
  00057	03 d6		 add	 edx, esi

; 115  :     lmask = (1U << state->lenbits) - 1;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	89 45 f0	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 116  :     dmask = (1U << state->distbits) - 1;

  00061	89 45 ec	 mov	 DWORD PTR _dmask$1$[ebp], eax
  00064	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx
  00067	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0006a	8b 79 3c	 mov	 edi, DWORD PTR [ecx+60]
  0006d	89 55 c8	 mov	 DWORD PTR _beg$1$[ebp], edx
  00070	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00073	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00076	d3 65 f0	 shl	 DWORD PTR _lmask$1$[ebp], cl
  00079	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0007c	8b 45 ec	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  0007f	ff 4d f0	 dec	 DWORD PTR _lmask$1$[ebp]
  00082	d3 e0		 shl	 eax, cl
  00084	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  00087	48		 dec	 eax
  00088	89 45 ec	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008b	eb 03 8d 49 00	 npad	 5
$LL55@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN52@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  00095	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  00099	8b cf		 mov	 ecx, edi
  0009b	d3 e0		 shl	 eax, cl

; 123  :             bits += 8;
; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  0009d	83 c3 02	 add	 ebx, 2
  000a0	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  000a3	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  000a6	03 d0		 add	 edx, eax
  000a8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000ab	d3 e0		 shl	 eax, cl
  000ad	03 d0		 add	 edx, eax

; 125  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN52@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000b2	8b 45 f0	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d e0	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);

  000bd	8b c3		 mov	 eax, ebx
  000bf	c1 e8 08	 shr	 eax, 8
  000c2	0f b6 c8	 movzx	 ecx, al

; 130  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 131  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 0c	 mov	 DWORD PTR _hold$1$[ebp], edx

; 132  :         op = (unsigned)(here.op);

  000cc	0f b6 d3	 movzx	 edx, bl

; 133  :         if (op == 0) {                          /* literal */

  000cf	84 db		 test	 bl, bl
  000d1	74 3e		 je	 SHORT $LN72@inflate_fa
$dolen$95:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  000d3	f6 c2 10	 test	 dl, 16			; 00000010H
  000d6	75 44		 jne	 SHORT $LN73@inflate_fa

; 291  :             }
; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000d8	f6 c2 40	 test	 dl, 64			; 00000040H
  000db	0f 85 b8 02 00
	00		 jne	 $LN5@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000e1	8b ca		 mov	 ecx, edx
  000e3	8b 55 0c	 mov	 edx, DWORD PTR _hold$1$[ebp]
  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	d3 e0		 shl	 eax, cl
  000ed	8b 4d e0	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000f0	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000f3	48		 dec	 eax
  000f4	23 c2		 and	 eax, edx
  000f6	03 c3		 add	 eax, ebx
  000f8	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]
  000fb	8b c3		 mov	 eax, ebx
  000fd	c1 e8 08	 shr	 eax, 8
  00100	0f b6 c8	 movzx	 ecx, al
  00103	d3 ea		 shr	 edx, cl
  00105	2b f9		 sub	 edi, ecx
  00107	89 55 0c	 mov	 DWORD PTR _hold$1$[ebp], edx
  0010a	0f b6 d3	 movzx	 edx, bl
  0010d	84 db		 test	 bl, bl
  0010f	75 c2		 jne	 SHORT $dolen$95
$LN72@inflate_fa:

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  00111	46		 inc	 esi
  00112	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00115	88 1e		 mov	 BYTE PTR [esi], bl
  00117	e9 1b 02 00 00	 jmp	 $LN54@inflate_fa
$LN73@inflate_fa:

; 140  :             len = (unsigned)(here.val);

  0011c	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 141  :             op &= 15;                           /* number of extra bits */

  0011f	83 e2 0f	 and	 edx, 15			; 0000000fH

; 142  :             if (op) {

  00122	74 2c		 je	 SHORT $LN48@inflate_fa

; 143  :                 if (bits < op) {

  00124	3b fa		 cmp	 edi, edx
  00126	73 14		 jae	 SHORT $LN47@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  00128	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0012b	40		 inc	 eax
  0012c	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  0012f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00132	8b cf		 mov	 ecx, edi
  00134	d3 e0		 shl	 eax, cl
  00136	01 45 0c	 add	 DWORD PTR _hold$1$[ebp], eax

; 145  :                     bits += 8;

  00139	83 c7 08	 add	 edi, 8
$LN47@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  0013c	8b ca		 mov	 ecx, edx
  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	d3 e0		 shl	 eax, cl
  00145	48		 dec	 eax
  00146	23 45 0c	 and	 eax, DWORD PTR _hold$1$[ebp]

; 148  :                 hold >>= op;

  00149	d3 6d 0c	 shr	 DWORD PTR _hold$1$[ebp], cl
  0014c	03 d8		 add	 ebx, eax

; 149  :                 bits -= op;

  0014e	2b fa		 sub	 edi, edx
$LN48@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {
; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  00150	8b 55 0c	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00153	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00156	73 24		 jae	 SHORT $LN46@inflate_fa
  00158	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0015b	40		 inc	 eax
  0015c	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  0015f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00162	8b cf		 mov	 ecx, edi
  00164	d3 e0		 shl	 eax, cl

; 154  :                 bits += 8;
; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  00166	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00169	03 d0		 add	 edx, eax
  0016b	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0016e	40		 inc	 eax
  0016f	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00172	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00175	d3 e0		 shl	 eax, cl
  00177	03 d0		 add	 edx, eax

; 156  :                 bits += 8;

  00179	83 c7 10	 add	 edi, 16			; 00000010H
$LN46@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  0017c	8b 45 ec	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  0017f	8b 4d dc	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00182	23 c2		 and	 eax, edx
  00184	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00187	89 45 f8	 mov	 DWORD PTR _dist$1$[ebp], eax

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);

  0018a	c1 e8 08	 shr	 eax, 8
  0018d	0f b6 c8	 movzx	 ecx, al

; 161  :             hold >>= op;
; 162  :             bits -= op;
; 163  :             op = (unsigned)(here.op);

  00190	8b 45 f8	 mov	 eax, DWORD PTR _dist$1$[ebp]
  00193	d3 ea		 shr	 edx, cl
  00195	2b f9		 sub	 edi, ecx
  00197	89 55 0c	 mov	 DWORD PTR _hold$1$[ebp], edx
  0019a	0f b6 d0	 movzx	 edx, al

; 164  :             if (op & 16) {                      /* distance base */

  0019d	f6 c2 10	 test	 dl, 16			; 00000010H
  001a0	75 44		 jne	 SHORT $LN74@inflate_fa
$dodist$96:

; 280  :                     }
; 281  :                 }
; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001a2	f6 c2 40	 test	 dl, 64			; 00000040H
  001a5	0f 85 10 02 00
	00		 jne	 $LN8@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001ab	8b ca		 mov	 ecx, edx
  001ad	8b 55 dc	 mov	 edx, DWORD PTR _dcode$1$[ebp]
  001b0	b8 01 00 00 00	 mov	 eax, 1
  001b5	d3 e0		 shl	 eax, cl
  001b7	8b 4d f8	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  001ba	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001bd	48		 dec	 eax
  001be	23 45 0c	 and	 eax, DWORD PTR _hold$1$[ebp]
  001c1	03 c1		 add	 eax, ecx
  001c3	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001c6	8b 55 0c	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001c9	8b c1		 mov	 eax, ecx
  001cb	c1 e8 08	 shr	 eax, 8
  001ce	89 4d f8	 mov	 DWORD PTR _dist$1$[ebp], ecx
  001d1	0f b6 c8	 movzx	 ecx, al
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _dist$1$[ebp]
  001d7	d3 ea		 shr	 edx, cl
  001d9	2b f9		 sub	 edi, ecx
  001db	89 55 0c	 mov	 DWORD PTR _hold$1$[ebp], edx
  001de	0f b6 d0	 movzx	 edx, al
  001e1	f6 c2 10	 test	 dl, 16			; 00000010H
  001e4	74 bc		 je	 SHORT $dodist$96
$LN74@inflate_fa:

; 165  :                 dist = (unsigned)(here.val);

  001e6	c1 e8 10	 shr	 eax, 16			; 00000010H

; 166  :                 op &= 15;                       /* number of extra bits */

  001e9	83 e2 0f	 and	 edx, 15			; 0000000fH
  001ec	89 45 f8	 mov	 DWORD PTR _dist$1$[ebp], eax

; 167  :                 if (bits < op) {

  001ef	3b fa		 cmp	 edi, edx
  001f1	73 2c		 jae	 SHORT $LN43@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  001f3	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  001f6	40		 inc	 eax
  001f7	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001fd	8b cf		 mov	 ecx, edi
  001ff	d3 e0		 shl	 eax, cl

; 169  :                     bits += 8;

  00201	83 c7 08	 add	 edi, 8
  00204	01 45 0c	 add	 DWORD PTR _hold$1$[ebp], eax

; 170  :                     if (bits < op) {

  00207	3b fa		 cmp	 edi, edx
  00209	73 14		 jae	 SHORT $LN43@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  0020b	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  0020e	40		 inc	 eax
  0020f	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00212	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00215	8b cf		 mov	 ecx, edi
  00217	d3 e0		 shl	 eax, cl
  00219	01 45 0c	 add	 DWORD PTR _hold$1$[ebp], eax

; 172  :                         bits += 8;

  0021c	83 c7 08	 add	 edi, 8
$LN43@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0021f	8b ca		 mov	 ecx, edx
  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	d3 e0		 shl	 eax, cl

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;
; 184  :                 bits -= op;

  00228	2b fa		 sub	 edi, edx
  0022a	89 7d e4	 mov	 DWORD PTR _bits$1$[ebp], edi
  0022d	48		 dec	 eax
  0022e	23 45 0c	 and	 eax, DWORD PTR _hold$1$[ebp]
  00231	d3 6d 0c	 shr	 DWORD PTR _hold$1$[ebp], cl
  00234	01 45 f8	 add	 DWORD PTR _dist$1$[ebp], eax

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */
; 187  :                 if (dist > op) {                /* see if copy from window */

  00237	8b 55 f8	 mov	 edx, DWORD PTR _dist$1$[ebp]
  0023a	8b c6		 mov	 eax, esi
  0023c	2b 45 c8	 sub	 eax, DWORD PTR _beg$1$[ebp]
  0023f	3b d0		 cmp	 edx, eax
  00241	0f 86 0d 01 00
	00		 jbe	 $LN42@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00247	8b ca		 mov	 ecx, edx
  00249	2b c8		 sub	 ecx, eax

; 189  :                     if (op > whave) {

  0024b	3b 4d c4	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0024e	76 10		 jbe	 SHORT $LN40@inflate_fa

; 190  :                         if (state->sane) {

  00250	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00253	83 b8 c0 1b 00
	00 00		 cmp	 DWORD PTR [eax+7104], 0
  0025a	0f 85 6a 01 00
	00		 jne	 $LN75@inflate_fa
$LN40@inflate_fa:

; 194  :                             break;
; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  00260	8b 7d d4	 mov	 edi, DWORD PTR _window$1$[ebp]

; 217  :                     if (wnext == 0) {           /* very common case */

  00263	8b 45 e8	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  00266	4f		 dec	 edi
  00267	85 c0		 test	 eax, eax
  00269	75 1b		 jne	 SHORT $LN39@inflate_fa

; 218  :                         from += wsize - op;

  0026b	8b 45 d8	 mov	 eax, DWORD PTR _wsize$1$[ebp]
  0026e	2b c1		 sub	 eax, ecx
  00270	03 f8		 add	 edi, eax

; 219  :                         if (op < len) {         /* some from window */

  00272	3b cb		 cmp	 ecx, ebx
  00274	73 72		 jae	 SHORT $LN69@inflate_fa

; 220  :                             len -= op;

  00276	2b d9		 sub	 ebx, ecx
$LL37@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  00278	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0027b	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0027e	46		 inc	 esi
  0027f	88 06		 mov	 BYTE PTR [esi], al

; 223  :                             } while (--op);

  00281	49		 dec	 ecx
  00282	75 f4		 jne	 SHORT $LL37@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */
; 225  :                         }

  00284	eb 5e		 jmp	 SHORT $LN91@inflate_fa
$LN39@inflate_fa:

; 226  :                     }
; 227  :                     else if (wnext < op) {      /* wrap around window */

  00286	3b c1		 cmp	 eax, ecx
  00288	73 44		 jae	 SHORT $LN33@inflate_fa

; 228  :                         from += wsize + wnext - op;

  0028a	2b c1		 sub	 eax, ecx
  0028c	03 45 d8	 add	 eax, DWORD PTR _wsize$1$[ebp]

; 229  :                         op -= wnext;

  0028f	2b 4d e8	 sub	 ecx, DWORD PTR _wnext$1$[ebp]
  00292	03 f8		 add	 edi, eax

; 230  :                         if (op < len) {         /* some from end of window */

  00294	3b cb		 cmp	 ecx, ebx
  00296	73 50		 jae	 SHORT $LN69@inflate_fa

; 231  :                             len -= op;

  00298	2b d9		 sub	 ebx, ecx

; 234  :                             } while (--op);

  0029a	2b fe		 sub	 edi, esi
  0029c	8d 64 24 00	 npad	 4
$LL31@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  002a0	8a 44 37 01	 mov	 al, BYTE PTR [edi+esi+1]
  002a4	46		 inc	 esi
  002a5	88 06		 mov	 BYTE PTR [esi], al

; 234  :                             } while (--op);

  002a7	49		 dec	 ecx
  002a8	75 f6		 jne	 SHORT $LL31@inflate_fa

; 235  :                             from = window - OFF;

  002aa	8b 7d d4	 mov	 edi, DWORD PTR _window$1$[ebp]

; 236  :                             if (wnext < len) {  /* some from start of window */

  002ad	8b 45 e8	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002b0	4f		 dec	 edi
  002b1	3b c3		 cmp	 eax, ebx
  002b3	73 33		 jae	 SHORT $LN69@inflate_fa

; 237  :                                 op = wnext;

  002b5	8b c8		 mov	 ecx, eax

; 238  :                                 len -= op;

  002b7	2b d8		 sub	 ebx, eax
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL27@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  002c0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002c3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002c6	46		 inc	 esi
  002c7	88 06		 mov	 BYTE PTR [esi], al

; 241  :                                 } while (--op);

  002c9	49		 dec	 ecx
  002ca	75 f4		 jne	 SHORT $LL27@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */
; 243  :                             }
; 244  :                         }
; 245  :                     }
; 246  :                     else {                      /* contiguous in window */

  002cc	eb 16		 jmp	 SHORT $LN91@inflate_fa
$LN33@inflate_fa:

; 247  :                         from += wnext - op;

  002ce	2b c1		 sub	 eax, ecx
  002d0	03 f8		 add	 edi, eax

; 248  :                         if (op < len) {         /* some from window */

  002d2	3b cb		 cmp	 ecx, ebx
  002d4	73 12		 jae	 SHORT $LN69@inflate_fa

; 249  :                             len -= op;

  002d6	2b d9		 sub	 ebx, ecx
$LL22@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  002d8	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002db	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002de	46		 inc	 esi
  002df	88 06		 mov	 BYTE PTR [esi], al

; 252  :                             } while (--op);

  002e1	49		 dec	 ecx
  002e2	75 f4		 jne	 SHORT $LL22@inflate_fa
$LN91@inflate_fa:

; 253  :                             from = out - dist;  /* rest from output */

  002e4	8b fe		 mov	 edi, esi
  002e6	2b fa		 sub	 edi, edx
$LN69@inflate_fa:

; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  002e8	83 fb 02	 cmp	 ebx, 2
  002eb	76 32		 jbe	 SHORT $LN18@inflate_fa
  002ed	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  002f0	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002f5	f7 e1		 mul	 ecx
  002f7	d1 ea		 shr	 edx, 1
  002f9	42		 inc	 edx
  002fa	8d 9b 00 00 00
	00		 npad	 6
$LL19@inflate_fa:

; 257  :                         PUP(out) = PUP(from);

  00300	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00304	88 46 01	 mov	 BYTE PTR [esi+1], al

; 258  :                         PUP(out) = PUP(from);

  00307	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]

; 259  :                         PUP(out) = PUP(from);

  0030b	83 c7 03	 add	 edi, 3
  0030e	88 46 02	 mov	 BYTE PTR [esi+2], al
  00311	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00314	83 c6 03	 add	 esi, 3

; 260  :                         len -= 3;

  00317	83 eb 03	 sub	 ebx, 3
  0031a	88 06		 mov	 BYTE PTR [esi], al
  0031c	4a		 dec	 edx
  0031d	75 e1		 jne	 SHORT $LL19@inflate_fa
$LN18@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  0031f	85 db		 test	 ebx, ebx
  00321	74 11		 je	 SHORT $LN89@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  00323	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00326	46		 inc	 esi
  00327	88 06		 mov	 BYTE PTR [esi], al

; 264  :                         if (len > 1)

  00329	83 fb 01	 cmp	 ebx, 1
  0032c	76 06		 jbe	 SHORT $LN89@inflate_fa

; 265  :                             PUP(out) = PUP(from);

  0032e	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  00331	46		 inc	 esi
  00332	88 06		 mov	 BYTE PTR [esi], al
$LN89@inflate_fa:
  00334	8b 7d e4	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN54@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  00337	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  0033a	3b 5d d0	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  0033d	0f 83 9a 00 00
	00		 jae	 $LN53@inflate_fa
  00343	3b 75 cc	 cmp	 esi, DWORD PTR _end$1$[ebp]
  00346	0f 83 91 00 00
	00		 jae	 $LN53@inflate_fa
  0034c	8b 55 0c	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0034f	e9 3c fd ff ff	 jmp	 $LL55@inflate_fa
$LN42@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {
; 269  :                     from = out - dist;          /* copy direct from output */

  00354	8b ce		 mov	 ecx, esi
  00356	2b ca		 sub	 ecx, edx
  00358	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL14@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  00360	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00364	88 46 01	 mov	 BYTE PTR [esi+1], al

; 272  :                         PUP(out) = PUP(from);

  00367	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  0036b	88 46 02	 mov	 BYTE PTR [esi+2], al

; 273  :                         PUP(out) = PUP(from);

  0036e	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00372	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  00375	83 c6 03	 add	 esi, 3

; 274  :                         len -= 3;

  00378	83 eb 03	 sub	 ebx, 3
  0037b	88 06		 mov	 BYTE PTR [esi], al

; 275  :                     } while (len > 2);

  0037d	83 fb 02	 cmp	 ebx, 2
  00380	77 de		 ja	 SHORT $LL14@inflate_fa

; 276  :                     if (len) {

  00382	85 db		 test	 ebx, ebx
  00384	74 b1		 je	 SHORT $LN54@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  00386	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00389	46		 inc	 esi
  0038a	88 06		 mov	 BYTE PTR [esi], al

; 278  :                         if (len > 1)

  0038c	83 fb 01	 cmp	 ebx, 1
  0038f	76 a6		 jbe	 SHORT $LN54@inflate_fa

; 279  :                             PUP(out) = PUP(from);

  00391	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00394	46		 inc	 esi
  00395	88 06		 mov	 BYTE PTR [esi], al
  00397	eb 9e		 jmp	 SHORT $LN54@inflate_fa
$LN5@inflate_fa:

; 300  :             break;

  00399	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  0039c	f6 c2 20	 test	 dl, 32			; 00000020H
  0039f	74 0b		 je	 SHORT $LN3@inflate_fa

; 295  :             goto dolen;
; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */
; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  003a1	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  003a4	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 300  :             break;

  003aa	eb 31		 jmp	 SHORT $LN53@inflate_fa
$LN3@inflate_fa:

; 301  :         }
; 302  :         else {
; 303  :             strm->msg = (char *)"invalid literal/length code";

  003ac	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  003af	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 304  :             state->mode = BAD;

  003b6	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  003b9	eb 1c		 jmp	 SHORT $LN92@inflate_fa
$LN8@inflate_fa:

; 285  :                 goto dodist;
; 286  :             }
; 287  :             else {
; 288  :                 strm->msg = (char *)"invalid distance code";

  003bb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  003be	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 289  :                 state->mode = BAD;

  003c5	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]

; 290  :                 break;

  003c8	eb 0a		 jmp	 SHORT $LN93@inflate_fa
$LN75@inflate_fa:

; 191  :                             strm->msg =
; 192  :                                 (char *)"invalid distance too far back";

  003ca	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  003cd	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
$LN93@inflate_fa:
  003d4	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN92@inflate_fa:

; 193  :                             state->mode = BAD;

  003d7	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH
$LN53@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;
; 311  :     in -= len;
; 312  :     bits -= len << 3;
; 313  :     hold &= (1U << bits) - 1;
; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  003dd	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  003e0	8b c7		 mov	 eax, edi
  003e2	c1 e8 03	 shr	 eax, 3
  003e5	2b d8		 sub	 ebx, eax
  003e7	c1 e0 03	 shl	 eax, 3
  003ea	2b f8		 sub	 edi, eax
  003ec	8b cf		 mov	 ecx, edi
  003ee	b8 01 00 00 00	 mov	 eax, 1
  003f3	d3 e0		 shl	 eax, cl
  003f5	8b 4d 0c	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  003f8	48		 dec	 eax
  003f9	23 c8		 and	 ecx, eax
  003fb	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  003fe	89 02		 mov	 DWORD PTR [edx], eax

; 317  :     strm->next_out = out + OFF;

  00400	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00403	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  00406	8b 45 d0	 mov	 eax, DWORD PTR _last$1$[ebp]
  00409	2b c3		 sub	 eax, ebx
  0040b	8b da		 mov	 ebx, edx

; 319  :     strm->avail_out = (unsigned)(out < end ?
; 320  :                                  257 + (end - out) : 257 - (out - end));

  0040d	8b 55 cc	 mov	 edx, DWORD PTR _end$1$[ebp]
  00410	83 c0 05	 add	 eax, 5
  00413	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 321  :     state->hold = hold;

  00416	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00419	2b d6		 sub	 edx, esi
  0041b	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00421	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 322  :     state->bits = bits;

  00424	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00427	5f		 pop	 edi
  00428	5e		 pop	 esi
  00429	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0042c	5b		 pop	 ebx

; 323  :     return;
; 324  : }

  0042d	8b e5		 mov	 esp, ebp
  0042f	5d		 pop	 ebp
  00430	c3		 ret	 0
_inflate_fast ENDP
_TEXT	ENDS
END
