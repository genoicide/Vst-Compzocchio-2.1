; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gzdopen
PUBLIC	_gzbuffer
PUBLIC	_gzrewind
PUBLIC	_gzeof
PUBLIC	_gzerror
PUBLIC	_gzclearerr
PUBLIC	_gzopen
PUBLIC	_gzseek
PUBLIC	_gztell
PUBLIC	_gzoffset
PUBLIC	_gzopen64
PUBLIC	_gzseek64
PUBLIC	_gztell64
PUBLIC	_gzoffset64
PUBLIC	_gz_error
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	_sprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_lseek:PROC
EXTRN	_open:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gz_open
_TEXT	SEGMENT
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 92   :     gz_statep state;
; 93   : 
; 94   :     /* allocate gzFile structure to return */
; 95   :     state = malloc(sizeof(gz_state));

  00004	68 8c 00 00 00	 push	 140			; 0000008cH
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	8b f0		 mov	 esi, eax
  00010	83 c4 04	 add	 esp, 4

; 96   :     if (state == NULL)

  00013	85 f6		 test	 esi, esi
  00015	0f 84 eb 00 00
	00		 je	 $LN42@gz_open

; 97   :         return NULL;
; 98   :     state->size = 0;            /* no buffers allocated yet */
; 99   :     state->want = GZBUFSIZE;    /* requested buffer size */
; 100  :     state->msg = NULL;          /* no error message yet */
; 101  : 
; 102  :     /* interpret mode */
; 103  :     state->mode = GZ_NONE;
; 104  :     state->level = Z_DEFAULT_COMPRESSION;
; 105  :     state->strategy = Z_DEFAULT_STRATEGY;
; 106  :     while (*mode) {

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00025	c7 46 14 00 20
	00 00		 mov	 DWORD PTR [esi+20], 8192 ; 00002000H
  0002c	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00039	c7 46 3c ff ff
	ff ff		 mov	 DWORD PTR [esi+60], -1
  00040	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  00047	8a 01		 mov	 al, BYTE PTR [ecx]
  00049	84 c0		 test	 al, al
  0004b	0f 84 ac 00 00
	00		 je	 $LN13@gz_open
$LL22@gz_open:

; 107  :         if (*mode >= '0' && *mode <= '9')

  00051	3c 30		 cmp	 al, 48			; 00000030H
  00053	7c 0f		 jl	 SHORT $LN20@gz_open
  00055	3c 39		 cmp	 al, 57			; 00000039H
  00057	7f 0b		 jg	 SHORT $LN20@gz_open

; 108  :             state->level = *mode - '0';

  00059	0f be c0	 movsx	 eax, al
  0005c	83 e8 30	 sub	 eax, 48			; 00000030H
  0005f	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 109  :         else

  00062	eb 53		 jmp	 SHORT $LN7@gz_open
$LN20@gz_open:

; 110  :             switch (*mode) {

  00064	0f be c0	 movsx	 eax, al
  00067	83 c0 d5	 add	 eax, -43		; ffffffd5H
  0006a	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0006d	77 48		 ja	 SHORT $LN7@gz_open
  0006f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN37@gz_open[eax]
  00076	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN44@gz_open[eax*4]
$LN16@gz_open:

; 111  :             case 'r':
; 112  :                 state->mode = GZ_READ;

  0007d	c7 06 4f 1c 00
	00		 mov	 DWORD PTR [esi], 7247	; 00001c4fH

; 113  :                 break;

  00083	eb 32		 jmp	 SHORT $LN7@gz_open
$LN15@gz_open:

; 114  : #ifndef NO_GZCOMPRESS
; 115  :             case 'w':
; 116  :                 state->mode = GZ_WRITE;

  00085	c7 06 b1 79 00
	00		 mov	 DWORD PTR [esi], 31153	; 000079b1H

; 117  :                 break;

  0008b	eb 2a		 jmp	 SHORT $LN7@gz_open
$LN14@gz_open:

; 118  :             case 'a':
; 119  :                 state->mode = GZ_APPEND;

  0008d	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1

; 120  :                 break;

  00093	eb 22		 jmp	 SHORT $LN7@gz_open
$LN11@gz_open:

; 125  :             case 'b':       /* ignore -- will request binary anyway */
; 126  :                 break;
; 127  :             case 'f':
; 128  :                 state->strategy = Z_FILTERED;

  00095	c7 46 40 01 00
	00 00		 mov	 DWORD PTR [esi+64], 1

; 129  :                 break;

  0009c	eb 19		 jmp	 SHORT $LN7@gz_open
$LN10@gz_open:

; 130  :             case 'h':
; 131  :                 state->strategy = Z_HUFFMAN_ONLY;

  0009e	c7 46 40 02 00
	00 00		 mov	 DWORD PTR [esi+64], 2

; 132  :                 break;

  000a5	eb 10		 jmp	 SHORT $LN7@gz_open
$LN9@gz_open:

; 133  :             case 'R':
; 134  :                 state->strategy = Z_RLE;

  000a7	c7 46 40 03 00
	00 00		 mov	 DWORD PTR [esi+64], 3

; 135  :                 break;

  000ae	eb 07		 jmp	 SHORT $LN7@gz_open
$LN8@gz_open:

; 136  :             case 'F':
; 137  :                 state->strategy = Z_FIXED;

  000b0	c7 46 40 04 00
	00 00		 mov	 DWORD PTR [esi+64], 4
$LN7@gz_open:

; 97   :         return NULL;
; 98   :     state->size = 0;            /* no buffers allocated yet */
; 99   :     state->want = GZBUFSIZE;    /* requested buffer size */
; 100  :     state->msg = NULL;          /* no error message yet */
; 101  : 
; 102  :     /* interpret mode */
; 103  :     state->mode = GZ_NONE;
; 104  :     state->level = Z_DEFAULT_COMPRESSION;
; 105  :     state->strategy = Z_DEFAULT_STRATEGY;
; 106  :     while (*mode) {

  000b7	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 138  :             default:        /* could consider as an error, but just ignore */
; 139  :                 ;
; 140  :             }
; 141  :         mode++;

  000ba	41		 inc	 ecx
  000bb	84 c0		 test	 al, al
  000bd	75 92		 jne	 SHORT $LL22@gz_open

; 142  :     }
; 143  : 
; 144  :     /* must provide an "r", "w", or "a" */
; 145  :     if (state->mode == GZ_NONE) {

  000bf	83 3e 00	 cmp	 DWORD PTR [esi], 0
  000c2	74 39		 je	 SHORT $LN13@gz_open

; 146  :         free(state);
; 147  :         return NULL;
; 148  :     }
; 149  : 
; 150  :     /* save the path name for error messages */
; 151  :     state->path = malloc(strlen(path) + 1);

  000c4	57		 push	 edi
  000c5	8b 7d 08	 mov	 edi, DWORD PTR _path$[ebp]
  000c8	8b cf		 mov	 ecx, edi
  000ca	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000cd	8d 49 00	 npad	 3
$LL38@gz_open:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	41		 inc	 ecx
  000d3	84 c0		 test	 al, al
  000d5	75 f9		 jne	 SHORT $LL38@gz_open
  000d7	2b ca		 sub	 ecx, edx
  000d9	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _malloc
  000e2	8b c8		 mov	 ecx, eax
  000e4	83 c4 04	 add	 esp, 4
  000e7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 152  :     if (state->path == NULL) {

  000ea	85 c9		 test	 ecx, ecx
  000ec	75 1d		 jne	 SHORT $LN5@gz_open

; 153  :         free(state);

  000ee	56		 push	 esi
  000ef	e8 00 00 00 00	 call	 _free
  000f4	83 c4 04	 add	 esp, 4

; 154  :         return NULL;

  000f7	33 c0		 xor	 eax, eax
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi

; 193  : }

  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN13@gz_open:

; 121  : #endif
; 122  :             case '+':       /* can't read and write at the same time */
; 123  :                 free(state);

  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 _free
  00103	83 c4 04	 add	 esp, 4
$LN42@gz_open:

; 124  :                 return NULL;

  00106	33 c0		 xor	 eax, eax
  00108	5e		 pop	 esi

; 193  : }

  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
$LN5@gz_open:

; 155  :     }
; 156  :     strcpy(state->path, path);

  0010b	8b d7		 mov	 edx, edi
  0010d	8d 49 00	 npad	 3
$LL26@gz_open:
  00110	8a 02		 mov	 al, BYTE PTR [edx]
  00112	88 01		 mov	 BYTE PTR [ecx], al
  00114	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00117	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0011a	84 c0		 test	 al, al
  0011c	75 f2		 jne	 SHORT $LL26@gz_open

; 157  : 
; 158  :     /* open the file with the appropriate mode (or just use fd) */
; 159  :     state->fd = fd != -1 ? fd :
; 160  :         open(path,
; 161  : #ifdef O_LARGEFILE
; 162  :             O_LARGEFILE |
; 163  : #endif
; 164  : #ifdef O_BINARY
; 165  :             O_BINARY |
; 166  : #endif
; 167  :             (state->mode == GZ_READ ?
; 168  :                 O_RDONLY :
; 169  :                 (O_WRONLY | O_CREAT | (
; 170  :                     state->mode == GZ_WRITE ?
; 171  :                         O_TRUNC :
; 172  :                         O_APPEND))),
; 173  :             0666);

  0011e	8b 45 0c	 mov	 eax, DWORD PTR _fd$[ebp]
  00121	83 f8 ff	 cmp	 eax, -1
  00124	75 3a		 jne	 SHORT $LN30@gz_open
  00126	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00128	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  0012e	75 04		 jne	 SHORT $LN27@gz_open
  00130	33 c0		 xor	 eax, eax
  00132	eb 18		 jmp	 SHORT $LN28@gz_open
$LN27@gz_open:
  00134	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H
  0013a	b8 08 00 00 00	 mov	 eax, 8
  0013f	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00144	0f 44 c2	 cmove	 eax, edx
  00147	0d 01 01 00 00	 or	 eax, 257		; 00000101H
$LN28@gz_open:
  0014c	68 b6 01 00 00	 push	 438			; 000001b6H
  00151	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00156	50		 push	 eax
  00157	57		 push	 edi
  00158	e8 00 00 00 00	 call	 _open
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@gz_open:
  00160	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 174  :     if (state->fd == -1) {

  00163	83 f8 ff	 cmp	 eax, -1
  00166	75 17		 jne	 SHORT $LN4@gz_open

; 175  :         free(state->path);

  00168	ff 76 08	 push	 DWORD PTR [esi+8]
  0016b	e8 00 00 00 00	 call	 _free

; 176  :         free(state);

  00170	56		 push	 esi
  00171	e8 00 00 00 00	 call	 _free
  00176	83 c4 08	 add	 esp, 8
  00179	33 c0		 xor	 eax, eax
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi

; 193  : }

  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
$LN4@gz_open:

; 177  :         return NULL;
; 178  :     }
; 179  :     if (state->mode == GZ_APPEND)

  0017f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00181	83 f9 01	 cmp	 ecx, 1
  00184	75 15		 jne	 SHORT $LN3@gz_open

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  00186	56		 push	 esi
  00187	c7 06 b1 79 00
	00		 mov	 DWORD PTR [esi], 31153	; 000079b1H
  0018d	e8 00 00 00 00	 call	 _gz_reset
  00192	83 c4 04	 add	 esp, 4

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  00195	8b c6		 mov	 eax, esi
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi

; 193  : }

  00199	5d		 pop	 ebp
  0019a	c3		 ret	 0
$LN3@gz_open:

; 180  :         state->mode = GZ_WRITE;         /* simplify later checks */
; 181  : 
; 182  :     /* save the current position for rewinding (only if reading) */
; 183  :     if (state->mode == GZ_READ) {

  0019b	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  001a1	75 1c		 jne	 SHORT $LN1@gz_open

; 184  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  001a3	6a 01		 push	 1
  001a5	6a 00		 push	 0
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _lseek
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b0	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 185  :         if (state->start == -1) state->start = 0;

  001b3	83 f8 ff	 cmp	 eax, -1
  001b6	75 07		 jne	 SHORT $LN1@gz_open
  001b8	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN1@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  001bf	56		 push	 esi
  001c0	e8 00 00 00 00	 call	 _gz_reset
  001c5	83 c4 04	 add	 esp, 4

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  001c8	8b c6		 mov	 eax, esi
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi

; 193  : }

  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
  001ce	8b ff		 npad	 2
$LN44@gz_open:
  001d0	00 00 00 00	 DD	 $LN13@gz_open
  001d4	00 00 00 00	 DD	 $LN8@gz_open
  001d8	00 00 00 00	 DD	 $LN9@gz_open
  001dc	00 00 00 00	 DD	 $LN14@gz_open
  001e0	00 00 00 00	 DD	 $LN11@gz_open
  001e4	00 00 00 00	 DD	 $LN10@gz_open
  001e8	00 00 00 00	 DD	 $LN16@gz_open
  001ec	00 00 00 00	 DD	 $LN15@gz_open
  001f0	00 00 00 00	 DD	 $LN7@gz_open
$LN37@gz_open:
  001f4	00		 DB	 0
  001f5	08		 DB	 8
  001f6	08		 DB	 8
  001f7	08		 DB	 8
  001f8	08		 DB	 8
  001f9	08		 DB	 8
  001fa	08		 DB	 8
  001fb	08		 DB	 8
  001fc	08		 DB	 8
  001fd	08		 DB	 8
  001fe	08		 DB	 8
  001ff	08		 DB	 8
  00200	08		 DB	 8
  00201	08		 DB	 8
  00202	08		 DB	 8
  00203	08		 DB	 8
  00204	08		 DB	 8
  00205	08		 DB	 8
  00206	08		 DB	 8
  00207	08		 DB	 8
  00208	08		 DB	 8
  00209	08		 DB	 8
  0020a	08		 DB	 8
  0020b	08		 DB	 8
  0020c	08		 DB	 8
  0020d	08		 DB	 8
  0020e	08		 DB	 8
  0020f	01		 DB	 1
  00210	08		 DB	 8
  00211	08		 DB	 8
  00212	08		 DB	 8
  00213	08		 DB	 8
  00214	08		 DB	 8
  00215	08		 DB	 8
  00216	08		 DB	 8
  00217	08		 DB	 8
  00218	08		 DB	 8
  00219	08		 DB	 8
  0021a	08		 DB	 8
  0021b	02		 DB	 2
  0021c	08		 DB	 8
  0021d	08		 DB	 8
  0021e	08		 DB	 8
  0021f	08		 DB	 8
  00220	08		 DB	 8
  00221	08		 DB	 8
  00222	08		 DB	 8
  00223	08		 DB	 8
  00224	08		 DB	 8
  00225	08		 DB	 8
  00226	08		 DB	 8
  00227	08		 DB	 8
  00228	08		 DB	 8
  00229	08		 DB	 8
  0022a	03		 DB	 3
  0022b	08		 DB	 8
  0022c	08		 DB	 8
  0022d	08		 DB	 8
  0022e	08		 DB	 8
  0022f	04		 DB	 4
  00230	08		 DB	 8
  00231	05		 DB	 5
  00232	08		 DB	 8
  00233	08		 DB	 8
  00234	08		 DB	 8
  00235	08		 DB	 8
  00236	08		 DB	 8
  00237	08		 DB	 8
  00238	08		 DB	 8
  00239	08		 DB	 8
  0023a	08		 DB	 8
  0023b	06		 DB	 6
  0023c	08		 DB	 8
  0023d	08		 DB	 8
  0023e	08		 DB	 8
  0023f	08		 DB	 8
  00240	07		 DB	 7
_gz_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 74   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00004	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  00007	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  0000d	75 1c		 jne	 SHORT $LN1@gz_reset

; 75   :         state->have = 0;            /* no output data available */

  0000f	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 76   :         state->eof = 0;             /* not at end of file */

  00016	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 77   :         state->how = LOOK;          /* look for gzip header */

  0001d	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 78   :         state->direct = 1;          /* default for empty file */

  00024	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [esi+56], 1
$LN1@gz_reset:

; 79   :     }
; 80   :     state->seek = 0;                /* no seek request pending */
; 81   :     gz_error(state, Z_OK, NULL);    /* clear error */

  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	56		 push	 esi
  00030	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00037	e8 00 00 00 00	 call	 _gz_error
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :     state->pos = 0;                 /* no uncompressed data yet */

  0003f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 83   :     state->strm.avail_in = 0;       /* no input data yet */

  00046	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004d	5e		 pop	 esi

; 84   : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
tv147 = 8						; size = 4
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 490  :     /* free previously allocated message and clear */
; 491  :     if (state->msg != NULL) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR _state$[ebp]
  00008	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  0000b	85 c0		 test	 eax, eax
  0000d	74 16		 je	 SHORT $LN5@gz_error

; 492  :         if (state->err != Z_MEM_ERROR)

  0000f	83 7f 4c fc	 cmp	 DWORD PTR [edi+76], -4	; fffffffcH
  00013	74 09		 je	 SHORT $LN4@gz_error

; 493  :             free(state->msg);

  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 04	 add	 esp, 4
$LN4@gz_error:

; 494  :         state->msg = NULL;

  0001e	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0
$LN5@gz_error:

; 495  :     }
; 496  : 
; 497  :     /* set error code, and if no message, then done */
; 498  :     state->err = err;
; 499  :     if (msg == NULL)

  00025	8b 5d 10	 mov	 ebx, DWORD PTR _msg$[ebp]
  00028	8b 45 0c	 mov	 eax, DWORD PTR _err$[ebp]
  0002b	89 47 4c	 mov	 DWORD PTR [edi+76], eax
  0002e	85 db		 test	 ebx, ebx
  00030	0f 84 b2 00 00
	00		 je	 $LN6@gz_error

; 500  :         return;
; 501  : 
; 502  :     /* for an out of memory error, save as static string */
; 503  :     if (err == Z_MEM_ERROR) {

  00036	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00039	75 07		 jne	 SHORT $LN2@gz_error

; 504  :         state->msg = (char *)msg;

  0003b	89 5f 50	 mov	 DWORD PTR [edi+80], ebx
  0003e	5f		 pop	 edi
  0003f	5b		 pop	 ebx

; 517  :     return;
; 518  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN2@gz_error:
  00042	56		 push	 esi

; 505  :         return;
; 506  :     }
; 507  : 
; 508  :     /* construct error message with path */
; 509  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00043	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00046	8b ce		 mov	 ecx, esi
  00048	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0004b	eb 03 8d 49 00	 npad	 5
$LL11@gz_error:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL11@gz_error
  00057	2b ca		 sub	 ecx, edx
  00059	8b d3		 mov	 edx, ebx
  0005b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0005e	89 45 08	 mov	 DWORD PTR tv147[ebp], eax
$LL12@gz_error:
  00061	8a 02		 mov	 al, BYTE PTR [edx]
  00063	42		 inc	 edx
  00064	84 c0		 test	 al, al
  00066	75 f9		 jne	 SHORT $LL12@gz_error
  00068	2b 55 08	 sub	 edx, DWORD PTR tv147[ebp]
  0006b	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  0006e	03 c2		 add	 eax, edx
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _malloc
  00076	8b c8		 mov	 ecx, eax
  00078	83 c4 04	 add	 esp, 4
  0007b	89 4f 50	 mov	 DWORD PTR [edi+80], ecx
  0007e	85 c9		 test	 ecx, ecx
  00080	75 13		 jne	 SHORT $LL1@gz_error

; 510  :         state->err = Z_MEM_ERROR;

  00082	5e		 pop	 esi
  00083	c7 47 4c fc ff
	ff ff		 mov	 DWORD PTR [edi+76], -4	; fffffffcH

; 511  :         state->msg = (char *)"out of memory";

  0008a	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00091	5f		 pop	 edi
  00092	5b		 pop	 ebx

; 517  :     return;
; 518  : }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LL1@gz_error:

; 512  :         return;
; 513  :     }
; 514  :     strcpy(state->msg, state->path);

  00095	8a 06		 mov	 al, BYTE PTR [esi]
  00097	88 01		 mov	 BYTE PTR [ecx], al
  00099	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0009c	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0009f	84 c0		 test	 al, al
  000a1	75 f2		 jne	 SHORT $LL1@gz_error

; 515  :     strcat(state->msg, ": ");

  000a3	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  000a6	49		 dec	 ecx
$LL13@gz_error:
  000a7	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000aa	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000ad	84 c0		 test	 al, al
  000af	75 f6		 jne	 SHORT $LL13@gz_error
  000b1	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
  000b7	66 89 01	 mov	 WORD PTR [ecx], ax
  000ba	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
  000bf	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 516  :     strcat(state->msg, msg);

  000c2	8b f3		 mov	 esi, ebx
$LL14@gz_error:
  000c4	8a 03		 mov	 al, BYTE PTR [ebx]
  000c6	43		 inc	 ebx
  000c7	84 c0		 test	 al, al
  000c9	75 f9		 jne	 SHORT $LL14@gz_error
  000cb	8b 7f 50	 mov	 edi, DWORD PTR [edi+80]
  000ce	2b de		 sub	 ebx, esi
  000d0	4f		 dec	 edi
$LL15@gz_error:
  000d1	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000d4	47		 inc	 edi
  000d5	84 c0		 test	 al, al
  000d7	75 f8		 jne	 SHORT $LL15@gz_error
  000d9	8b cb		 mov	 ecx, ebx
  000db	c1 e9 02	 shr	 ecx, 2
  000de	f3 a5		 rep movsd
  000e0	8b cb		 mov	 ecx, ebx
  000e2	83 e1 03	 and	 ecx, 3
  000e5	f3 a4		 rep movsb
  000e7	5e		 pop	 esi
$LN6@gz_error:
  000e8	5f		 pop	 edi
  000e9	5b		 pop	 ebx

; 517  :     return;
; 518  : }

  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzoffset64
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzoffset64 PROC					; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 393  :     z_off64_t offset;
; 394  :     gz_statep state;
; 395  : 
; 396  :     /* get internal structure and check integrity */
; 397  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN4@gzoffset64
$LN7@gzoffset64:

; 398  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 409  :     return offset;
; 410  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN4@gzoffset64:

; 399  :     state = (gz_statep)file;
; 400  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00018	74 07		 je	 SHORT $LN3@gzoffset64
  0001a	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0001f	75 ea		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 401  :         return -1;
; 402  : 
; 403  :     /* compute and return effective offset in file */
; 404  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00021	6a 01		 push	 1
  00023	6a 00		 push	 0
  00025	ff 76 04	 push	 DWORD PTR [esi+4]
  00028	e8 00 00 00 00	 call	 _lseek
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 405  :     if (offset == -1)

  00030	83 f8 ff	 cmp	 eax, -1
  00033	74 d6		 je	 SHORT $LN7@gzoffset64

; 406  :         return -1;
; 407  :     if (state->mode == GZ_READ)             /* reading */

  00035	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  0003b	75 03		 jne	 SHORT $LN5@gzoffset64

; 408  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0003d	2b 46 58	 sub	 eax, DWORD PTR [esi+88]
$LN5@gzoffset64:
  00040	5e		 pop	 esi

; 409  :     return offset;
; 410  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_gzoffset64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gztell64
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gztell64 PROC						; COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 366  :     gz_statep state;
; 367  : 
; 368  :     /* get internal structure and check integrity */
; 369  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 370  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 377  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN2@gztell64:

; 371  :     state = (gz_statep)file;
; 372  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00017	74 08		 je	 SHORT $LN1@gztell64
  00019	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H
  0001f	75 e9		 jne	 SHORT $LN7@gztell64
$LN1@gztell64:

; 373  :         return -1;
; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00021	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00025	74 0a		 je	 SHORT $LN5@gztell64
  00027	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0002a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002d	03 c1		 add	 eax, ecx

; 377  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN5@gztell64:

; 373  :         return -1;
; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00031	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00034	33 c9		 xor	 ecx, ecx
  00036	03 c1		 add	 eax, ecx

; 377  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_gztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzseek64
_TEXT	SEGMENT
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek64 PROC						; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 280  :     unsigned n;
; 281  :     z_off64_t ret;
; 282  :     gz_statep state;
; 283  : 
; 284  :     /* get internal structure and check integrity */
; 285  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN15@gzseek64
$LN25@gzseek64:

; 286  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 348  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN15@gzseek64:

; 287  :     state = (gz_statep)file;
; 288  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00019	74 08		 je	 SHORT $LN14@gzseek64
  0001b	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H
  00021	75 e8		 jne	 SHORT $LN25@gzseek64
$LN14@gzseek64:

; 289  :         return -1;
; 290  : 
; 291  :     /* check that there's no error */
; 292  :     if (state->err != Z_OK)

  00023	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00027	75 e2		 jne	 SHORT $LN25@gzseek64

; 293  :         return -1;
; 294  : 
; 295  :     /* can only seek from start or relative to current position */
; 296  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00029	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  0002c	57		 push	 edi
  0002d	85 c0		 test	 eax, eax
  0002f	74 17		 je	 SHORT $LN21@gzseek64
  00031	83 f8 01	 cmp	 eax, 1
  00034	0f 85 9d 00 00
	00		 jne	 $LN24@gzseek64

; 302  :     else if (state->seek)

  0003a	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0

; 303  :         offset += state->skip;

  0003e	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp]
  00041	74 0b		 je	 SHORT $LN9@gzseek64
  00043	03 7e 44	 add	 edi, DWORD PTR [esi+68]
  00046	eb 06		 jmp	 SHORT $LN9@gzseek64
$LN21@gzseek64:

; 297  :         return -1;
; 298  : 
; 299  :     /* normalize offset to a SEEK_CUR specification */
; 300  :     if (whence == SEEK_SET)
; 301  :         offset -= state->pos;

  00048	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp]
  0004b	2b 7e 0c	 sub	 edi, DWORD PTR [esi+12]
$LN9@gzseek64:

; 304  :     state->seek = 0;

  0004e	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0

; 305  : 
; 306  :     /* if within raw area while reading, just go there */
; 307  :     if (state->mode == GZ_READ && state->how == COPY &&
; 308  :         state->pos + offset >= state->raw) {

  00055	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  0005b	75 5b		 jne	 SHORT $LN8@gzseek64
  0005d	83 7e 34 01	 cmp	 DWORD PTR [esi+52], 1
  00061	75 55		 jne	 SHORT $LN8@gzseek64
  00063	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00066	03 c7		 add	 eax, edi
  00068	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0006b	7c 4b		 jl	 SHORT $LN8@gzseek64

; 309  :         ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);

  0006d	8b c7		 mov	 eax, edi
  0006f	2b 46 24	 sub	 eax, DWORD PTR [esi+36]
  00072	6a 01		 push	 1
  00074	50		 push	 eax
  00075	ff 76 04	 push	 DWORD PTR [esi+4]
  00078	e8 00 00 00 00	 call	 _lseek
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 310  :         if (ret == -1)

  00080	83 f8 ff	 cmp	 eax, -1
  00083	74 52		 je	 SHORT $LN24@gzseek64

; 311  :             return -1;
; 312  :         state->have = 0;
; 313  :         state->eof = 0;
; 314  :         state->seek = 0;
; 315  :         gz_error(state, Z_OK, NULL);

  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	56		 push	 esi
  0008a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00091	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00098	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0009f	e8 00 00 00 00	 call	 _gz_error
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  :         state->strm.avail_in = 0;
; 317  :         state->pos += offset;

  000a7	01 7e 0c	 add	 DWORD PTR [esi+12], edi

; 318  :         return state->pos;

  000aa	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000ad	5f		 pop	 edi
  000ae	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  000b5	5e		 pop	 esi

; 348  : }

  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN8@gzseek64:

; 319  :     }
; 320  : 
; 321  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 322  :     if (offset < 0) {

  000b8	85 ff		 test	 edi, edi
  000ba	79 22		 jns	 SHORT $LN3@gzseek64

; 323  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000bc	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  000c2	75 13		 jne	 SHORT $LN24@gzseek64

; 324  :             return -1;
; 325  :         offset += state->pos;

  000c4	03 7e 0c	 add	 edi, DWORD PTR [esi+12]

; 326  :         if (offset < 0)                     /* before start of file! */

  000c7	78 0e		 js	 SHORT $LN24@gzseek64

; 327  :             return -1;
; 328  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  000c9	56		 push	 esi
  000ca	e8 00 00 00 00	 call	 _gzrewind
  000cf	83 c4 04	 add	 esp, 4
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	75 07		 jne	 SHORT $LN3@gzseek64
$LN24@gzseek64:
  000d7	5f		 pop	 edi

; 329  :             return -1;

  000d8	83 c8 ff	 or	 eax, -1
  000db	5e		 pop	 esi

; 348  : }

  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
$LN3@gzseek64:

; 330  :     }
; 331  : 
; 332  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 333  :     if (state->mode == GZ_READ) {

  000de	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  000e4	75 1f		 jne	 SHORT $LN2@gzseek64

; 334  :         n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?
; 335  :             (unsigned)offset : state->have;

  000e6	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000e9	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000ee	77 06		 ja	 SHORT $LN19@gzseek64
  000f0	8b c8		 mov	 ecx, eax
  000f2	3b c7		 cmp	 eax, edi
  000f4	7e 02		 jle	 SHORT $LN20@gzseek64
$LN19@gzseek64:
  000f6	8b cf		 mov	 ecx, edi
$LN20@gzseek64:

; 336  :         state->have -= n;
; 337  :         state->next += n;

  000f8	01 4e 20	 add	 DWORD PTR [esi+32], ecx

; 338  :         state->pos += n;

  000fb	01 4e 0c	 add	 DWORD PTR [esi+12], ecx
  000fe	2b c1		 sub	 eax, ecx
  00100	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 339  :         offset -= n;

  00103	2b f9		 sub	 edi, ecx
$LN2@gzseek64:

; 340  :     }
; 341  : 
; 342  :     /* request skip (if not zero) */
; 343  :     if (offset) {

  00105	85 ff		 test	 edi, edi
  00107	74 0a		 je	 SHORT $LN1@gzseek64

; 344  :         state->seek = 1;

  00109	c7 46 48 01 00
	00 00		 mov	 DWORD PTR [esi+72], 1

; 345  :         state->skip = offset;

  00110	89 7e 44	 mov	 DWORD PTR [esi+68], edi
$LN1@gzseek64:

; 346  :     }
; 347  :     return state->pos + offset;

  00113	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00116	03 c7		 add	 eax, edi
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi

; 348  : }

  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_gzseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzopen64
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen64 PROC						; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  :     return gz_open(path, -1, mode);

  00003	ff 75 0c	 push	 DWORD PTR _mode$[ebp]
  00006	6a ff		 push	 -1
  00008	ff 75 08	 push	 DWORD PTR _path$[ebp]
  0000b	e8 00 00 00 00	 call	 _gz_open
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_gzopen64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzoffset
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzoffset PROC						; COMDAT

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 419  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
; 420  : }

  00003	5d		 pop	 ebp

; 416  :     z_off64_t ret;
; 417  : 
; 418  :     ret = gzoffset64(file);

  00004	e9 00 00 00 00	 jmp	 _gzoffset64
_gzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gztell
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gztell	PROC						; COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 386  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
; 387  : }

  00003	5d		 pop	 ebp

; 383  :     z_off64_t ret;
; 384  : 
; 385  :     ret = gztell64(file);

  00004	e9 00 00 00 00	 jmp	 _gztell64
_gztell	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzseek
_TEXT	SEGMENT
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek	PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 359  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
; 360  : }

  00003	5d		 pop	 ebp

; 356  :     z_off64_t ret;
; 357  : 
; 358  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00004	e9 00 00 00 00	 jmp	 _gzseek64
_gzseek	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzopen
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen	PROC						; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  :     return gz_open(path, -1, mode);

  00003	ff 75 0c	 push	 DWORD PTR _mode$[ebp]
  00006	6a ff		 push	 -1
  00008	ff 75 08	 push	 DWORD PTR _path$[ebp]
  0000b	e8 00 00 00 00	 call	 _gz_open
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_gzopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzclearerr
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclearerr PROC					; COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 464  :     gz_statep state;
; 465  : 
; 466  :     /* get internal structure and check integrity */
; 467  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 35		 je	 SHORT $LN4@gzclearerr

; 468  :         return;
; 469  :     state = (gz_statep)file;
; 470  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00012	74 17		 je	 SHORT $LN6@gzclearerr
  00014	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H
  0001a	75 23		 jne	 SHORT $LN4@gzclearerr

; 471  :         return;
; 472  : 
; 473  :     /* clear error and end-of-file */
; 474  :     if (state->mode == GZ_READ)
; 475  :         state->eof = 0;
; 476  :     gz_error(state, Z_OK, NULL);

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gz_error
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN6@gzclearerr:

; 471  :         return;
; 472  : 
; 473  :     /* clear error and end-of-file */
; 474  :     if (state->mode == GZ_READ)
; 475  :         state->eof = 0;
; 476  :     gz_error(state, Z_OK, NULL);

  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  00037	e8 00 00 00 00	 call	 _gz_error
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzclearerr:

; 477  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_gzclearerr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzerror
_TEXT	SEGMENT
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror PROC						; COMDAT

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 445  :     gz_statep state;
; 446  : 
; 447  :     /* get internal structure and check integrity */
; 448  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@gzerror
$LN8@gzerror:

; 449  :         return NULL;

  0000a	33 c0		 xor	 eax, eax

; 458  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@gzerror:

; 450  :     state = (gz_statep)file;
; 451  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00015	74 07		 je	 SHORT $LN2@gzerror
  00017	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0001c	75 ec		 jne	 SHORT $LN8@gzerror
$LN2@gzerror:

; 452  :         return NULL;
; 453  : 
; 454  :     /* return error information */
; 455  :     if (errnum != NULL)

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _errnum$[ebp]
  00021	85 d2		 test	 edx, edx
  00023	74 05		 je	 SHORT $LN1@gzerror

; 456  :         *errnum = state->err;

  00025	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00028	89 02		 mov	 DWORD PTR [edx], eax
$LN1@gzerror:

; 457  :     return state->msg == NULL ? "" : state->msg;

  0002a	8b 49 50	 mov	 ecx, DWORD PTR [ecx+80]
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00032	85 c9		 test	 ecx, ecx
  00034	0f 45 c1	 cmovne	 eax, ecx

; 458  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_gzerror ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzeof
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzeof	PROC						; COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 426  :     gz_statep state;
; 427  : 
; 428  :     /* get internal structure and check integrity */
; 429  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 23		 je	 SHORT $LN5@gzeof

; 430  :         return 0;
; 431  :     state = (gz_statep)file;
; 432  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00012	75 19		 jne	 SHORT $LN5@gzeof

; 433  :         return 0;
; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  00014	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00018	74 13		 je	 SHORT $LN5@gzeof
  0001a	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0001e	75 0d		 jne	 SHORT $LN5@gzeof
  00020	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00024	75 07		 jne	 SHORT $LN5@gzeof
  00026	b8 01 00 00 00	 mov	 eax, 1

; 438  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN5@gzeof:

; 433  :         return 0;
; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  0002d	33 c0		 xor	 eax, eax

; 438  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_gzeof	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzrewind
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzrewind PROC						; COMDAT

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 256  :     gz_statep state;
; 257  : 
; 258  :     /* get internal structure */
; 259  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 31		 je	 SHORT $LN2@gzrewind

; 260  :         return -1;
; 261  :     state = (gz_statep)file;
; 262  : 
; 263  :     /* check that we're reading and that there's no error */
; 264  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000b	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00011	75 29		 jne	 SHORT $LN2@gzrewind
  00013	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00017	75 23		 jne	 SHORT $LN2@gzrewind

; 266  : 
; 267  :     /* back up and start over */
; 268  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00019	6a 00		 push	 0
  0001b	ff 76 2c	 push	 DWORD PTR [esi+44]
  0001e	ff 76 04	 push	 DWORD PTR [esi+4]
  00021	e8 00 00 00 00	 call	 _lseek
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	83 f8 ff	 cmp	 eax, -1
  0002c	74 0e		 je	 SHORT $LN2@gzrewind

; 269  :         return -1;
; 270  :     gz_reset(state);

  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 _gz_reset
  00034	83 c4 04	 add	 esp, 4

; 271  :     return 0;

  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 272  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN2@gzrewind:

; 265  :         return -1;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5e		 pop	 esi

; 272  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_gzrewind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzbuffer
_TEXT	SEGMENT
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer PROC						; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :     gz_statep state;
; 233  : 
; 234  :     /* get internal structure and check integrity */
; 235  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN4@gzbuffer
$LN7@gzbuffer:

; 236  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 250  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN4@gzbuffer:

; 237  :     state = (gz_statep)file;
; 238  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00017	74 08		 je	 SHORT $LN3@gzbuffer
  00019	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H
  0001f	75 e9		 jne	 SHORT $LN7@gzbuffer
$LN3@gzbuffer:

; 239  :         return -1;
; 240  : 
; 241  :     /* make sure we haven't already allocated memory */
; 242  :     if (state->size != 0)

  00021	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00025	75 e3		 jne	 SHORT $LN7@gzbuffer

; 243  :         return -1;
; 244  : 
; 245  :     /* check and set requested size */
; 246  :     if (size == 0)

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 dc		 je	 SHORT $LN7@gzbuffer

; 247  :         return -1;
; 248  :     state->want = size;

  0002e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 249  :     return 0;

  00031	33 c0		 xor	 eax, eax

; 250  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_gzbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\gzlib.c
;	COMDAT _gzdopen
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen PROC						; COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 216  :     char *path;         /* identifier for error messages */
; 217  :     gzFile gz;
; 218  : 
; 219  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _fd$[ebp]
  00007	57		 push	 edi
  00008	83 fe ff	 cmp	 esi, -1
  0000b	74 37		 je	 SHORT $LN1@gzdopen
  0000d	6a 13		 push	 19			; 00000013H
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	8b f8		 mov	 edi, eax
  00016	83 c4 04	 add	 esp, 4
  00019	85 ff		 test	 edi, edi
  0001b	74 27		 je	 SHORT $LN1@gzdopen

; 221  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _sprintf

; 222  :     gz = gz_open(path, fd, mode);

  00029	ff 75 0c	 push	 DWORD PTR _mode$[ebp]
  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 _gz_open

; 223  :     free(path);

  00033	57		 push	 edi
  00034	8b f0		 mov	 esi, eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 224  :     return gz;

  0003e	8b c6		 mov	 eax, esi
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 225  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN1@gzdopen:
  00044	5f		 pop	 edi

; 220  :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	5e		 pop	 esi

; 225  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_gzdopen ENDP
_TEXT	ENDS
END
