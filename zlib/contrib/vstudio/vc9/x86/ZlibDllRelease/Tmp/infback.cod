; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	_inflateBack
PUBLIC	_inflateBackEnd
PUBLIC	_inflateBackInit_
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	_zcalloc:PROC
EXTRN	_zcfree:PROC
EXTRN	_inflate_table:PROC
EXTRN	_inflate_fast:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\infback.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  0000d	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 112  :     state->distcode = distfix;

  00014	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 113  :     state->distbits = 5;

  0001b	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 114  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\infback.c
;	COMDAT _inflateBackInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_ PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 ba 00 00
	00		 je	 $LN6@inflateBac
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 b1 00 00
	00		 jne	 $LN6@inflateBac
  00017	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 a7 00 00
	00		 jne	 $LN6@inflateBac

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00026	57		 push	 edi
  00027	85 f6		 test	 esi, esi
  00029	0f 84 8f 00 00
	00		 je	 $LN4@inflateBac
  0002f	8b 5d 10	 mov	 ebx, DWORD PTR _window$[ebp]
  00032	85 db		 test	 ebx, ebx
  00034	0f 84 84 00 00
	00		 je	 $LN4@inflateBac
  0003a	8b 7d 0c	 mov	 edi, DWORD PTR _windowBits$[ebp]
  0003d	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00040	83 f8 07	 cmp	 eax, 7
  00043	77 79		 ja	 SHORT $LN4@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00045	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00049	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00050	75 0e		 jne	 SHORT $LN3@inflateBac

; 45   :         strm->zalloc = zcalloc;

  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 46   :         strm->opaque = (voidpf)0;

  00059	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN3@inflateBac:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00060	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00064	75 07		 jne	 SHORT $LN2@inflateBac
  00066	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN2@inflateBac:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  0006d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00070	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00075	6a 01		 push	 1
  00077	ff 76 28	 push	 DWORD PTR [esi+40]
  0007a	ff d0		 call	 eax
  0007c	8b d0		 mov	 edx, eax
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  00081	85 d2		 test	 edx, edx
  00083	75 08		 jne	 SHORT $LN1@inflateBac
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0008a	5b		 pop	 ebx

; 61   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN1@inflateBac:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  0008d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 54   :     state->dmax = 32768U;
; 55   :     state->wbits = windowBits;
; 56   :     state->wsize = 1U << windowBits;

  00090	8b cf		 mov	 ecx, edi
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	d3 e0		 shl	 eax, cl
  00099	89 7a 24	 mov	 DWORD PTR [edx+36], edi
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 57   :     state->window = window;

  000a1	89 5a 34	 mov	 DWORD PTR [edx+52], ebx
  000a4	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [edx+20], 32768 ; 00008000H

; 58   :     state->wnext = 0;

  000ab	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 59   :     state->whave = 0;

  000b2	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 60   :     return Z_OK;

  000b9	33 c0		 xor	 eax, eax
  000bb	5b		 pop	 ebx

; 61   : }

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN4@inflateBac:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 42   :         return Z_STREAM_ERROR;

  000c0	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000c5	5b		 pop	 ebx

; 61   : }

  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN6@inflateBac:

; 39   :         return Z_VERSION_ERROR;

  000c8	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 61   : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\infback.c
;	COMDAT _inflateBackEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd PROC					; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 23		 je	 SHORT $LN1@inflateBac
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN1@inflateBac
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 15		 je	 SHORT $LN1@inflateBac

; 628  :     ZFREE(strm, strm->state);

  00019	50		 push	 eax
  0001a	ff 76 28	 push	 DWORD PTR [esi+40]
  0001d	ff d1		 call	 ecx
  0001f	83 c4 08	 add	 esp, 8

; 629  :     strm->state = Z_NULL;

  00022	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 632  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN1@inflateBac:

; 627  :         return Z_STREAM_ERROR;

  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	5e		 pop	 esi

; 632  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_inflateBackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\infback.c
;	COMDAT _inflateBack
_TEXT	SEGMENT
tv1750 = -40						; size = 4
tv1746 = -40						; size = 4
tv1745 = -40						; size = 4
_len$1$ = -36						; size = 4
_here$1$ = -36						; size = 4
tv1739 = -36						; size = 4
tv1738 = -36						; size = 4
tv1737 = -36						; size = 4
_copy$4$ = -32						; size = 4
_last$ = -32						; size = 4
_here$ = -32						; size = 4
_put$1$ = -28						; size = 4
_left$1$ = -24						; size = 4
$T1 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$5$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_next$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack PROC					; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 28	 sub	 esp, 40			; 00000028H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 3b 0e 00
	00		 je	 $LN346@inflateBac
  00011	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00014	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 2d 0e 00
	00		 je	 $LN346@inflateBac

; 266  :     state = (struct inflate_state FAR *)strm->state;
; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  0001f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00026	53		 push	 ebx

; 270  :     state->mode = TYPE;

  00027	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 271  :     state->last = 0;

  0002d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 272  :     state->whave = 0;

  00034	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 273  :     next = strm->next_in;

  0003b	8b 18		 mov	 ebx, DWORD PTR [eax]
  0003d	56		 push	 esi
  0003e	57		 push	 edi
  0003f	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00042	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00045	85 db		 test	 ebx, ebx
  00047	74 05		 je	 SHORT $LN350@inflateBac
  00049	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0004c	eb 02		 jmp	 SHORT $LN351@inflateBac
$LN350@inflateBac:
  0004e	33 f6		 xor	 esi, esi
$LN351@inflateBac:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;

  00050	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00053	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax

; 278  :     left = state->wsize;

  00056	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00059	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  0005c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005e	33 d2		 xor	 edx, edx
  00060	33 ff		 xor	 edi, edi
  00062	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00065	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00068	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0006b	83 f8 12	 cmp	 eax, 18			; 00000012H
  0006e	0f 87 3a 0d 00
	00		 ja	 $LN1@inflateBac
  00074	8b 5d f0	 mov	 ebx, DWORD PTR _next$5$[ebp]
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL345@inflateBac:
  00080	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN453@inflateBac[eax]
  00087	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN484@inflateBac[eax*4]
$LN341@inflateBac:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  0008e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00092	74 23		 je	 SHORT $LN336@inflateBac

; 286  :                 BYTEBITS();

  00094	8b cf		 mov	 ecx, edi
  00096	83 e1 07	 and	 ecx, 7
  00099	d3 ea		 shr	 edx, cl
  0009b	2b f9		 sub	 edi, ecx

; 287  :                 state->mode = DONE;

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000a0	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  000a3	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH

; 288  :                 break;

  000a9	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  000ac	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000af	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  000b2	e9 e9 0c 00 00	 jmp	 $LN402@inflateBac
$LN336@inflateBac:

; 289  :             }
; 290  :             NEEDBITS(3);

  000b7	83 ff 03	 cmp	 edi, 3
  000ba	73 41		 jae	 SHORT $LN335@inflateBac
  000bc	8d 64 24 00	 npad	 4
$LL333@inflateBac:
  000c0	85 f6		 test	 esi, esi
  000c2	75 1d		 jne	 SHORT $LN327@inflateBac
  000c4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  000c7	50		 push	 eax
  000c8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  000cb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  000ce	8b f0		 mov	 esi, eax
  000d0	83 c4 08	 add	 esp, 8
  000d3	85 f6		 test	 esi, esi
  000d5	0f 84 ec 0c 00
	00		 je	 $LN377@inflateBac
  000db	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  000de	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN327@inflateBac:
  000e1	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000e4	8b cf		 mov	 ecx, edi
  000e6	d3 e0		 shl	 eax, cl
  000e8	43		 inc	 ebx
  000e9	83 c7 08	 add	 edi, 8
  000ec	4e		 dec	 esi
  000ed	03 d0		 add	 edx, eax
  000ef	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000f2	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  000f5	83 ff 03	 cmp	 edi, 3
  000f8	72 c6		 jb	 SHORT $LL333@inflateBac
  000fa	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN335@inflateBac:

; 291  :             state->last = BITS(1);

  000fd	8b c2		 mov	 eax, edx
  000ff	83 e0 01	 and	 eax, 1

; 292  :             DROPBITS(1);

  00102	d1 ea		 shr	 edx, 1
  00104	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 293  :             switch (BITS(2)) {

  00107	8b c2		 mov	 eax, edx
  00109	83 e0 03	 and	 eax, 3
  0010c	83 f8 03	 cmp	 eax, 3
  0010f	77 38		 ja	 SHORT $LN314@inflateBac
  00111	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN485@inflateBac[eax*4]
$LN318@inflateBac:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  00118	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH

; 298  :                 break;

  0011e	eb 29		 jmp	 SHORT $LN314@inflateBac
$LN317@inflateBac:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 _fixedtables
  00126	83 c4 04	 add	 esp, 4

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00129	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 304  :                 break;

  0012f	eb 18		 jmp	 SHORT $LN314@inflateBac
$LN316@inflateBac:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  00131	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H

; 309  :                 break;

  00137	eb 10		 jmp	 SHORT $LN314@inflateBac
$LN315@inflateBac:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  00139	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0013c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 312  :                 state->mode = BAD;

  00143	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN314@inflateBac:

; 313  :             }
; 314  :             DROPBITS(2);
; 315  :             break;

  00149	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  0014c	c1 ea 02	 shr	 edx, 2
  0014f	83 ef 03	 sub	 edi, 3
  00152	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00155	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00158	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0015b	e9 40 0c 00 00	 jmp	 $LN402@inflateBac
$LN310@inflateBac:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  00160	8b cf		 mov	 ecx, edi
  00162	83 e1 07	 and	 ecx, 7
  00165	d3 ea		 shr	 edx, cl
  00167	2b f9		 sub	 edi, ecx
  00169	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0016c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 320  :             NEEDBITS(32);

  0016f	83 ff 20	 cmp	 edi, 32			; 00000020H
  00172	73 3d		 jae	 SHORT $LN306@inflateBac
$LL304@inflateBac:
  00174	85 f6		 test	 esi, esi
  00176	75 1d		 jne	 SHORT $LN298@inflateBac
  00178	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0017b	50		 push	 eax
  0017c	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0017f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00182	8b f0		 mov	 esi, eax
  00184	83 c4 08	 add	 esp, 8
  00187	85 f6		 test	 esi, esi
  00189	0f 84 38 0c 00
	00		 je	 $LN377@inflateBac
  0018f	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00192	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN298@inflateBac:
  00195	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00198	8b cf		 mov	 ecx, edi
  0019a	d3 e0		 shl	 eax, cl
  0019c	83 c7 08	 add	 edi, 8
  0019f	43		 inc	 ebx
  001a0	4e		 dec	 esi
  001a1	03 d0		 add	 edx, eax
  001a3	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001a6	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  001a9	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  001ac	83 ff 20	 cmp	 edi, 32			; 00000020H
  001af	72 c3		 jb	 SHORT $LL304@inflateBac
$LN306@inflateBac:

; 323  :                 state->mode = BAD;

  001b1	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001b4	8b c2		 mov	 eax, edx
  001b6	8b da		 mov	 ebx, edx
  001b8	f7 d0		 not	 eax
  001ba	81 e3 ff ff 00
	00		 and	 ebx, 65535		; 0000ffffH
  001c0	c1 e8 10	 shr	 eax, 16			; 00000010H
  001c3	3b d8		 cmp	 ebx, eax
  001c5	74 1b		 je	 SHORT $LN294@inflateBac

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  001c7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001ca	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 323  :                 state->mode = BAD;

  001d1	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 324  :                 break;

  001d7	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  001da	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  001dd	e9 be 0b 00 00	 jmp	 $LN402@inflateBac
$LN294@inflateBac:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;
; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  001e2	33 d2		 xor	 edx, edx
  001e4	33 ff		 xor	 edi, edi
  001e6	89 59 40	 mov	 DWORD PTR [ecx+64], ebx
  001e9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001ec	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  001ef	3b da		 cmp	 ebx, edx
  001f1	0f 84 8a 00 00
	00		 je	 $LN289@inflateBac
  001f7	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  001fa	8d 9b 00 00 00
	00		 npad	 6
$LL290@inflateBac:

; 333  :                 copy = state->length;

  00200	8b 59 40	 mov	 ebx, DWORD PTR [ecx+64]

; 334  :                 PULL();

  00203	85 f6		 test	 esi, esi
  00205	75 1d		 jne	 SHORT $LN287@inflateBac
  00207	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0020a	50		 push	 eax
  0020b	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0020e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00211	8b f0		 mov	 esi, eax
  00213	83 c4 08	 add	 esp, 8
  00216	85 f6		 test	 esi, esi
  00218	0f 84 a9 0b 00
	00		 je	 $LN377@inflateBac
  0021e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00221	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN287@inflateBac:

; 335  :                 ROOM();

  00224	85 c0		 test	 eax, eax
  00226	75 25		 jne	 SHORT $LN282@inflateBac
  00228	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0022b	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0022e	52		 push	 edx
  0022f	50		 push	 eax
  00230	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00233	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00236	89 55 e8	 mov	 DWORD PTR _left$1$[ebp], edx
  00239	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  0023c	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00242	85 c0		 test	 eax, eax
  00244	0f 85 95 0b 00
	00		 jne	 $LN380@inflateBac
  0024a	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN282@inflateBac:

; 336  :                 if (copy > have) copy = have;

  0024d	3b de		 cmp	 ebx, esi
  0024f	0f 47 de	 cmova	 ebx, esi

; 337  :                 if (copy > left) copy = left;

  00252	3b d8		 cmp	 ebx, eax
  00254	0f 47 d8	 cmova	 ebx, eax

; 338  :                 zmemcpy(put, next, copy);

  00257	8b 45 e4	 mov	 eax, DWORD PTR _put$1$[ebp]
  0025a	53		 push	 ebx
  0025b	ff 75 fc	 push	 DWORD PTR _next$[ebp]
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 _memcpy

; 339  :                 have -= copy;
; 340  :                 next += copy;
; 341  :                 left -= copy;

  00264	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]

; 342  :                 put += copy;
; 343  :                 state->length -= copy;

  00267	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0026a	01 5d fc	 add	 DWORD PTR _next$[ebp], ebx
  0026d	01 5d e4	 add	 DWORD PTR _put$1$[ebp], ebx
  00270	2b c3		 sub	 eax, ebx
  00272	83 c4 0c	 add	 esp, 12			; 0000000cH
  00275	2b f3		 sub	 esi, ebx
  00277	29 59 40	 sub	 DWORD PTR [ecx+64], ebx
  0027a	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  0027d	75 81		 jne	 SHORT $LL290@inflateBac
  0027f	8b d7		 mov	 edx, edi
$LN289@inflateBac:

; 344  :             }
; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  00281	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 347  :             break;

  00287	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  0028a	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0028d	e9 0e 0b 00 00	 jmp	 $LN402@inflateBac
$LN275@inflateBac:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  00292	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  00295	73 3d		 jae	 SHORT $LN274@inflateBac
$LL272@inflateBac:
  00297	85 f6		 test	 esi, esi
  00299	75 1d		 jne	 SHORT $LN266@inflateBac
  0029b	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0029e	50		 push	 eax
  0029f	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  002a2	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  002a5	8b f0		 mov	 esi, eax
  002a7	83 c4 08	 add	 esp, 8
  002aa	85 f6		 test	 esi, esi
  002ac	0f 84 15 0b 00
	00		 je	 $LN377@inflateBac
  002b2	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  002b5	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN266@inflateBac:
  002b8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  002bb	8b cf		 mov	 ecx, edi
  002bd	d3 e0		 shl	 eax, cl
  002bf	43		 inc	 ebx
  002c0	83 c7 08	 add	 edi, 8
  002c3	4e		 dec	 esi
  002c4	03 d0		 add	 edx, eax
  002c6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002c9	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  002cc	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  002cf	72 c6		 jb	 SHORT $LL272@inflateBac
  002d1	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN274@inflateBac:

; 352  :             state->nlen = BITS(5) + 257;

  002d4	8b c2		 mov	 eax, edx
  002d6	83 e0 1f	 and	 eax, 31			; 0000001fH
  002d9	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002de	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 353  :             DROPBITS(5);

  002e1	c1 ea 05	 shr	 edx, 5

; 354  :             state->ndist = BITS(5) + 1;

  002e4	8b c2		 mov	 eax, edx
  002e6	83 e0 1f	 and	 eax, 31			; 0000001fH
  002e9	40		 inc	 eax

; 355  :             DROPBITS(5);

  002ea	c1 ea 05	 shr	 edx, 5
  002ed	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 356  :             state->ncode = BITS(4) + 4;

  002f0	8b c2		 mov	 eax, edx
  002f2	83 e0 0f	 and	 eax, 15			; 0000000fH
  002f5	83 c0 04	 add	 eax, 4

; 357  :             DROPBITS(4);

  002f8	c1 ea 04	 shr	 edx, 4
  002fb	83 ef 0e	 sub	 edi, 14			; 0000000eH

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  002fe	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  00305	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  00308	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0030b	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0030e	0f 87 5d 05 00
	00		 ja	 $LN252@inflateBac
  00314	83 79 64 1e	 cmp	 DWORD PTR [ecx+100], 30	; 0000001eH
  00318	0f 87 53 05 00
	00		 ja	 $LN252@inflateBac

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  0031e	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 369  :             while (state->have < state->ncode) {

  00325	85 c0		 test	 eax, eax
  00327	76 7a		 jbe	 SHORT $LN359@inflateBac
  00329	8d a4 24 00 00
	00 00		 npad	 7
$LL251@inflateBac:

; 370  :                 NEEDBITS(3);

  00330	83 ff 03	 cmp	 edi, 3
  00333	73 3d		 jae	 SHORT $LN248@inflateBac
  00335	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
$LL246@inflateBac:
  00338	85 f6		 test	 esi, esi
  0033a	75 1d		 jne	 SHORT $LN240@inflateBac
  0033c	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0033f	50		 push	 eax
  00340	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00343	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00346	8b f0		 mov	 esi, eax
  00348	83 c4 08	 add	 esp, 8
  0034b	85 f6		 test	 esi, esi
  0034d	0f 84 74 0a 00
	00		 je	 $LN377@inflateBac
  00353	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00356	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN240@inflateBac:
  00359	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0035c	8b cf		 mov	 ecx, edi
  0035e	d3 e0		 shl	 eax, cl
  00360	43		 inc	 ebx
  00361	83 c7 08	 add	 edi, 8
  00364	4e		 dec	 esi
  00365	03 d0		 add	 edx, eax
  00367	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0036a	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  0036d	83 ff 03	 cmp	 edi, 3
  00370	72 c6		 jb	 SHORT $LL246@inflateBac
$LN248@inflateBac:

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00372	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00375	8b ca		 mov	 ecx, edx
  00377	8b 43 68	 mov	 eax, DWORD PTR [ebx+104]
  0037a	83 e1 07	 and	 ecx, 7
  0037d	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]

; 372  :                 DROPBITS(3);

  00385	c1 ea 03	 shr	 edx, 3
  00388	66 89 4c 43 70	 mov	 WORD PTR [ebx+eax*2+112], cx
  0038d	8b cb		 mov	 ecx, ebx
  0038f	83 ef 03	 sub	 edi, 3
  00392	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00395	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00398	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0039b	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0039e	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  003a1	72 8d		 jb	 SHORT $LL251@inflateBac
$LN359@inflateBac:

; 373  :             }
; 374  :             while (state->have < 19)

  003a3	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  003a7	73 22		 jae	 SHORT $LN232@inflateBac
  003a9	8d a4 24 00 00
	00 00		 npad	 7
$LL233@inflateBac:

; 375  :                 state->lens[order[state->have++]] = 0;

  003b0	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  003b3	33 d2		 xor	 edx, edx
  003b5	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]
  003bd	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  003c2	ff 41 68	 inc	 DWORD PTR [ecx+104]
  003c5	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  003c9	72 e5		 jb	 SHORT $LL233@inflateBac
$LN232@inflateBac:

; 376  :             state->next = state->codes;

  003cb	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  003d1	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]

; 377  :             state->lencode = (code const FAR *)(state->next);
; 378  :             state->lenbits = 7;
; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  003d4	8d 99 f0 02 00
	00		 lea	 ebx, DWORD PTR [ecx+752]
  003da	53		 push	 ebx
  003db	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  003de	89 02		 mov	 DWORD PTR [edx], eax
  003e0	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  003e3	50		 push	 eax
  003e4	52		 push	 edx
  003e5	83 c1 70	 add	 ecx, 112		; 00000070H
  003e8	6a 13		 push	 19			; 00000013H
  003ea	51		 push	 ecx
  003eb	6a 00		 push	 0
  003ed	89 45 d8	 mov	 DWORD PTR tv1750[ebp], eax
  003f0	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
  003f6	e8 00 00 00 00	 call	 _inflate_table

; 383  :                 state->mode = BAD;

  003fb	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003fe	83 c4 18	 add	 esp, 24			; 00000018H
  00401	85 c0		 test	 eax, eax
  00403	74 15		 je	 SHORT $LN231@inflateBac

; 381  :             if (ret) {
; 382  :                 strm->msg = (char *)"invalid code lengths set";

  00405	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00408	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 383  :                 state->mode = BAD;

  0040f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 384  :                 break;

  00415	e9 7d 09 00 00	 jmp	 $LN481@inflateBac
$LN231@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  0041a	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  0041d	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0
  00424	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00427	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0042a	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  0042d	0f 84 d0 02 00
	00		 je	 $LN229@inflateBac
$LL230@inflateBac:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  00433	8b 45 d8	 mov	 eax, DWORD PTR tv1750[ebp]
  00436	ba 01 00 00 00	 mov	 edx, 1
  0043b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00440	d3 e2		 shl	 edx, cl
  00442	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00445	4a		 dec	 edx
  00446	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  00449	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  0044c	8b c8		 mov	 ecx, eax
  0044e	c1 e9 08	 shr	 ecx, 8
  00451	0f b6 c9	 movzx	 ecx, cl
  00454	89 45 dc	 mov	 DWORD PTR _here$1$[ebp], eax
  00457	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  0045a	3b cf		 cmp	 ecx, edi
  0045c	76 60		 jbe	 SHORT $LN383@inflateBac
  0045e	8b ff		 npad	 2
$LL228@inflateBac:

; 394  :                     PULLBYTE();

  00460	85 f6		 test	 esi, esi
  00462	75 1a		 jne	 SHORT $LN221@inflateBac
  00464	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00467	50		 push	 eax
  00468	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0046b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0046e	8b f0		 mov	 esi, eax
  00470	83 c4 08	 add	 esp, 8
  00473	85 f6		 test	 esi, esi
  00475	0f 84 4c 09 00
	00		 je	 $LN377@inflateBac
  0047b	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
$LN221@inflateBac:
  0047e	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00481	8b cf		 mov	 ecx, edi
  00483	d3 e0		 shl	 eax, cl
  00485	43		 inc	 ebx
  00486	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00489	ba 01 00 00 00	 mov	 edx, 1
  0048e	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00491	8b 45 d8	 mov	 eax, DWORD PTR tv1750[ebp]
  00494	83 c7 08	 add	 edi, 8
  00497	8b 08		 mov	 ecx, DWORD PTR [eax]
  00499	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0049c	d3 e2		 shl	 edx, cl
  0049e	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  004a1	4e		 dec	 esi
  004a2	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  004a5	4a		 dec	 edx
  004a6	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  004a9	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  004ac	8b c8		 mov	 ecx, eax
  004ae	c1 e9 08	 shr	 ecx, 8
  004b1	0f b6 c9	 movzx	 ecx, cl
  004b4	89 45 dc	 mov	 DWORD PTR _here$1$[ebp], eax
  004b7	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  004ba	3b cf		 cmp	 ecx, edi
  004bc	77 a2		 ja	 SHORT $LL228@inflateBac
$LN383@inflateBac:
  004be	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 395  :                 }
; 396  :                 if (here.val < 16) {

  004c1	8b c8		 mov	 ecx, eax
  004c3	c1 e9 10	 shr	 ecx, 16			; 00000010H
  004c6	83 f9 10	 cmp	 ecx, 16			; 00000010H
  004c9	73 78		 jae	 SHORT $LN217@inflateBac

; 397  :                     NEEDBITS(here.bits);

  004cb	8b c8		 mov	 ecx, eax
  004cd	c1 e9 08	 shr	 ecx, 8
  004d0	0f b6 c9	 movzx	 ecx, cl
  004d3	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
  004d6	3b f9		 cmp	 edi, ecx
  004d8	73 43		 jae	 SHORT $LN215@inflateBac
  004da	8d 9b 00 00 00
	00		 npad	 6
$LL213@inflateBac:
  004e0	85 f6		 test	 esi, esi
  004e2	75 1d		 jne	 SHORT $LN207@inflateBac
  004e4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  004e7	50		 push	 eax
  004e8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  004eb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  004ee	8b f0		 mov	 esi, eax
  004f0	83 c4 08	 add	 esp, 8
  004f3	85 f6		 test	 esi, esi
  004f5	0f 84 cc 08 00
	00		 je	 $LN377@inflateBac
  004fb	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  004fe	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN207@inflateBac:
  00501	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00504	8b cf		 mov	 ecx, edi
  00506	d3 e0		 shl	 eax, cl
  00508	43		 inc	 ebx
  00509	83 c7 08	 add	 edi, 8
  0050c	4e		 dec	 esi
  0050d	03 d0		 add	 edx, eax
  0050f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00512	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00515	3b 7d ec	 cmp	 edi, DWORD PTR $T1[ebp]
  00518	72 c6		 jb	 SHORT $LL213@inflateBac
  0051a	8b 45 dc	 mov	 eax, DWORD PTR _here$1$[ebp]
$LN215@inflateBac:

; 398  :                     DROPBITS(here.bits);

  0051d	0f b6 cc	 movzx	 ecx, ah

; 399  :                     state->lens[state->have++] = here.val;

  00520	66 8b 45 e2	 mov	 ax, WORD PTR _here$[ebp+2]
  00524	d3 ea		 shr	 edx, cl
  00526	2b f9		 sub	 edi, ecx
  00528	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  0052b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0052e	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00531	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  00534	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  00539	8b ca		 mov	 ecx, edx
  0053b	ff 41 68	 inc	 DWORD PTR [ecx+104]

; 400  :                 }
; 401  :                 else {

  0053e	e9 ab 01 00 00	 jmp	 $LN482@inflateBac
$LN217@inflateBac:

; 402  :                     if (here.val == 16) {

  00543	66 8b 4d e2	 mov	 cx, WORD PTR _here$[ebp+2]
  00547	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  0054b	0f 85 87 00 00
	00		 jne	 $LN199@inflateBac

; 403  :                         NEEDBITS(here.bits + 2);

  00551	0f b6 cc	 movzx	 ecx, ah
  00554	89 4d dc	 mov	 DWORD PTR tv1739[ebp], ecx
  00557	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  0055a	3b f8		 cmp	 edi, eax
  0055c	73 44		 jae	 SHORT $LN197@inflateBac
  0055e	8b ff		 npad	 2
$LL195@inflateBac:
  00560	85 f6		 test	 esi, esi
  00562	75 1d		 jne	 SHORT $LN189@inflateBac
  00564	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00567	50		 push	 eax
  00568	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0056b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0056e	8b f0		 mov	 esi, eax
  00570	83 c4 08	 add	 esp, 8
  00573	85 f6		 test	 esi, esi
  00575	0f 84 4c 08 00
	00		 je	 $LN377@inflateBac
  0057b	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  0057e	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN189@inflateBac:
  00581	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00584	8b cf		 mov	 ecx, edi
  00586	d3 e0		 shl	 eax, cl
  00588	8b 4d dc	 mov	 ecx, DWORD PTR tv1739[ebp]
  0058b	43		 inc	 ebx
  0058c	83 c7 08	 add	 edi, 8
  0058f	03 d0		 add	 edx, eax
  00591	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00594	4e		 dec	 esi
  00595	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00598	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0059b	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  0059e	3b f8		 cmp	 edi, eax
  005a0	72 be		 jb	 SHORT $LL195@inflateBac
$LN197@inflateBac:

; 404  :                         DROPBITS(here.bits);

  005a2	d3 ea		 shr	 edx, cl
  005a4	2b f9		 sub	 edi, ecx

; 405  :                         if (state->have == 0) {

  005a6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005a9	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  005ac	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  005af	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  005b2	85 c0		 test	 eax, eax
  005b4	0f 84 71 01 00
	00		 je	 $LN389@inflateBac

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  005ba	0f b7 44 41 6e	 movzx	 eax, WORD PTR [ecx+eax*2+110]
  005bf	89 45 dc	 mov	 DWORD PTR _len$1$[ebp], eax

; 411  :                         copy = 3 + BITS(2);

  005c2	8b c2		 mov	 eax, edx
  005c4	83 e0 03	 and	 eax, 3
  005c7	83 c0 03	 add	 eax, 3

; 412  :                         DROPBITS(2);

  005ca	c1 ea 02	 shr	 edx, 2
  005cd	89 45 e0	 mov	 DWORD PTR _copy$4$[ebp], eax
  005d0	83 ef 02	 sub	 edi, 2

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  005d3	e9 e0 00 00 00	 jmp	 $LN479@inflateBac
$LN199@inflateBac:
  005d8	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  005dc	0f b6 cc	 movzx	 ecx, ah
  005df	75 68		 jne	 SHORT $LN156@inflateBac

; 415  :                         NEEDBITS(here.bits + 3);

  005e1	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  005e4	89 4d dc	 mov	 DWORD PTR tv1738[ebp], ecx
  005e7	3b f8		 cmp	 edi, eax
  005e9	73 47		 jae	 SHORT $LN175@inflateBac
  005eb	eb 03 8d 49 00	 npad	 5
$LL173@inflateBac:
  005f0	85 f6		 test	 esi, esi
  005f2	75 1d		 jne	 SHORT $LN167@inflateBac
  005f4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  005f7	50		 push	 eax
  005f8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  005fb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  005fe	8b f0		 mov	 esi, eax
  00600	83 c4 08	 add	 esp, 8
  00603	85 f6		 test	 esi, esi
  00605	0f 84 bc 07 00
	00		 je	 $LN377@inflateBac
  0060b	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  0060e	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN167@inflateBac:
  00611	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00614	8b cf		 mov	 ecx, edi
  00616	d3 e0		 shl	 eax, cl
  00618	8b 4d dc	 mov	 ecx, DWORD PTR tv1738[ebp]
  0061b	43		 inc	 ebx
  0061c	83 c7 08	 add	 edi, 8
  0061f	03 d0		 add	 edx, eax
  00621	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00624	4e		 dec	 esi
  00625	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00628	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0062b	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  0062e	3b f8		 cmp	 edi, eax
  00630	72 be		 jb	 SHORT $LL173@inflateBac
$LN175@inflateBac:

; 416  :                         DROPBITS(here.bits);

  00632	d3 ea		 shr	 edx, cl

; 417  :                         len = 0;
; 418  :                         copy = 3 + BITS(3);

  00634	8b c2		 mov	 eax, edx
  00636	83 e0 07	 and	 eax, 7
  00639	83 c0 03	 add	 eax, 3
  0063c	89 45 e0	 mov	 DWORD PTR _copy$4$[ebp], eax

; 419  :                         DROPBITS(3);

  0063f	c1 ea 03	 shr	 edx, 3
  00642	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 420  :                     }
; 421  :                     else {

  00647	eb 61		 jmp	 SHORT $LN480@inflateBac
$LN156@inflateBac:

; 422  :                         NEEDBITS(here.bits + 7);

  00649	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  0064c	89 4d dc	 mov	 DWORD PTR tv1737[ebp], ecx
  0064f	3b f8		 cmp	 edi, eax
  00651	73 42		 jae	 SHORT $LN155@inflateBac
$LL153@inflateBac:
  00653	85 f6		 test	 esi, esi
  00655	75 1d		 jne	 SHORT $LN147@inflateBac
  00657	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0065a	50		 push	 eax
  0065b	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0065e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00661	8b f0		 mov	 esi, eax
  00663	83 c4 08	 add	 esp, 8
  00666	85 f6		 test	 esi, esi
  00668	0f 84 59 07 00
	00		 je	 $LN377@inflateBac
  0066e	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00671	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN147@inflateBac:
  00674	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00677	8b cf		 mov	 ecx, edi
  00679	d3 e0		 shl	 eax, cl
  0067b	8b 4d dc	 mov	 ecx, DWORD PTR tv1737[ebp]
  0067e	43		 inc	 ebx
  0067f	83 c7 08	 add	 edi, 8
  00682	03 d0		 add	 edx, eax
  00684	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00687	4e		 dec	 esi
  00688	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0068b	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  0068e	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00691	3b f8		 cmp	 edi, eax
  00693	72 be		 jb	 SHORT $LL153@inflateBac
$LN155@inflateBac:

; 423  :                         DROPBITS(here.bits);

  00695	d3 ea		 shr	 edx, cl

; 424  :                         len = 0;
; 425  :                         copy = 11 + BITS(7);

  00697	8b c2		 mov	 eax, edx
  00699	83 e0 7f	 and	 eax, 127		; 0000007fH
  0069c	83 c0 0b	 add	 eax, 11			; 0000000bH
  0069f	89 45 e0	 mov	 DWORD PTR _copy$4$[ebp], eax

; 426  :                         DROPBITS(7);

  006a2	c1 ea 07	 shr	 edx, 7
  006a5	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN480@inflateBac:
  006aa	2b c1		 sub	 eax, ecx
  006ac	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006af	03 f8		 add	 edi, eax
  006b1	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _len$1$[ebp], 0
$LN479@inflateBac:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  006b8	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  006bb	8b 49 64	 mov	 ecx, DWORD PTR [ecx+100]
  006be	03 48 60	 add	 ecx, DWORD PTR [eax+96]
  006c1	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  006c4	03 45 e0	 add	 eax, DWORD PTR _copy$4$[ebp]
  006c7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  006ca	3b c1		 cmp	 eax, ecx
  006cc	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006cf	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  006d2	77 57		 ja	 SHORT $LN389@inflateBac

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  006d4	8b 55 e0	 mov	 edx, DWORD PTR _copy$4$[ebp]
  006d7	85 d2		 test	 edx, edx
  006d9	74 19		 je	 SHORT $LN416@inflateBac
  006db	8b 5d dc	 mov	 ebx, DWORD PTR _len$1$[ebp]
  006de	8b ff		 npad	 2
$LL136@inflateBac:

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  006e0	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  006e3	66 89 5c 41 70	 mov	 WORD PTR [ecx+eax*2+112], bx
  006e8	ff 41 68	 inc	 DWORD PTR [ecx+104]
  006eb	4a		 dec	 edx
  006ec	75 f2		 jne	 SHORT $LL136@inflateBac
$LN482@inflateBac:

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  006ee	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  006f1	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN416@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  006f4	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  006f7	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  006fa	39 41 68	 cmp	 DWORD PTR [ecx+104], eax
  006fd	0f 82 30 fd ff
	ff		 jb	 $LL230@inflateBac
$LN229@inflateBac:

; 435  :                 }
; 436  :             }
; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00703	83 39 1d	 cmp	 DWORD PTR [ecx], 29	; 0000001dH
  00706	0f 84 91 06 00
	00		 je	 $LN469@inflateBac

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  0070c	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00714	75 30		 jne	 SHORT $LN133@inflateBac

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00716	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00719	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 444  :                 state->mode = BAD;

  00720	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 445  :                 break;

  00726	e9 6c 06 00 00	 jmp	 $LN481@inflateBac
$LN389@inflateBac:

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  0072b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0072e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 407  :                             state->mode = BAD;

  00735	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 408  :                             break;

  0073b	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  0073e	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00741	e9 5a 06 00 00	 jmp	 $LN402@inflateBac
$LN133@inflateBac:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;

  00746	8d 59 6c	 lea	 ebx, DWORD PTR [ecx+108]
  00749	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  0074f	89 03		 mov	 DWORD PTR [ebx], eax

; 452  :             state->lencode = (code const FAR *)(state->next);

  00751	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 453  :             state->lenbits = 9;

  00754	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]

; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  00757	8d 91 f0 02 00
	00		 lea	 edx, DWORD PTR [ecx+752]
  0075d	52		 push	 edx
  0075e	50		 push	 eax
  0075f	53		 push	 ebx
  00760	ff 71 60	 push	 DWORD PTR [ecx+96]
  00763	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  00769	8d 41 70	 lea	 eax, DWORD PTR [ecx+112]
  0076c	50		 push	 eax
  0076d	6a 01		 push	 1
  0076f	e8 00 00 00 00	 call	 _inflate_table

; 458  :                 state->mode = BAD;

  00774	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00777	83 c4 18	 add	 esp, 24			; 00000018H
  0077a	85 c0		 test	 eax, eax
  0077c	74 15		 je	 SHORT $LN132@inflateBac

; 456  :             if (ret) {
; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  0077e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00781	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 458  :                 state->mode = BAD;

  00788	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 459  :                 break;

  0078e	e9 04 06 00 00	 jmp	 $LN481@inflateBac
$LN132@inflateBac:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  00793	8b 03		 mov	 eax, DWORD PTR [ebx]
  00795	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 462  :             state->distbits = 6;

  00798	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]

; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  0079b	8d 91 f0 02 00
	00		 lea	 edx, DWORD PTR [ecx+752]
  007a1	52		 push	 edx
  007a2	50		 push	 eax
  007a3	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  007a9	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  007ac	53		 push	 ebx
  007ad	ff 71 64	 push	 DWORD PTR [ecx+100]
  007b0	83 c0 38	 add	 eax, 56			; 00000038H
  007b3	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  007b6	50		 push	 eax
  007b7	6a 02		 push	 2
  007b9	e8 00 00 00 00	 call	 _inflate_table

; 467  :                 state->mode = BAD;

  007be	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 468  :                 break;

  007c1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  007c4	83 c4 18	 add	 esp, 24			; 00000018H
  007c7	85 c0		 test	 eax, eax
  007c9	74 1b		 je	 SHORT $LN131@inflateBac

; 465  :             if (ret) {
; 466  :                 strm->msg = (char *)"invalid distances set";

  007cb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  007ce	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 467  :                 state->mode = BAD;

  007d5	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 468  :                 break;

  007db	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  007de	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  007e1	e9 ba 05 00 00	 jmp	 $LN402@inflateBac
$LN131@inflateBac:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  007e6	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  007ec	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  007ef	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN130@inflateBac:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  007f2	83 fe 06	 cmp	 esi, 6
  007f5	0f 82 91 00 00
	00		 jb	 $LN367@inflateBac
  007fb	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00802	0f 82 84 00 00
	00		 jb	 $LN367@inflateBac

; 476  :                 RESTORE();

  00808	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0080b	8b 45 e4	 mov	 eax, DWORD PTR _put$1$[ebp]
  0080e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00811	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  00814	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00817	8b c1		 mov	 eax, ecx
  00819	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0081c	89 18		 mov	 DWORD PTR [eax], ebx
  0081e	8b d8		 mov	 ebx, eax
  00820	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00823	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 477  :                 if (state->whave < state->wsize)

  00826	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00829	89 79 3c	 mov	 DWORD PTR [ecx+60], edi
  0082c	39 51 2c	 cmp	 DWORD PTR [ecx+44], edx
  0082f	73 08		 jae	 SHORT $LN125@inflateBac

; 478  :                     state->whave = state->wsize - left;

  00831	8b c2		 mov	 eax, edx
  00833	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  00836	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN125@inflateBac:

; 479  :                 inflate_fast(strm, state->wsize);

  00839	52		 push	 edx
  0083a	53		 push	 ebx
  0083b	e8 00 00 00 00	 call	 _inflate_fast

; 480  :                 LOAD();

  00840	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00843	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00846	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00849	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0084c	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0084e	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  00851	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00854	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00857	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0085a	8b 79 3c	 mov	 edi, DWORD PTR [ecx+60]
  0085d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00860	83 c4 08	 add	 esp, 8
  00863	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00866	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00869	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi

; 481  :                 break;

  0086c	e9 2f 05 00 00	 jmp	 $LN402@inflateBac
$LN252@inflateBac:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  00871	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00874	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 361  :                 state->mode = BAD;

  0087b	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 362  :                 break;

  00881	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00884	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00887	e9 14 05 00 00	 jmp	 $LN402@inflateBac
$LN367@inflateBac:

; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  0088c	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0088f	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00892	ba 01 00 00 00	 mov	 edx, 1
  00897	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0089a	d3 e2		 shl	 edx, cl
  0089c	4a		 dec	 edx
  0089d	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  008a0	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  008a3	8b c8		 mov	 ecx, eax
  008a5	c1 e9 08	 shr	 ecx, 8
  008a8	0f b6 c9	 movzx	 ecx, cl
  008ab	3b cf		 cmp	 ecx, edi
  008ad	76 5a		 jbe	 SHORT $LN391@inflateBac
  008af	90		 npad	 1
$LL121@inflateBac:

; 488  :                 PULLBYTE();

  008b0	85 f6		 test	 esi, esi
  008b2	75 1a		 jne	 SHORT $LN114@inflateBac
  008b4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  008b7	50		 push	 eax
  008b8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  008bb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  008be	8b f0		 mov	 esi, eax
  008c0	83 c4 08	 add	 esp, 8
  008c3	85 f6		 test	 esi, esi
  008c5	0f 84 fc 04 00
	00		 je	 $LN377@inflateBac
  008cb	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
$LN114@inflateBac:
  008ce	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  008d1	8b cf		 mov	 ecx, edi
  008d3	d3 e0		 shl	 eax, cl
  008d5	43		 inc	 ebx
  008d6	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  008d9	ba 01 00 00 00	 mov	 edx, 1
  008de	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  008e1	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  008e4	83 c7 08	 add	 edi, 8
  008e7	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  008ea	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  008ed	d3 e2		 shl	 edx, cl
  008ef	4e		 dec	 esi
  008f0	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  008f3	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  008f6	4a		 dec	 edx
  008f7	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  008fa	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  008fd	8b c8		 mov	 ecx, eax
  008ff	c1 e9 08	 shr	 ecx, 8
  00902	0f b6 c9	 movzx	 ecx, cl
  00905	3b cf		 cmp	 ecx, edi
  00907	77 a7		 ja	 SHORT $LL121@inflateBac
$LN391@inflateBac:

; 489  :             }
; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  00909	84 c0		 test	 al, al
  0090b	0f 84 d3 00 00
	00		 je	 $LN472@inflateBac
  00911	a8 f0		 test	 al, 240			; 000000f0H
  00913	0f 85 cb 00 00
	00		 jne	 $LN472@inflateBac

; 491  :                 last = here;
; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  00919	8b c8		 mov	 ecx, eax
  0091b	c1 e9 08	 shr	 ecx, 8
  0091e	0f b6 f9	 movzx	 edi, cl
  00921	89 4d d8	 mov	 DWORD PTR tv1746[ebp], ecx
  00924	0f b6 c8	 movzx	 ecx, al
  00927	03 cf		 add	 ecx, edi
  00929	bb 01 00 00 00	 mov	 ebx, 1
  0092e	d3 e3		 shl	 ebx, cl
  00930	8b cf		 mov	 ecx, edi
  00932	8b d0		 mov	 edx, eax
  00934	c1 e8 10	 shr	 eax, 16			; 00000010H
  00937	4b		 dec	 ebx
  00938	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  0093b	89 55 e0	 mov	 DWORD PTR _last$[ebp], edx
  0093e	d3 eb		 shr	 ebx, cl
  00940	03 d8		 add	 ebx, eax
  00942	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00945	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00948	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0094b	8b c8		 mov	 ecx, eax
  0094d	c1 e9 08	 shr	 ecx, 8
  00950	0f b6 f9	 movzx	 edi, cl
  00953	8b 4d d8	 mov	 ecx, DWORD PTR tv1746[ebp]
  00956	0f b6 c9	 movzx	 ecx, cl
  00959	03 f9		 add	 edi, ecx
  0095b	3b 7d ec	 cmp	 edi, DWORD PTR _bits$1$[ebp]
  0095e	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00961	76 75		 jbe	 SHORT $LN98@inflateBac
$LL109@inflateBac:

; 496  :                     PULLBYTE();

  00963	85 f6		 test	 esi, esi
  00965	75 1f		 jne	 SHORT $LN466@inflateBac
  00967	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0096a	50		 push	 eax
  0096b	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0096e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00971	8b f0		 mov	 esi, eax
  00973	83 c4 08	 add	 esp, 8
  00976	85 f6		 test	 esi, esi
  00978	0f 84 49 04 00
	00		 je	 $LN377@inflateBac
  0097e	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00981	8b 55 e0	 mov	 edx, DWORD PTR _last$[ebp]
  00984	eb 03		 jmp	 SHORT $LN102@inflateBac
$LN466@inflateBac:
  00986	8b 5d f0	 mov	 ebx, DWORD PTR _next$5$[ebp]
$LN102@inflateBac:
  00989	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0098c	8b cf		 mov	 ecx, edi
  0098e	d3 e0		 shl	 eax, cl
  00990	83 c7 08	 add	 edi, 8
  00993	43		 inc	 ebx
  00994	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00997	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  0099a	0f b7 45 e2	 movzx	 eax, WORD PTR _last$[ebp+2]
  0099e	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  009a1	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  009a4	0f b6 de	 movzx	 ebx, dh
  009a7	0f b6 ca	 movzx	 ecx, dl
  009aa	03 cb		 add	 ecx, ebx
  009ac	bf 01 00 00 00	 mov	 edi, 1
  009b1	d3 e7		 shl	 edi, cl
  009b3	8b cb		 mov	 ecx, ebx
  009b5	4e		 dec	 esi
  009b6	4f		 dec	 edi
  009b7	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  009ba	d3 ef		 shr	 edi, cl
  009bc	03 f8		 add	 edi, eax
  009be	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  009c1	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  009c4	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  009c7	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  009ca	8b c8		 mov	 ecx, eax
  009cc	c1 e9 08	 shr	 ecx, 8
  009cf	0f b6 c9	 movzx	 ecx, cl
  009d2	03 cb		 add	 ecx, ebx
  009d4	3b cf		 cmp	 ecx, edi
  009d6	77 8b		 ja	 SHORT $LL109@inflateBac
$LN98@inflateBac:

; 497  :                 }
; 498  :                 DROPBITS(last.bits);

  009d8	0f b6 ce	 movzx	 ecx, dh
  009db	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  009de	d3 ea		 shr	 edx, cl
  009e0	2b f9		 sub	 edi, ecx
  009e2	eb 03		 jmp	 SHORT $LN96@inflateBac
$LN472@inflateBac:
  009e4	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN96@inflateBac:

; 499  :             }
; 500  :             DROPBITS(here.bits);
; 501  :             state->length = (unsigned)here.val;

  009e7	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  009ea	8b c8		 mov	 ecx, eax
  009ec	c1 e9 08	 shr	 ecx, 8
  009ef	0f b6 c9	 movzx	 ecx, cl
  009f2	d3 ea		 shr	 edx, cl
  009f4	2b f9		 sub	 edi, ecx
  009f6	8b c8		 mov	 ecx, eax
  009f8	c1 e9 10	 shr	 ecx, 16			; 00000010H
  009fb	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  009fe	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00a01	89 4b 40	 mov	 DWORD PTR [ebx+64], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  00a04	84 c0		 test	 al, al
  00a06	75 4d		 jne	 SHORT $LN92@inflateBac

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  00a08	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  00a0c	75 25		 jne	 SHORT $LN90@inflateBac
  00a0e	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00a11	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00a14	51		 push	 ecx
  00a15	50		 push	 eax
  00a16	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00a19	89 45 e4	 mov	 DWORD PTR _put$1$[ebp], eax
  00a1c	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00a1f	89 4b 2c	 mov	 DWORD PTR [ebx+44], ecx
  00a22	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00a25	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a28	85 c0		 test	 eax, eax
  00a2a	0f 85 af 03 00
	00		 jne	 $LN380@inflateBac
  00a30	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN90@inflateBac:

; 509  :                 *put++ = (unsigned char)(state->length);

  00a33	8b cb		 mov	 ecx, ebx
  00a35	8b 5d e4	 mov	 ebx, DWORD PTR _put$1$[ebp]
  00a38	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  00a3b	88 03		 mov	 BYTE PTR [ebx], al
  00a3d	43		 inc	 ebx

; 510  :                 left--;

  00a3e	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  00a41	89 5d e4	 mov	 DWORD PTR _put$1$[ebp], ebx

; 511  :                 state->mode = LEN;

  00a44	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 512  :                 break;

  00a4a	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00a4d	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00a50	e9 4b 03 00 00	 jmp	 $LN402@inflateBac
$LN92@inflateBac:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  00a55	a8 20		 test	 al, 32			; 00000020H
  00a57	74 13		 je	 SHORT $LN86@inflateBac

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  00a59	8b cb		 mov	 ecx, ebx
  00a5b	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 519  :                 break;

  00a61	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00a64	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00a67	e9 34 03 00 00	 jmp	 $LN402@inflateBac
$LN86@inflateBac:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  00a6c	a8 40		 test	 al, 64			; 00000040H
  00a6e	74 1d		 je	 SHORT $LN85@inflateBac

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  00a70	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 525  :                 state->mode = BAD;

  00a73	8b cb		 mov	 ecx, ebx
  00a75	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00a7c	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 526  :                 break;

  00a82	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00a85	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00a88	e9 13 03 00 00	 jmp	 $LN402@inflateBac
$LN85@inflateBac:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  00a8d	0f b6 c0	 movzx	 eax, al
  00a90	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a93	89 43 48	 mov	 DWORD PTR [ebx+72], eax

; 531  :             if (state->extra != 0) {

  00a96	74 5f		 je	 SHORT $LN68@inflateBac

; 532  :                 NEEDBITS(state->extra);

  00a98	3b f8		 cmp	 edi, eax
  00a9a	73 41		 jae	 SHORT $LN82@inflateBac
  00a9c	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00a9f	90		 npad	 1
$LL80@inflateBac:
  00aa0	85 f6		 test	 esi, esi
  00aa2	75 1d		 jne	 SHORT $LN74@inflateBac
  00aa4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00aa7	50		 push	 eax
  00aa8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00aab	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00aae	8b f0		 mov	 esi, eax
  00ab0	83 c4 08	 add	 esp, 8
  00ab3	85 f6		 test	 esi, esi
  00ab5	0f 84 0c 03 00
	00		 je	 $LN377@inflateBac
  00abb	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00abe	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN74@inflateBac:
  00ac1	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00ac4	8b cf		 mov	 ecx, edi
  00ac6	d3 e0		 shl	 eax, cl
  00ac8	83 c7 08	 add	 edi, 8
  00acb	4e		 dec	 esi
  00acc	03 d0		 add	 edx, eax
  00ace	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00ad1	40		 inc	 eax
  00ad2	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00ad5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ad8	3b 7b 48	 cmp	 edi, DWORD PTR [ebx+72]
  00adb	72 c3		 jb	 SHORT $LL80@inflateBac
$LN82@inflateBac:

; 533  :                 state->length += BITS(state->extra);

  00add	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00ae0	b8 01 00 00 00	 mov	 eax, 1
  00ae5	d3 e0		 shl	 eax, cl
  00ae7	48		 dec	 eax
  00ae8	23 c2		 and	 eax, edx
  00aea	01 43 40	 add	 DWORD PTR [ebx+64], eax

; 534  :                 DROPBITS(state->extra);

  00aed	d3 ea		 shr	 edx, cl
  00aef	2b f9		 sub	 edi, ecx
  00af1	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00af4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN68@inflateBac:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  00af7	8b 4b 58	 mov	 ecx, DWORD PTR [ebx+88]
  00afa	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00afd	8b 5d f8	 mov	 ebx, DWORD PTR _hold$1$[ebp]
  00b00	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00b03	ba 01 00 00 00	 mov	 edx, 1
  00b08	d3 e2		 shl	 edx, cl
  00b0a	4a		 dec	 edx
  00b0b	23 d3		 and	 edx, ebx
  00b0d	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  00b10	8b c8		 mov	 ecx, eax
  00b12	c1 e9 08	 shr	 ecx, 8
  00b15	0f b6 c9	 movzx	 ecx, cl
  00b18	3b cf		 cmp	 ecx, edi
  00b1a	76 5b		 jbe	 SHORT $LN457@inflateBac
  00b1c	8d 64 24 00	 npad	 4
$LL67@inflateBac:

; 542  :                 PULLBYTE();

  00b20	85 f6		 test	 esi, esi
  00b22	75 17		 jne	 SHORT $LN60@inflateBac
  00b24	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00b27	50		 push	 eax
  00b28	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00b2b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00b2e	8b f0		 mov	 esi, eax
  00b30	83 c4 08	 add	 esp, 8
  00b33	85 f6		 test	 esi, esi
  00b35	0f 84 8c 02 00
	00		 je	 $LN377@inflateBac
$LN60@inflateBac:
  00b3b	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00b3e	8b cf		 mov	 ecx, edi
  00b40	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b43	d3 e0		 shl	 eax, cl
  00b45	42		 inc	 edx
  00b46	89 55 fc	 mov	 DWORD PTR _next$[ebp], edx
  00b49	ba 01 00 00 00	 mov	 edx, 1
  00b4e	03 d8		 add	 ebx, eax
  00b50	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b53	83 c7 08	 add	 edi, 8
  00b56	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00b59	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00b5c	d3 e2		 shl	 edx, cl
  00b5e	4e		 dec	 esi
  00b5f	89 5d f8	 mov	 DWORD PTR _hold$1$[ebp], ebx
  00b62	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00b65	4a		 dec	 edx
  00b66	23 d3		 and	 edx, ebx
  00b68	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00b6b	8b c8		 mov	 ecx, eax
  00b6d	c1 e9 08	 shr	 ecx, 8
  00b70	0f b6 c9	 movzx	 ecx, cl
  00b73	3b cf		 cmp	 ecx, edi
  00b75	77 a9		 ja	 SHORT $LL67@inflateBac
$LN457@inflateBac:

; 543  :             }
; 544  :             if ((here.op & 0xf0) == 0) {

  00b77	a8 f0		 test	 al, 240			; 000000f0H
  00b79	0f 85 ca 00 00
	00		 jne	 $LN470@inflateBac

; 545  :                 last = here;
; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  00b7f	8b c8		 mov	 ecx, eax
  00b81	c1 e9 08	 shr	 ecx, 8
  00b84	0f b6 f9	 movzx	 edi, cl
  00b87	89 4d d8	 mov	 DWORD PTR tv1745[ebp], ecx
  00b8a	0f b6 c8	 movzx	 ecx, al
  00b8d	03 cf		 add	 ecx, edi
  00b8f	bb 01 00 00 00	 mov	 ebx, 1
  00b94	d3 e3		 shl	 ebx, cl
  00b96	8b cf		 mov	 ecx, edi
  00b98	8b d0		 mov	 edx, eax
  00b9a	c1 e8 10	 shr	 eax, 16			; 00000010H
  00b9d	4b		 dec	 ebx
  00b9e	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00ba1	89 55 e0	 mov	 DWORD PTR _last$[ebp], edx
  00ba4	d3 eb		 shr	 ebx, cl
  00ba6	03 d8		 add	 ebx, eax
  00ba8	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bab	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bae	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bb1	8b c8		 mov	 ecx, eax
  00bb3	c1 e9 08	 shr	 ecx, 8
  00bb6	0f b6 f9	 movzx	 edi, cl
  00bb9	8b 4d d8	 mov	 ecx, DWORD PTR tv1745[ebp]
  00bbc	0f b6 c9	 movzx	 ecx, cl
  00bbf	03 f9		 add	 edi, ecx
  00bc1	3b 7d ec	 cmp	 edi, DWORD PTR _bits$1$[ebp]
  00bc4	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00bc7	76 74		 jbe	 SHORT $LN44@inflateBac
  00bc9	8d a4 24 00 00
	00 00		 npad	 7
$LL55@inflateBac:

; 550  :                     PULLBYTE();

  00bd0	85 f6		 test	 esi, esi
  00bd2	75 1a		 jne	 SHORT $LN48@inflateBac
  00bd4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00bd7	50		 push	 eax
  00bd8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00bdb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00bde	8b f0		 mov	 esi, eax
  00be0	83 c4 08	 add	 esp, 8
  00be3	85 f6		 test	 esi, esi
  00be5	0f 84 dc 01 00
	00		 je	 $LN377@inflateBac
  00beb	8b 55 e0	 mov	 edx, DWORD PTR _last$[ebp]
$LN48@inflateBac:
  00bee	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00bf1	8b cf		 mov	 ecx, edi
  00bf3	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00bf6	d3 e0		 shl	 eax, cl
  00bf8	83 c7 08	 add	 edi, 8
  00bfb	43		 inc	 ebx
  00bfc	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00bff	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00c02	0f b7 45 e2	 movzx	 eax, WORD PTR _last$[ebp+2]
  00c06	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00c09	0f b6 de	 movzx	 ebx, dh
  00c0c	0f b6 ca	 movzx	 ecx, dl
  00c0f	03 cb		 add	 ecx, ebx
  00c11	bf 01 00 00 00	 mov	 edi, 1
  00c16	d3 e7		 shl	 edi, cl
  00c18	8b cb		 mov	 ecx, ebx
  00c1a	4e		 dec	 esi
  00c1b	4f		 dec	 edi
  00c1c	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  00c1f	d3 ef		 shr	 edi, cl
  00c21	03 f8		 add	 edi, eax
  00c23	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00c26	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00c29	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00c2c	8b 7d ec	 mov	 edi, DWORD PTR _bits$1$[ebp]
  00c2f	8b c8		 mov	 ecx, eax
  00c31	c1 e9 08	 shr	 ecx, 8
  00c34	0f b6 c9	 movzx	 ecx, cl
  00c37	03 cb		 add	 ecx, ebx
  00c39	3b cf		 cmp	 ecx, edi
  00c3b	77 93		 ja	 SHORT $LL55@inflateBac
$LN44@inflateBac:

; 551  :                 }
; 552  :                 DROPBITS(last.bits);

  00c3d	0f b6 ce	 movzx	 ecx, dh
  00c40	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00c43	d3 ea		 shr	 edx, cl
  00c45	2b f9		 sub	 edi, ecx
  00c47	eb 03		 jmp	 SHORT $LN42@inflateBac
$LN470@inflateBac:
  00c49	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN42@inflateBac:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  00c4c	8b c8		 mov	 ecx, eax
  00c4e	c1 e9 08	 shr	 ecx, 8
  00c51	0f b6 c9	 movzx	 ecx, cl
  00c54	d3 ea		 shr	 edx, cl
  00c56	2b f9		 sub	 edi, ecx
  00c58	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00c5b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 555  :             if (here.op & 64) {

  00c5e	a8 40		 test	 al, 64			; 00000040H
  00c60	74 1e		 je	 SHORT $LN38@inflateBac

; 556  :                 strm->msg = (char *)"invalid distance code";

  00c62	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 557  :                 state->mode = BAD;

  00c65	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c68	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00c6f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 558  :                 break;

  00c75	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00c78	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00c7b	e9 20 01 00 00	 jmp	 $LN402@inflateBac
$LN38@inflateBac:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  00c80	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00c83	8b c8		 mov	 ecx, eax

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  00c85	0f b6 c0	 movzx	 eax, al
  00c88	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c8b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00c8e	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  00c91	89 43 48	 mov	 DWORD PTR [ebx+72], eax

; 564  :             if (state->extra != 0) {

  00c94	74 61		 je	 SHORT $LN21@inflateBac

; 565  :                 NEEDBITS(state->extra);

  00c96	3b f8		 cmp	 edi, eax
  00c98	73 43		 jae	 SHORT $LN35@inflateBac
  00c9a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00c9d	8d 49 00	 npad	 3
$LL33@inflateBac:
  00ca0	85 f6		 test	 esi, esi
  00ca2	75 1d		 jne	 SHORT $LN27@inflateBac
  00ca4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00ca7	50		 push	 eax
  00ca8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00cab	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00cae	8b f0		 mov	 esi, eax
  00cb0	83 c4 08	 add	 esp, 8
  00cb3	85 f6		 test	 esi, esi
  00cb5	0f 84 0c 01 00
	00		 je	 $LN377@inflateBac
  00cbb	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00cbe	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN27@inflateBac:
  00cc1	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00cc4	8b cf		 mov	 ecx, edi
  00cc6	d3 e0		 shl	 eax, cl
  00cc8	83 c7 08	 add	 edi, 8
  00ccb	4e		 dec	 esi
  00ccc	03 d0		 add	 edx, eax
  00cce	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00cd1	40		 inc	 eax
  00cd2	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00cd5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cd8	3b 7b 48	 cmp	 edi, DWORD PTR [ebx+72]
  00cdb	72 c3		 jb	 SHORT $LL33@inflateBac
$LN35@inflateBac:

; 566  :                 state->offset += BITS(state->extra);

  00cdd	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00ce0	b8 01 00 00 00	 mov	 eax, 1
  00ce5	d3 e0		 shl	 eax, cl
  00ce7	48		 dec	 eax
  00ce8	23 c2		 and	 eax, edx
  00cea	01 43 44	 add	 DWORD PTR [ebx+68], eax

; 567  :                 DROPBITS(state->extra);

  00ced	d3 ea		 shr	 edx, cl
  00cef	2b f9		 sub	 edi, ecx
  00cf1	89 7d ec	 mov	 DWORD PTR _bits$1$[ebp], edi
  00cf4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN21@inflateBac:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  00cf7	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00cfa	39 4b 2c	 cmp	 DWORD PTR [ebx+44], ecx
  00cfd	1b c0		 sbb	 eax, eax
  00cff	23 45 e8	 and	 eax, DWORD PTR _left$1$[ebp]
  00d02	2b c8		 sub	 ecx, eax
  00d04	39 4b 44	 cmp	 DWORD PTR [ebx+68], ecx

; 572  :                 state->mode = BAD;

  00d07	8b cb		 mov	 ecx, ebx
  00d09	76 1b		 jbe	 SHORT $LL19@inflateBac

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  00d0b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d0e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 572  :                 state->mode = BAD;

  00d15	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 573  :                 break;

  00d1b	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00d1e	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
  00d21	e9 7a 00 00 00	 jmp	 $LN402@inflateBac
$LL19@inflateBac:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  00d26	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  00d2a	75 27		 jne	 SHORT $LN478@inflateBac
  00d2c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00d2f	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  00d32	50		 push	 eax
  00d33	53		 push	 ebx
  00d34	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00d37	89 5d e4	 mov	 DWORD PTR _put$1$[ebp], ebx
  00d3a	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax
  00d3d	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  00d40	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00d43	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d46	85 c0		 test	 eax, eax
  00d48	0f 85 91 00 00
	00		 jne	 $LN380@inflateBac
  00d4e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d51	eb 03		 jmp	 SHORT $LN15@inflateBac
$LN478@inflateBac:
  00d53	8b 5d e4	 mov	 ebx, DWORD PTR _put$1$[ebp]
$LN15@inflateBac:

; 580  :                 copy = state->wsize - state->offset;

  00d56	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00d59	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00d5c	2b c2		 sub	 eax, edx

; 581  :                 if (copy < left) {

  00d5e	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  00d61	73 09		 jae	 SHORT $LN11@inflateBac

; 582  :                     from = put + copy;
; 583  :                     copy = left - copy;

  00d63	8b 55 e8	 mov	 edx, DWORD PTR _left$1$[ebp]
  00d66	03 d8		 add	 ebx, eax
  00d68	2b d0		 sub	 edx, eax

; 584  :                 }
; 585  :                 else {

  00d6a	eb 05		 jmp	 SHORT $LN10@inflateBac
$LN11@inflateBac:

; 586  :                     from = put - state->offset;

  00d6c	2b da		 sub	 ebx, edx

; 587  :                     copy = left;

  00d6e	8b 55 e8	 mov	 edx, DWORD PTR _left$1$[ebp]
$LN10@inflateBac:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  00d71	3b 51 40	 cmp	 edx, DWORD PTR [ecx+64]
  00d74	0f 47 51 40	 cmova	 edx, DWORD PTR [ecx+64]

; 590  :                 state->length -= copy;

  00d78	29 51 40	 sub	 DWORD PTR [ecx+64], edx

; 594  :                 } while (--copy);

  00d7b	8b 4d e4	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00d7e	29 55 e8	 sub	 DWORD PTR _left$1$[ebp], edx
  00d81	2b d9		 sub	 ebx, ecx
$LL8@inflateBac:

; 591  :                 left -= copy;
; 592  :                 do {
; 593  :                     *put++ = *from++;

  00d83	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  00d86	88 01		 mov	 BYTE PTR [ecx], al
  00d88	41		 inc	 ecx

; 594  :                 } while (--copy);

  00d89	4a		 dec	 edx
  00d8a	75 f7		 jne	 SHORT $LL8@inflateBac

; 595  :             } while (state->length != 0);

  00d8c	89 4d e4	 mov	 DWORD PTR _put$1$[ebp], ecx
  00d8f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d92	39 51 40	 cmp	 DWORD PTR [ecx+64], edx
  00d95	75 8f		 jne	 SHORT $LL19@inflateBac
$LN481@inflateBac:
  00d97	8b 5d fc	 mov	 ebx, DWORD PTR _next$[ebp]
  00d9a	89 5d f0	 mov	 DWORD PTR _next$5$[ebp], ebx
$LN469@inflateBac:
  00d9d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN402@inflateBac:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00da0	8b 01		 mov	 eax, DWORD PTR [ecx]
  00da2	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00da5	83 f8 12	 cmp	 eax, 18			; 00000012H
  00da8	0f 86 d2 f2 ff
	ff		 jbe	 $LL345@inflateBac
$LN1@inflateBac:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;
; 609  :             goto inf_leave;
; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  00dae	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN465@inflateBac:
  00db3	8b 45 f0	 mov	 eax, DWORD PTR _next$5$[ebp]
$inf_leave$486:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00db6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00db9	89 01		 mov	 DWORD PTR [ecx], eax

; 619  :     strm->avail_in = have;
; 620  :     return ret;

  00dbb	8b c7		 mov	 eax, edi
  00dbd	5f		 pop	 edi
  00dbe	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00dc1	5e		 pop	 esi
  00dc2	5b		 pop	 ebx

; 621  : }

  00dc3	8b e5		 mov	 esp, ebp
  00dc5	5d		 pop	 ebp
  00dc6	c3		 ret	 0
$LN377@inflateBac:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00dc7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00dca	33 c0		 xor	 eax, eax
  00dcc	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00dd1	89 01		 mov	 DWORD PTR [ecx], eax

; 619  :     strm->avail_in = have;
; 620  :     return ret;

  00dd3	8b c7		 mov	 eax, edi
  00dd5	5f		 pop	 edi
  00dd6	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00dd9	5e		 pop	 esi
  00dda	5b		 pop	 ebx

; 621  : }

  00ddb	8b e5		 mov	 esp, ebp
  00ddd	5d		 pop	 ebp
  00dde	c3		 ret	 0
$LN380@inflateBac:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00ddf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00de2	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00de5	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00dea	89 01		 mov	 DWORD PTR [ecx], eax

; 619  :     strm->avail_in = have;
; 620  :     return ret;

  00dec	8b c7		 mov	 eax, edi
  00dee	5f		 pop	 edi
  00def	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00df2	5e		 pop	 esi
  00df3	5b		 pop	 ebx

; 621  : }

  00df4	8b e5		 mov	 esp, ebp
  00df6	5d		 pop	 ebp
  00df7	c3		 ret	 0
$LN5@inflateBac:

; 596  :             break;
; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;
; 601  :             if (left < state->wsize) {

  00df8	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00dfb	8b 55 e8	 mov	 edx, DWORD PTR _left$1$[ebp]
  00dfe	bf 01 00 00 00	 mov	 edi, 1
  00e03	3b d0		 cmp	 edx, eax
  00e05	73 ac		 jae	 SHORT $LN465@inflateBac

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  00e07	2b c2		 sub	 eax, edx
  00e09	50		 push	 eax
  00e0a	ff 71 34	 push	 DWORD PTR [ecx+52]
  00e0d	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00e10	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00e13	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e16	85 c0		 test	 eax, eax

; 603  :                     ret = Z_BUF_ERROR;
; 604  :             }
; 605  :             goto inf_leave;

  00e18	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00e1b	74 99		 je	 SHORT $inf_leave$486

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00e1d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00e20	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00e25	89 01		 mov	 DWORD PTR [ecx], eax

; 619  :     strm->avail_in = have;
; 620  :     return ret;

  00e27	8b c7		 mov	 eax, edi
  00e29	5f		 pop	 edi
  00e2a	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00e2d	5e		 pop	 esi
  00e2e	5b		 pop	 ebx

; 621  : }

  00e2f	8b e5		 mov	 esp, ebp
  00e31	5d		 pop	 ebp
  00e32	c3		 ret	 0
$LN2@inflateBac:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00e33	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00e36	8b 45 f0	 mov	 eax, DWORD PTR _next$5$[ebp]
  00e39	bf fd ff ff ff	 mov	 edi, -3			; fffffffdH
  00e3e	89 01		 mov	 DWORD PTR [ecx], eax

; 619  :     strm->avail_in = have;
; 620  :     return ret;

  00e40	8b c7		 mov	 eax, edi
  00e42	5f		 pop	 edi
  00e43	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00e46	5e		 pop	 esi
  00e47	5b		 pop	 ebx

; 621  : }

  00e48	8b e5		 mov	 esp, ebp
  00e4a	5d		 pop	 ebp
  00e4b	c3		 ret	 0
$LN346@inflateBac:

; 265  :         return Z_STREAM_ERROR;

  00e4c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 621  : }

  00e51	8b e5		 mov	 esp, ebp
  00e53	5d		 pop	 ebp
  00e54	c3		 ret	 0
  00e55	8d 49 00	 npad	 3
$LN484@inflateBac:
  00e58	00 00 00 00	 DD	 $LN341@inflateBac
  00e5c	00 00 00 00	 DD	 $LN310@inflateBac
  00e60	00 00 00 00	 DD	 $LN275@inflateBac
  00e64	00 00 00 00	 DD	 $LN130@inflateBac
  00e68	00 00 00 00	 DD	 $LN5@inflateBac
  00e6c	00 00 00 00	 DD	 $LN2@inflateBac
  00e70	00 00 00 00	 DD	 $LN1@inflateBac
$LN453@inflateBac:
  00e74	00		 DB	 0
  00e75	06		 DB	 6
  00e76	01		 DB	 1
  00e77	06		 DB	 6
  00e78	06		 DB	 6
  00e79	02		 DB	 2
  00e7a	06		 DB	 6
  00e7b	06		 DB	 6
  00e7c	06		 DB	 6
  00e7d	03		 DB	 3
  00e7e	06		 DB	 6
  00e7f	06		 DB	 6
  00e80	06		 DB	 6
  00e81	06		 DB	 6
  00e82	06		 DB	 6
  00e83	06		 DB	 6
  00e84	06		 DB	 6
  00e85	04		 DB	 4
  00e86	05		 DB	 5
  00e87	90		 npad	 1
$LN485@inflateBac:
  00e88	00 00 00 00	 DD	 $LN318@inflateBac
  00e8c	00 00 00 00	 DD	 $LN317@inflateBac
  00e90	00 00 00 00	 DD	 $LN316@inflateBac
  00e94	00 00 00 00	 DD	 $LN315@inflateBac
_inflateBack ENDP
_TEXT	ENDS
END
