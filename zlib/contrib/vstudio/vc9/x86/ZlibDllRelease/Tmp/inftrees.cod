; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
CONST	SEGMENT
_inflate_copyright DB ' inflate 1.2.5 Copyright 1995-2010 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
CONST	ENDS
PUBLIC	_inflate_table
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
_offs$ = -128						; size = 32
_count$ = -96						; size = 32
tv1267 = -64						; size = 4
_min$2$ = -60						; size = 4
_mask$1$ = -56						; size = 4
tv1268 = -52						; size = 4
_incr$1$ = -48						; size = 4
_huff$1$ = -48						; size = 4
_used$1$ = -44						; size = 4
_low$1$ = -40						; size = 4
_len$2$ = -36						; size = 4
_base$1$ = -32						; size = 4
_extra$1$ = -28						; size = 4
_curr$1$ = -24						; size = 4
tv1262 = -24						; size = 4
_max$1$ = -20						; size = 4
_end$1$ = -16						; size = 4
_root$3$ = -12						; size = 4
_next$1$ = -8						; size = 4
_drop$1$ = -4						; size = 4
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_here$ = 16						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00009	33 c9		 xor	 ecx, ecx
  0000b	0f b7 c1	 movzx	 eax, cx
  0000e	8b c8		 mov	 ecx, eax
  00010	c1 e0 10	 shl	 eax, 16			; 00000010H
  00013	0b c8		 or	 ecx, eax
  00015	53		 push	 ebx
  00016	56		 push	 esi

; 109  :     for (sym = 0; sym < codes; sym++)

  00017	8b 75 10	 mov	 esi, DWORD PTR _codes$[ebp]
  0001a	89 4d a0	 mov	 DWORD PTR _count$[ebp], ecx
  0001d	89 4d a4	 mov	 DWORD PTR _count$[ebp+4], ecx
  00020	89 4d a8	 mov	 DWORD PTR _count$[ebp+8], ecx
  00023	89 4d ac	 mov	 DWORD PTR _count$[ebp+12], ecx
  00026	89 4d b0	 mov	 DWORD PTR _count$[ebp+16], ecx
  00029	89 4d b4	 mov	 DWORD PTR _count$[ebp+20], ecx
  0002c	89 4d b8	 mov	 DWORD PTR _count$[ebp+24], ecx
  0002f	89 4d bc	 mov	 DWORD PTR _count$[ebp+28], ecx
  00032	33 c9		 xor	 ecx, ecx
  00034	57		 push	 edi
  00035	85 f6		 test	 esi, esi
  00037	74 19		 je	 SHORT $LN63@inflate_ta
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL65@inflate_ta:

; 110  :         count[lens[sym]]++;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00043	41		 inc	 ecx
  00044	0f b7 44 48 fe	 movzx	 eax, WORD PTR [eax+ecx*2-2]
  00049	66 ff 44 45 a0	 inc	 WORD PTR _count$[ebp+eax*2]
  0004e	3b ce		 cmp	 ecx, esi
  00050	72 ee		 jb	 SHORT $LL65@inflate_ta
$LN63@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00052	8b 5d 18	 mov	 ebx, DWORD PTR _bits$[ebp]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00055	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0005a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005c	8d 64 24 00	 npad	 4
$LL62@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00060	66 83 7c 7d a0
	00		 cmp	 WORD PTR _count$[ebp+edi*2], 0
  00066	75 06		 jne	 SHORT $LN85@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00068	4f		 dec	 edi
  00069	83 ff 01	 cmp	 edi, 1
  0006c	73 f2		 jae	 SHORT $LL62@inflate_ta
$LN85@inflate_ta:

; 116  :     if (root > max) root = max;

  0006e	3b c7		 cmp	 eax, edi
  00070	0f 47 c7	 cmova	 eax, edi
  00073	89 7d ec	 mov	 DWORD PTR _max$1$[ebp], edi

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  00076	85 ff		 test	 edi, edi
  00078	75 2a		 jne	 SHORT $LN57@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  0007a	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  0007d	c7 45 10 40 01
	00 00		 mov	 DWORD PTR _here$[ebp], 320 ; 00000140H
  00084	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00086	8b 45 10	 mov	 eax, DWORD PTR _here$[ebp]
  00089	89 01		 mov	 DWORD PTR [ecx], eax
  0008b	83 02 04	 add	 DWORD PTR [edx], 4
  0008e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00090	5f		 pop	 edi

; 122  :         *(*table)++ = here;

  00091	89 01		 mov	 DWORD PTR [ecx], eax
  00093	83 02 04	 add	 DWORD PTR [edx], 4
  00096	5e		 pop	 esi

; 123  :         *bits = 1;

  00097	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0009d	33 c0		 xor	 eax, eax
  0009f	5b		 pop	 ebx

; 330  : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
$LN57@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000a4	bb 01 00 00 00	 mov	 ebx, 1
  000a9	89 5d dc	 mov	 DWORD PTR _len$2$[ebp], ebx
  000ac	3b fb		 cmp	 edi, ebx
  000ae	76 10		 jbe	 SHORT $LN86@inflate_ta
$LL56@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000b0	66 83 7c 5d a0
	00		 cmp	 WORD PTR _count$[ebp+ebx*2], 0
  000b6	75 05		 jne	 SHORT $LN132@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000b8	43		 inc	 ebx
  000b9	3b df		 cmp	 ebx, edi
  000bb	72 f3		 jb	 SHORT $LL56@inflate_ta
$LN132@inflate_ta:
  000bd	89 5d dc	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN86@inflate_ta:

; 128  :     if (root < min) root = min;

  000c0	3b c3		 cmp	 eax, ebx
  000c2	0f 42 c3	 cmovb	 eax, ebx

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000c5	ba 01 00 00 00	 mov	 edx, 1
  000ca	89 45 f4	 mov	 DWORD PTR _root$3$[ebp], eax

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000cd	8b ca		 mov	 ecx, edx
  000cf	90		 npad	 1
$LL51@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  000d0	0f b7 44 4d a0	 movzx	 eax, WORD PTR _count$[ebp+ecx*2]
  000d5	03 d2		 add	 edx, edx
  000d7	2b d0		 sub	 edx, eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  000d9	0f 88 53 03 00
	00		 js	 $LN87@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000df	41		 inc	 ecx
  000e0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000e3	76 eb		 jbe	 SHORT $LL51@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  000e5	85 d2		 test	 edx, edx
  000e7	7e 13		 jle	 SHORT $LN47@inflate_ta
  000e9	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  000ed	0f 84 3f 03 00
	00		 je	 $LN87@inflate_ta
  000f3	83 ff 01	 cmp	 edi, 1
  000f6	0f 85 36 03 00
	00		 jne	 $LN87@inflate_ta
$LN47@inflate_ta:

; 138  :         return -1;                      /* incomplete set */
; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  000fc	33 c0		 xor	 eax, eax
  000fe	66 89 45 82	 mov	 WORD PTR _offs$[ebp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  00102	b9 02 00 00 00	 mov	 ecx, 2
  00107	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL45@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00110	66 8b 44 0d 80	 mov	 ax, WORD PTR _offs$[ebp+ecx]
  00115	66 03 44 0d a0	 add	 ax, WORD PTR _count$[ebp+ecx]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	66 89 44 0d 80	 mov	 WORD PTR _offs$[ebp+ecx], ax
  00122	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00125	72 e9		 jb	 SHORT $LL45@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00127	33 c9		 xor	 ecx, ecx
  00129	85 f6		 test	 esi, esi
  0012b	74 29		 je	 SHORT $LN40@inflate_ta
  0012d	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  00130	8b 7d 0c	 mov	 edi, DWORD PTR _lens$[ebp]
$LL42@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00133	0f b7 04 4f	 movzx	 eax, WORD PTR [edi+ecx*2]
  00137	66 85 c0	 test	 ax, ax
  0013a	74 12		 je	 SHORT $LN41@inflate_ta
  0013c	0f b7 44 45 80	 movzx	 eax, WORD PTR _offs$[ebp+eax*2]
  00141	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00145	0f b7 04 4f	 movzx	 eax, WORD PTR [edi+ecx*2]
  00149	66 ff 44 45 80	 inc	 WORD PTR _offs$[ebp+eax*2]
$LN41@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0014e	41		 inc	 ecx
  0014f	3b ce		 cmp	 ecx, esi
  00151	72 e0		 jb	 SHORT $LL42@inflate_ta
  00153	8b 7d ec	 mov	 edi, DWORD PTR _max$1$[ebp]
$LN40@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00156	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00159	83 e8 00	 sub	 eax, 0
  0015c	74 3a		 je	 SHORT $LN36@inflate_ta
  0015e	48		 dec	 eax
  0015f	74 17		 je	 SHORT $LN35@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  00161	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;

  00168	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _extra$1$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 196  :         end = -1;

  0016f	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _end$1$[ebp], -1
  00176	eb 30		 jmp	 SHORT $LN37@inflate_ta
$LN35@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  00178	b8 00 00 00 00	 mov	 eax, OFFSET ?lbase@?1??inflate_table@@9@9
  0017d	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  00182	89 45 e0	 mov	 DWORD PTR _base$1$[ebp], eax

; 189  :         extra = lext;
; 190  :         extra -= 257;

  00185	b8 00 00 00 00	 mov	 eax, OFFSET ?lext@?1??inflate_table@@9@9
  0018a	2d 02 02 00 00	 sub	 eax, 514		; 00000202H

; 191  :         end = 256;

  0018f	c7 45 f0 00 01
	00 00		 mov	 DWORD PTR _end$1$[ebp], 256 ; 00000100H

; 192  :         break;

  00196	eb 0d		 jmp	 SHORT $LN141@inflate_ta
$LN36@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00198	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0019b	89 45 e0	 mov	 DWORD PTR _base$1$[ebp], eax

; 184  :         end = 19;

  0019e	c7 45 f0 13 00
	00 00		 mov	 DWORD PTR _end$1$[ebp], 19 ; 00000013H
$LN141@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  001a5	89 45 e4	 mov	 DWORD PTR _extra$1$[ebp], eax
$LN37@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001a8	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */
; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */

  001ab	8b 4d f4	 mov	 ecx, DWORD PTR _root$3$[ebp]
  001ae	8b 00		 mov	 eax, DWORD PTR [eax]
  001b0	89 45 f8	 mov	 DWORD PTR _next$1$[ebp], eax
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	d3 e0		 shl	 eax, cl
  001ba	33 d2		 xor	 edx, edx
  001bc	33 f6		 xor	 esi, esi
  001be	89 55 fc	 mov	 DWORD PTR _drop$1$[ebp], edx
  001c1	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _low$1$[ebp], -1

; 208  :     mask = used - 1;            /* mask for comparing low */

  001c8	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  001cb	89 4d c8	 mov	 DWORD PTR _mask$1$[ebp], ecx

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  001d1	89 45 cc	 mov	 DWORD PTR tv1268[ebp], eax
  001d4	89 45 d4	 mov	 DWORD PTR _used$1$[ebp], eax
  001d7	83 f9 01	 cmp	 ecx, 1
  001da	75 21		 jne	 SHORT $LN31@inflate_ta
  001dc	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  001e1	73 26		 jae	 SHORT $LN32@inflate_ta
$LL30@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  001e3	8a c3		 mov	 al, bl
  001e5	2a c2		 sub	 al, dl
  001e7	88 45 11	 mov	 BYTE PTR _here$[ebp+1], al

; 219  :         if ((int)(work[sym]) < end) {

  001ea	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  001ed	0f b7 00	 movzx	 eax, WORD PTR [eax]
  001f0	8b c8		 mov	 ecx, eax
  001f2	3b 4d f0	 cmp	 ecx, DWORD PTR _end$1$[ebp]
  001f5	7d 1e		 jge	 SHORT $LN142@inflate_ta

; 220  :             here.op = (unsigned char)0;

  001f7	c6 45 10 00	 mov	 BYTE PTR _here$[ebp], 0

; 221  :             here.val = work[sym];

  001fb	eb 32		 jmp	 SHORT $LN143@inflate_ta
$LN31@inflate_ta:

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  001fd	83 f9 02	 cmp	 ecx, 2
  00200	75 e1		 jne	 SHORT $LL30@inflate_ta
  00202	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  00207	72 da		 jb	 SHORT $LL30@inflate_ta
$LN32@inflate_ta:
  00209	5f		 pop	 edi
  0020a	5e		 pop	 esi

; 213  :         return 1;

  0020b	b8 01 00 00 00	 mov	 eax, 1
  00210	5b		 pop	 ebx

; 330  : }

  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
$LN142@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  00215	7e 12		 jle	 SHORT $LN26@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00217	8b 45 e4	 mov	 eax, DWORD PTR _extra$1$[ebp]
  0021a	8a 04 48	 mov	 al, BYTE PTR [eax+ecx*2]
  0021d	88 45 10	 mov	 BYTE PTR _here$[ebp], al

; 225  :             here.val = base[work[sym]];

  00220	8b 45 e0	 mov	 eax, DWORD PTR _base$1$[ebp]
  00223	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]

; 226  :         }
; 227  :         else {

  00227	eb 06		 jmp	 SHORT $LN143@inflate_ta
$LN26@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00229	c6 45 10 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 229  :             here.val = 0;

  0022d	33 c0		 xor	 eax, eax
$LN143@inflate_ta:
  0022f	66 89 45 12	 mov	 WORD PTR _here$[ebp+2], ax

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00233	8b cb		 mov	 ecx, ebx
  00235	2b ca		 sub	 ecx, edx

; 234  :         fill = 1U << curr;

  00237	8b 55 cc	 mov	 edx, DWORD PTR tv1268[ebp]
  0023a	b8 01 00 00 00	 mov	 eax, 1
  0023f	d3 e0		 shl	 eax, cl
  00241	8b 4d fc	 mov	 ecx, DWORD PTR _drop$1$[ebp]

; 235  :         min = fill;                 /* save offset to next table */

  00244	89 55 c4	 mov	 DWORD PTR _min$2$[ebp], edx
  00247	89 45 d0	 mov	 DWORD PTR _incr$1$[ebp], eax
  0024a	c1 e0 02	 shl	 eax, 2
  0024d	89 45 e8	 mov	 DWORD PTR tv1262[ebp], eax
  00250	8b c6		 mov	 eax, esi
  00252	d3 e8		 shr	 eax, cl
  00254	8b 4d f8	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00257	03 c2		 add	 eax, edx
  00259	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  0025c	8b 45 10	 mov	 eax, DWORD PTR _here$[ebp]
  0025f	90		 npad	 1
$LL24@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  00260	2b 4d e8	 sub	 ecx, DWORD PTR tv1262[ebp]

; 238  :             next[(huff >> drop) + fill] = here;

  00263	89 01		 mov	 DWORD PTR [ecx], eax
  00265	2b 55 d0	 sub	 edx, DWORD PTR _incr$1$[ebp]

; 239  :         } while (fill != 0);

  00268	75 f6		 jne	 SHORT $LL24@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  0026a	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  0026d	ba 01 00 00 00	 mov	 edx, 1
  00272	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  00274	85 d6		 test	 edx, esi
  00276	74 06		 je	 SHORT $LN20@inflate_ta
$LL21@inflate_ta:

; 244  :             incr >>= 1;

  00278	d1 ea		 shr	 edx, 1
  0027a	85 d6		 test	 edx, esi
  0027c	75 fa		 jne	 SHORT $LL21@inflate_ta
$LN20@inflate_ta:

; 245  :         if (incr != 0) {

  0027e	85 d2		 test	 edx, edx
  00280	74 0e		 je	 SHORT $LN19@inflate_ta

; 246  :             huff &= incr - 1;

  00282	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00285	23 c6		 and	 eax, esi

; 247  :             huff += incr;

  00287	03 c2		 add	 eax, edx
  00289	8b f0		 mov	 esi, eax
  0028b	89 45 d0	 mov	 DWORD PTR _huff$1$[ebp], eax

; 248  :         }
; 249  :         else

  0028e	eb 05		 jmp	 SHORT $LN18@inflate_ta
$LN19@inflate_ta:

; 250  :             huff = 0;

  00290	33 f6		 xor	 esi, esi
  00292	89 75 d0	 mov	 DWORD PTR _huff$1$[ebp], esi
$LN18@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  00295	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00298	83 c0 02	 add	 eax, 2

; 254  :         if (--(count[len]) == 0) {

  0029b	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002a0	66 01 4c 5d a0	 add	 WORD PTR _count$[ebp+ebx*2], cx
  002a5	89 45 1c	 mov	 DWORD PTR _work$[ebp], eax
  002a8	75 15		 jne	 SHORT $LN17@inflate_ta

; 255  :             if (len == max) break;

  002aa	3b df		 cmp	 ebx, edi
  002ac	0f 84 f2 00 00
	00		 je	 $LN89@inflate_ta

; 256  :             len = lens[work[sym]];

  002b2	0f b7 00	 movzx	 eax, WORD PTR [eax]
  002b5	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  002b8	0f b7 1c 41	 movzx	 ebx, WORD PTR [ecx+eax*2]
  002bc	89 5d dc	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN17@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  002bf	8b 55 fc	 mov	 edx, DWORD PTR _drop$1$[ebp]
  002c2	3b 5d f4	 cmp	 ebx, DWORD PTR _root$3$[ebp]
  002c5	0f 86 18 ff ff
	ff		 jbe	 $LL30@inflate_ta
  002cb	8b 45 c8	 mov	 eax, DWORD PTR _mask$1$[ebp]
  002ce	23 c6		 and	 eax, esi
  002d0	89 45 c0	 mov	 DWORD PTR tv1267[ebp], eax
  002d3	3b 45 d8	 cmp	 eax, DWORD PTR _low$1$[ebp]
  002d6	0f 84 07 ff ff
	ff		 je	 $LL30@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)
; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  002dc	8b 45 c4	 mov	 eax, DWORD PTR _min$2$[ebp]
  002df	8b ca		 mov	 ecx, edx
  002e1	8b 55 f8	 mov	 edx, DWORD PTR _next$1$[ebp]
  002e4	85 c9		 test	 ecx, ecx
  002e6	0f 44 4d f4	 cmove	 ecx, DWORD PTR _root$3$[ebp]
  002ea	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  002ed	8b c3		 mov	 eax, ebx
  002ef	2b c1		 sub	 eax, ecx
  002f1	89 4d fc	 mov	 DWORD PTR _drop$1$[ebp], ecx
  002f4	89 55 f8	 mov	 DWORD PTR _next$1$[ebp], edx

; 270  :             left = (int)(1 << curr);

  002f7	8b c8		 mov	 ecx, eax
  002f9	ba 01 00 00 00	 mov	 edx, 1
  002fe	d3 e2		 shl	 edx, cl

; 271  :             while (curr + drop < max) {

  00300	8b 4d fc	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  00303	03 c8		 add	 ecx, eax
  00305	89 45 e8	 mov	 DWORD PTR _curr$1$[ebp], eax
  00308	3b cf		 cmp	 ecx, edi
  0030a	73 2e		 jae	 SHORT $LN88@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)
; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0030c	8b 75 ec	 mov	 esi, DWORD PTR _max$1$[ebp]
  0030f	8d 7d a0	 lea	 edi, DWORD PTR _count$[ebp]
  00312	8b d8		 mov	 ebx, eax
  00314	8d 3c 4f	 lea	 edi, DWORD PTR [edi+ecx*2]
$LL13@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00317	0f b7 07	 movzx	 eax, WORD PTR [edi]
  0031a	2b d0		 sub	 edx, eax

; 273  :                 if (left <= 0) break;

  0031c	85 d2		 test	 edx, edx
  0031e	7e 0b		 jle	 SHORT $LN133@inflate_ta

; 274  :                 curr++;

  00320	41		 inc	 ecx
  00321	43		 inc	 ebx
  00322	83 c7 02	 add	 edi, 2

; 275  :                 left <<= 1;

  00325	03 d2		 add	 edx, edx
  00327	3b ce		 cmp	 ecx, esi
  00329	72 ec		 jb	 SHORT $LL13@inflate_ta
$LN133@inflate_ta:
  0032b	8b 75 d0	 mov	 esi, DWORD PTR _huff$1$[ebp]
  0032e	8b 7d ec	 mov	 edi, DWORD PTR _max$1$[ebp]
  00331	89 5d e8	 mov	 DWORD PTR _curr$1$[ebp], ebx
  00334	8b 5d dc	 mov	 ebx, DWORD PTR _len$2$[ebp]
  00337	8b 45 e8	 mov	 eax, DWORD PTR _curr$1$[ebp]
$LN88@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  0033a	8b c8		 mov	 ecx, eax
  0033c	8b 45 d4	 mov	 eax, DWORD PTR _used$1$[ebp]
  0033f	ba 01 00 00 00	 mov	 edx, 1
  00344	d3 e2		 shl	 edx, cl

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))

  00346	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  00349	03 c2		 add	 eax, edx
  0034b	89 55 cc	 mov	 DWORD PTR tv1268[ebp], edx
  0034e	89 45 d4	 mov	 DWORD PTR _used$1$[ebp], eax
  00351	83 f9 01	 cmp	 ecx, 1
  00354	75 07		 jne	 SHORT $LN8@inflate_ta
  00356	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  0035b	eb 0a		 jmp	 SHORT $LN144@inflate_ta
$LN8@inflate_ta:
  0035d	83 f9 02	 cmp	 ecx, 2
  00360	75 0b		 jne	 SHORT $LN10@inflate_ta
  00362	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
$LN144@inflate_ta:
  00367	0f 83 9c fe ff
	ff		 jae	 $LN32@inflate_ta
$LN10@inflate_ta:

; 282  :                 return 1;
; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  0036d	8b 55 c0	 mov	 edx, DWORD PTR tv1267[ebp]

; 286  :             (*table)[low].op = (unsigned char)curr;

  00370	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00373	8b 4d e8	 mov	 ecx, DWORD PTR _curr$1$[ebp]
  00376	8b 00		 mov	 eax, DWORD PTR [eax]
  00378	89 55 d8	 mov	 DWORD PTR _low$1$[ebp], edx
  0037b	88 0c 90	 mov	 BYTE PTR [eax+edx*4], cl

; 287  :             (*table)[low].bits = (unsigned char)root;

  0037e	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00381	8b 4d f4	 mov	 ecx, DWORD PTR _root$3$[ebp]
  00384	8b 00		 mov	 eax, DWORD PTR [eax]
  00386	88 4c 90 01	 mov	 BYTE PTR [eax+edx*4+1], cl

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  0038a	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  0038d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038f	8b 45 f8	 mov	 eax, DWORD PTR _next$1$[ebp]
  00392	2b c1		 sub	 eax, ecx
  00394	c1 f8 02	 sar	 eax, 2
  00397	66 89 44 91 02	 mov	 WORD PTR [ecx+edx*4+2], ax

; 289  :         }
; 290  :     }

  0039c	8b 55 fc	 mov	 edx, DWORD PTR _drop$1$[ebp]
  0039f	e9 3f fe ff ff	 jmp	 $LL30@inflate_ta
$LN89@inflate_ta:

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */
; 300  :     here.bits = (unsigned char)(len - drop);

  003a4	8b 4d fc	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  003a7	8a c3		 mov	 al, bl
  003a9	2a c1		 sub	 al, cl
  003ab	88 45 11	 mov	 BYTE PTR _here$[ebp+1], al

; 301  :     here.val = (unsigned short)0;

  003ae	33 c0		 xor	 eax, eax
  003b0	c6 45 10 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H
  003b4	66 89 45 12	 mov	 WORD PTR _here$[ebp+2], ax

; 302  :     while (huff != 0) {

  003b8	85 f6		 test	 esi, esi
  003ba	74 5a		 je	 SHORT $LN134@inflate_ta
  003bc	8b 7d d8	 mov	 edi, DWORD PTR _low$1$[ebp]
  003bf	90		 npad	 1
$LL7@inflate_ta:

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  003c0	85 c9		 test	 ecx, ecx
  003c2	74 1e		 je	 SHORT $LN5@inflate_ta
  003c4	8b 45 c8	 mov	 eax, DWORD PTR _mask$1$[ebp]
  003c7	23 c6		 and	 eax, esi
  003c9	3b c7		 cmp	 eax, edi
  003cb	74 15		 je	 SHORT $LN5@inflate_ta

; 305  :             drop = 0;
; 306  :             len = root;
; 307  :             next = *table;

  003cd	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  003d0	8b 45 f4	 mov	 eax, DWORD PTR _root$3$[ebp]
  003d3	8b 12		 mov	 edx, DWORD PTR [edx]
  003d5	33 c9		 xor	 ecx, ecx
  003d7	89 4d fc	 mov	 DWORD PTR _drop$1$[ebp], ecx
  003da	8b d8		 mov	 ebx, eax
  003dc	89 55 f8	 mov	 DWORD PTR _next$1$[ebp], edx

; 308  :             here.bits = (unsigned char)len;

  003df	88 45 11	 mov	 BYTE PTR _here$[ebp+1], al
$LN5@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  003e2	8b 45 10	 mov	 eax, DWORD PTR _here$[ebp]
  003e5	8b d6		 mov	 edx, esi
  003e7	d3 ea		 shr	 edx, cl
  003e9	8b 4d f8	 mov	 ecx, DWORD PTR _next$1$[ebp]
  003ec	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  003ef	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  003f2	b8 01 00 00 00	 mov	 eax, 1
  003f7	d3 e0		 shl	 eax, cl

; 316  :         while (huff & incr)

  003f9	85 c6		 test	 eax, esi
  003fb	74 09		 je	 SHORT $LN3@inflate_ta
  003fd	8d 49 00	 npad	 3
$LL4@inflate_ta:

; 317  :             incr >>= 1;

  00400	d1 e8		 shr	 eax, 1
  00402	85 c6		 test	 eax, esi
  00404	75 fa		 jne	 SHORT $LL4@inflate_ta
$LN3@inflate_ta:

; 318  :         if (incr != 0) {

  00406	85 c0		 test	 eax, eax
  00408	74 0c		 je	 SHORT $LN134@inflate_ta

; 319  :             huff &= incr - 1;

  0040a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0040d	23 f1		 and	 esi, ecx
  0040f	8b 4d fc	 mov	 ecx, DWORD PTR _drop$1$[ebp]

; 320  :             huff += incr;

  00412	03 f0		 add	 esi, eax
  00414	75 aa		 jne	 SHORT $LL7@inflate_ta
$LN134@inflate_ta:

; 321  :         }
; 322  :         else
; 323  :             huff = 0;
; 324  :     }
; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  00416	8b 45 d4	 mov	 eax, DWORD PTR _used$1$[ebp]
  00419	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  0041c	c1 e0 02	 shl	 eax, 2
  0041f	01 01		 add	 DWORD PTR [ecx], eax

; 328  :     *bits = root;

  00421	8b 45 f4	 mov	 eax, DWORD PTR _root$3$[ebp]
  00424	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  00427	5f		 pop	 edi
  00428	5e		 pop	 esi
  00429	89 01		 mov	 DWORD PTR [ecx], eax

; 329  :     return 0;

  0042b	33 c0		 xor	 eax, eax
  0042d	5b		 pop	 ebx

; 330  : }

  0042e	8b e5		 mov	 esp, ebp
  00430	5d		 pop	 ebp
  00431	c3		 ret	 0
$LN87@inflate_ta:
  00432	5f		 pop	 edi
  00433	5e		 pop	 esi

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00434	83 c8 ff	 or	 eax, -1
  00437	5b		 pop	 ebx

; 330  : }

  00438	8b e5		 mov	 esp, ebp
  0043a	5d		 pop	 ebp
  0043b	c3		 ret	 0
_inflate_table ENDP
_TEXT	ENDS
END
