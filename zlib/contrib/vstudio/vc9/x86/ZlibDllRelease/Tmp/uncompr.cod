; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_uncompress
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
EXTRN	_inflate:PROC
EXTRN	_inflateEnd:PROC
EXTRN	_inflateInit_:PROC
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\uncompr.c
;	COMDAT _uncompress
_TEXT	SEGMENT
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress PROC					; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 30   :     z_stream stream;
; 31   :     int err;
; 32   : 
; 33   :     stream.next_in = (Bytef*)source;

  00006	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]
  00009	89 45 c8	 mov	 DWORD PTR _stream$[ebp], eax

; 34   :     stream.avail_in = (uInt)sourceLen;

  0000c	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  0000f	57		 push	 edi

; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : 
; 38   :     stream.next_out = dest;
; 39   :     stream.avail_out = (uInt)*destLen;

  00010	8b 7d 0c	 mov	 edi, DWORD PTR _destLen$[ebp]
  00013	89 45 cc	 mov	 DWORD PTR _stream$[ebp+4], eax
  00016	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00019	89 45 d4	 mov	 DWORD PTR _stream$[ebp+12], eax
  0001c	8b 07		 mov	 eax, DWORD PTR [edi]

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;
; 43   :     stream.zfree = (free_func)0;
; 44   : 
; 45   :     err = inflateInit(&stream);

  0001e	6a 38		 push	 56			; 00000038H
  00020	89 45 d8	 mov	 DWORD PTR _stream$[ebp+16], eax
  00023	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45?$AA@
  0002b	50		 push	 eax
  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+32], 0
  00033	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+36], 0
  0003a	e8 00 00 00 00	 call	 _inflateInit_
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 46   :     if (err != Z_OK) return err;

  00042	85 c0		 test	 eax, eax
  00044	75 57		 jne	 SHORT $LN7@uncompress

; 47   : 
; 48   :     err = inflate(&stream, Z_FINISH);

  00046	56		 push	 esi
  00047	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  0004a	6a 04		 push	 4
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _inflate
  00052	8b f0		 mov	 esi, eax
  00054	83 c4 08	 add	 esp, 8

; 49   :     if (err != Z_STREAM_END) {

  00057	83 fe 01	 cmp	 esi, 1
  0005a	74 2f		 je	 SHORT $LN3@uncompress

; 50   :         inflateEnd(&stream);

  0005c	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _inflateEnd
  00065	83 c4 04	 add	 esp, 4

; 51   :         if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))

  00068	83 fe 02	 cmp	 esi, 2
  0006b	74 13		 je	 SHORT $LN1@uncompress
  0006d	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00070	75 06		 jne	 SHORT $LN2@uncompress
  00072	83 7d cc 00	 cmp	 DWORD PTR _stream$[ebp+4], 0
  00076	74 08		 je	 SHORT $LN1@uncompress
$LN2@uncompress:

; 53   :         return err;

  00078	8b c6		 mov	 eax, esi
  0007a	5e		 pop	 esi
  0007b	5f		 pop	 edi

; 58   :     return err;
; 59   : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN1@uncompress:
  00080	5e		 pop	 esi

; 52   :             return Z_DATA_ERROR;

  00081	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00086	5f		 pop	 edi

; 58   :     return err;
; 59   : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN3@uncompress:

; 54   :     }
; 55   :     *destLen = stream.total_out;

  0008b	8b 45 dc	 mov	 eax, DWORD PTR _stream$[ebp+20]
  0008e	89 07		 mov	 DWORD PTR [edi], eax

; 56   : 
; 57   :     err = inflateEnd(&stream);

  00090	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _inflateEnd
  00099	83 c4 04	 add	 esp, 4
  0009c	5e		 pop	 esi
$LN7@uncompress:
  0009d	5f		 pop	 edi

; 58   :     return err;
; 59   : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_uncompress ENDP
_TEXT	ENDS
END
