; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\deflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deflate_copyright
CONST	SEGMENT
_deflate_copyright DB ' deflate 1.2.5 Copyright 1995-2010 Jean-loup Gaill'
	DB	'y and Mark Adler ', 00H
	ORG $+4
_configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DD	FLAT:_deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DD	FLAT:_deflate_slow
?my_version@?1??deflateInit2_@@9@9 DB '1.2.5', 00H	; `deflateInit2_'::`2'::my_version
CONST	ENDS
PUBLIC	_deflate
PUBLIC	_deflateEnd
PUBLIC	_deflateSetDictionary
PUBLIC	_deflateCopy
PUBLIC	_deflateReset
PUBLIC	_deflateParams
PUBLIC	_deflateTune
PUBLIC	_deflateBound
PUBLIC	_deflatePrime
PUBLIC	_deflateSetHeader
PUBLIC	_deflateInit_
PUBLIC	_deflateInit2_
EXTRN	_adler32:PROC
EXTRN	_crc32:PROC
EXTRN	_zcalloc:PROC
EXTRN	_zcfree:PROC
EXTRN	__tr_init:PROC
EXTRN	__tr_flush_block:PROC
EXTRN	__tr_align:PROC
EXTRN	__tr_stored_block:PROC
EXTRN	_match_init:PROC
EXTRN	_longest_match:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_z_errmsg:BYTE
EXTRN	__length_code:BYTE
EXTRN	__dist_code:BYTE
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _read_buf
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_read_buf PROC						; COMDAT

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 997  :     unsigned len = strm->avail_in;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 998  : 
; 999  :     if (len > size) len = size;

  0000b	3b 4d 10	 cmp	 ecx, DWORD PTR _size$[ebp]
  0000e	8b f9		 mov	 edi, ecx
  00010	0f 47 7d 10	 cmova	 edi, DWORD PTR _size$[ebp]

; 1000 :     if (len == 0) return 0;

  00014	85 ff		 test	 edi, edi
  00016	75 06		 jne	 SHORT $LN4@read_buf
  00018	5f		 pop	 edi
  00019	33 c0		 xor	 eax, eax
  0001b	5e		 pop	 esi

; 1017 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN4@read_buf:

; 1001 : 
; 1002 :     strm->avail_in  -= len;
; 1003 : 
; 1004 :     if (strm->state->wrap == 1) {

  0001e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00021	2b cf		 sub	 ecx, edi
  00023	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00026	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00029	83 f8 01	 cmp	 eax, 1
  0002c	75 0d		 jne	 SHORT $LN3@read_buf

; 1005 :         strm->adler = adler32(strm->adler, strm->next_in, len);

  0002e	57		 push	 edi
  0002f	ff 36		 push	 DWORD PTR [esi]
  00031	ff 76 30	 push	 DWORD PTR [esi+48]
  00034	e8 00 00 00 00	 call	 _adler32
  00039	eb 10		 jmp	 SHORT $LN8@read_buf
$LN3@read_buf:

; 1006 :     }
; 1007 : #ifdef GZIP
; 1008 :     else if (strm->state->wrap == 2) {

  0003b	83 f8 02	 cmp	 eax, 2
  0003e	75 11		 jne	 SHORT $LN1@read_buf

; 1009 :         strm->adler = crc32(strm->adler, strm->next_in, len);

  00040	57		 push	 edi
  00041	ff 36		 push	 DWORD PTR [esi]
  00043	ff 76 30	 push	 DWORD PTR [esi+48]
  00046	e8 00 00 00 00	 call	 _crc32
$LN8@read_buf:
  0004b	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@read_buf:

; 1010 :     }
; 1011 : #endif
; 1012 :     zmemcpy(buf, strm->next_in, len);

  00051	57		 push	 edi
  00052	ff 36		 push	 DWORD PTR [esi]
  00054	ff 75 0c	 push	 DWORD PTR _buf$[ebp]
  00057	e8 00 00 00 00	 call	 _memcpy

; 1013 :     strm->next_in  += len;

  0005c	01 3e		 add	 DWORD PTR [esi], edi
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1014 :     strm->total_in += len;

  00061	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1015 : 
; 1016 :     return (int)len;

  00064	8b c7		 mov	 eax, edi
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 1017 : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _flush_pending
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_flush_pending PROC					; COMDAT

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 565  :     unsigned len = strm->state->pending;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0000b	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 566  : 
; 567  :     if (len > strm->avail_out) len = strm->avail_out;

  0000e	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  00011	0f 47 77 10	 cmova	 esi, DWORD PTR [edi+16]

; 568  :     if (len == 0) return;

  00015	85 f6		 test	 esi, esi
  00017	74 33		 je	 SHORT $LN1@flush_pend

; 569  : 
; 570  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  00019	56		 push	 esi
  0001a	ff 71 10	 push	 DWORD PTR [ecx+16]
  0001d	ff 77 0c	 push	 DWORD PTR [edi+12]
  00020	e8 00 00 00 00	 call	 _memcpy

; 571  :     strm->next_out  += len;
; 572  :     strm->state->pending_out  += len;

  00025	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00028	01 77 0c	 add	 DWORD PTR [edi+12], esi
  0002b	01 70 10	 add	 DWORD PTR [eax+16], esi

; 573  :     strm->total_out += len;
; 574  :     strm->avail_out  -= len;
; 575  :     strm->state->pending -= len;

  0002e	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00031	01 77 14	 add	 DWORD PTR [edi+20], esi
  00034	29 77 10	 sub	 DWORD PTR [edi+16], esi
  00037	29 70 14	 sub	 DWORD PTR [eax+20], esi

; 576  :     if (strm->state->pending == 0) {

  0003a	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00044	75 06		 jne	 SHORT $LN1@flush_pend

; 577  :         strm->state->pending_out = strm->state->pending_buf;

  00046	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00049	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@flush_pend:
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 578  :     }
; 579  : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _putShortMSB
_TEXT	SEGMENT
_s$ = 8							; size = 4
_b$ = 12						; size = 4
_putShortMSB PROC					; COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 552  :     put_byte(s, (Byte)(b >> 8));

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _b$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000b	8b d3		 mov	 edx, ebx
  0000d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00010	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00013	c1 ea 08	 shr	 edx, 8
  00016	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00019	ff 46 14	 inc	 DWORD PTR [esi+20]
  0001c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 553  :     put_byte(s, (Byte)(b & 0xff));

  0001f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00022	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  00025	ff 46 14	 inc	 DWORD PTR [esi+20]
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx

; 554  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _lm_init
_TEXT	SEGMENT
_s$ = 8							; size = 4
_lm_init PROC						; COMDAT

; 1024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1025 :     s->window_size = (ulg)2L*s->w_size;

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]

; 1026 : 
; 1027 :     CLEAR_HASH(s);

  00007	33 d2		 xor	 edx, edx
  00009	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000c	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0000f	03 c0		 add	 eax, eax
  00011	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00014	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00017	66 89 54 48 fe	 mov	 WORD PTR [eax+ecx*2-2], dx
  0001c	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0001f	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR [eax*2-2]
  00026	50		 push	 eax
  00027	52		 push	 edx
  00028	ff 76 44	 push	 DWORD PTR [esi+68]
  0002b	e8 00 00 00 00	 call	 _memset

; 1028 : 
; 1029 :     /* Set the default configuration parameters:
; 1030 :      */
; 1031 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00030	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0003c	0f b7 04 8d 02
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+2]
  00044	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 1032 :     s->good_match       = configuration_table[s->level].good_length;

  0004a	0f b7 04 8d 00
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4]
  00052	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 1033 :     s->nice_match       = configuration_table[s->level].nice_length;

  00058	0f b7 04 8d 04
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+4]
  00060	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 1034 :     s->max_chain_length = configuration_table[s->level].max_chain;

  00066	0f b7 04 8d 06
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+6]
  0006e	89 46 7c	 mov	 DWORD PTR [esi+124], eax

; 1035 : 
; 1036 :     s->strstart = 0;

  00071	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 1037 :     s->block_start = 0L;

  00078	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 1038 :     s->lookahead = 0;

  0007f	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 1039 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00086	c7 46 78 02 00
	00 00		 mov	 DWORD PTR [esi+120], 2
  0008d	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2

; 1040 :     s->match_available = 0;

  00094	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 1041 :     s->ins_h = 0;

  0009b	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  000a2	5e		 pop	 esi

; 1045 : #endif
; 1046 : #endif
; 1047 : }

  000a3	5d		 pop	 ebp

; 1042 : #ifndef FASTEST
; 1043 : #ifdef ASMV
; 1044 :     match_init(); /* initialize the asm code */

  000a4	e9 00 00 00 00	 jmp	 _match_init
_lm_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate_huff
_TEXT	SEGMENT
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_huff PROC					; COMDAT

; 1810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	57		 push	 edi
$LL8@deflate_hu:

; 1811 :     int bflush;             /* set if current block must be flushed */
; 1812 : 
; 1813 :     for (;;) {
; 1814 :         /* Make sure that we have a literal to write. */
; 1815 :         if (s->lookahead == 0) {

  00008	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  0000c	75 13		 jne	 SHORT $LN5@deflate_hu

; 1816 :             fill_window(s);

  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _fill_window
  00014	83 c4 04	 add	 esp, 4

; 1817 :             if (s->lookahead == 0) {

  00017	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  0001b	0f 84 97 00 00
	00		 je	 $LN17@deflate_hu
$LN5@deflate_hu:

; 1819 :                     return need_more;
; 1820 :                 break;      /* flush the current block */
; 1821 :             }
; 1822 :         }
; 1823 : 
; 1824 :         /* Output a literal byte */
; 1825 :         s->match_length = 0;
; 1826 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1827 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00021	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00024	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00027	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  0002e	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00031	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00037	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0003d	33 ff		 xor	 edi, edi
  0003f	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00043	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00049	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0004f	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00052	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00058	0f b6 c2	 movzx	 eax, dl
  0005b	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  00063	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]

; 1828 :         s->lookahead--;
; 1829 :         s->strstart++;

  00069	ff 46 6c	 inc	 DWORD PTR [esi+108]
  0006c	ff 4e 74	 dec	 DWORD PTR [esi+116]
  0006f	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00072	48		 dec	 eax
  00073	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1830 :         if (bflush) FLUSH_BLOCK(s, 0);

  00079	75 8d		 jne	 SHORT $LL8@deflate_hu
  0007b	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0007e	85 c9		 test	 ecx, ecx
  00080	78 07		 js	 SHORT $LN11@deflate_hu
  00082	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00085	03 c1		 add	 eax, ecx
  00087	eb 02		 jmp	 SHORT $LN12@deflate_hu
$LN11@deflate_hu:
  00089	33 c0		 xor	 eax, eax
$LN12@deflate_hu:
  0008b	6a 00		 push	 0
  0008d	2b d1		 sub	 edx, ecx
  0008f	52		 push	 edx
  00090	50		 push	 eax
  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 __tr_flush_block
  00097	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0009a	ff 36		 push	 DWORD PTR [esi]
  0009c	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0009f	e8 00 00 00 00	 call	 _flush_pending
  000a4	8b 06		 mov	 eax, DWORD PTR [esi]
  000a6	83 c4 14	 add	 esp, 20			; 00000014H
  000a9	39 78 10	 cmp	 DWORD PTR [eax+16], edi
  000ac	0f 85 56 ff ff
	ff		 jne	 $LL8@deflate_hu
$LN18@deflate_hu:
  000b2	5f		 pop	 edi
  000b3	33 c0		 xor	 eax, eax
  000b5	5e		 pop	 esi

; 1834 : }

  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN17@deflate_hu:

; 1818 :                 if (flush == Z_NO_FLUSH)

  000b8	8b 7d 0c	 mov	 edi, DWORD PTR _flush$[ebp]
  000bb	85 ff		 test	 edi, edi
  000bd	74 f3		 je	 SHORT $LN18@deflate_hu

; 1831 :     }
; 1832 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  000bf	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  000c2	85 d2		 test	 edx, edx
  000c4	78 07		 js	 SHORT $LN13@deflate_hu
  000c6	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000c9	03 ca		 add	 ecx, edx
  000cb	eb 02		 jmp	 SHORT $LN14@deflate_hu
$LN13@deflate_hu:
  000cd	33 c9		 xor	 ecx, ecx
$LN14@deflate_hu:
  000cf	33 c0		 xor	 eax, eax
  000d1	83 ff 04	 cmp	 edi, 4
  000d4	0f 94 c0	 sete	 al
  000d7	50		 push	 eax
  000d8	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000db	2b c2		 sub	 eax, edx
  000dd	50		 push	 eax
  000de	51		 push	 ecx
  000df	56		 push	 esi
  000e0	e8 00 00 00 00	 call	 __tr_flush_block
  000e5	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000e8	ff 36		 push	 DWORD PTR [esi]
  000ea	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000ed	e8 00 00 00 00	 call	 _flush_pending
  000f2	8b 06		 mov	 eax, DWORD PTR [esi]
  000f4	83 c4 14	 add	 esp, 20			; 00000014H
  000f7	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000fb	75 11		 jne	 SHORT $LN1@deflate_hu
  000fd	33 c0		 xor	 eax, eax
  000ff	83 ff 04	 cmp	 edi, 4
  00102	b9 02 00 00 00	 mov	 ecx, 2
  00107	5f		 pop	 edi
  00108	0f 44 c1	 cmove	 eax, ecx
  0010b	5e		 pop	 esi

; 1834 : }

  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN1@deflate_hu:

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;

  0010e	33 c0		 xor	 eax, eax
  00110	83 ff 04	 cmp	 edi, 4
  00113	0f 94 c0	 sete	 al
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]

; 1834 : }

  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
_deflate_huff ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate_rle
_TEXT	SEGMENT
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_rle PROC					; COMDAT

; 1744 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000b	57		 push	 edi
  0000c	8d 64 24 00	 npad	 4
$LL17@deflate_rl:

; 1745 :     int bflush;             /* set if current block must be flushed */
; 1746 :     uInt prev;              /* byte at distance one to match */
; 1747 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1748 : 
; 1749 :     for (;;) {
; 1750 :         /* Make sure that we always have enough lookahead, except
; 1751 :          * at the end of the input file. We need MAX_MATCH bytes
; 1752 :          * for the longest encodable run.
; 1753 :          */
; 1754 :         if (s->lookahead < MAX_MATCH) {

  00010	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00013	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  00019	73 24		 jae	 SHORT $LN13@deflate_rl

; 1755 :             fill_window(s);

  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 _fill_window

; 1756 :             if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {

  00021	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00024	83 c4 04	 add	 esp, 4
  00027	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  0002d	73 08		 jae	 SHORT $LN14@deflate_rl
  0002f	85 db		 test	 ebx, ebx
  00031	0f 84 c5 01 00
	00		 je	 $LN31@deflate_rl
$LN14@deflate_rl:

; 1757 :                 return need_more;
; 1758 :             }
; 1759 :             if (s->lookahead == 0) break; /* flush the current block */

  00037	85 ff		 test	 edi, edi
  00039	0f 84 c4 01 00
	00		 je	 $LN30@deflate_rl
$LN13@deflate_rl:

; 1760 :         }
; 1761 : 
; 1762 :         /* See how many times the previous byte repeats */
; 1763 :         s->match_length = 0;

  0003f	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 1764 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  00046	83 ff 03	 cmp	 edi, 3
  00049	0f 82 9c 00 00
	00		 jb	 $LN6@deflate_rl
  0004f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00052	85 c9		 test	 ecx, ecx
  00054	0f 84 91 00 00
	00		 je	 $LN6@deflate_rl

; 1765 :             scan = s->window + s->strstart - 1;

  0005a	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  0005d	03 d9		 add	 ebx, ecx

; 1766 :             prev = *scan;
; 1767 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  0005f	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  00062	0f b6 53 ff	 movzx	 edx, BYTE PTR [ebx-1]
  00066	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00069	3b d1		 cmp	 edx, ecx
  0006b	75 7b		 jne	 SHORT $LN36@deflate_rl
  0006d	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00071	3b d1		 cmp	 edx, ecx
  00073	75 73		 jne	 SHORT $LN36@deflate_rl
  00075	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00079	83 c0 03	 add	 eax, 3
  0007c	3b d1		 cmp	 edx, ecx
  0007e	75 68		 jne	 SHORT $LN36@deflate_rl

; 1768 :                 strend = s->window + s->strstart + MAX_MATCH;

  00080	81 c3 02 01 00
	00		 add	 ebx, 258		; 00000102H
$LL10@deflate_rl:

; 1769 :                 do {
; 1770 :                 } while (prev == *++scan && prev == *++scan &&
; 1771 :                          prev == *++scan && prev == *++scan &&
; 1772 :                          prev == *++scan && prev == *++scan &&
; 1773 :                          prev == *++scan && prev == *++scan &&
; 1774 :                          scan < strend);

  00086	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0008a	40		 inc	 eax
  0008b	3b d1		 cmp	 edx, ecx
  0008d	75 43		 jne	 SHORT $LN7@deflate_rl
  0008f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00093	40		 inc	 eax
  00094	3b d1		 cmp	 edx, ecx
  00096	75 3a		 jne	 SHORT $LN7@deflate_rl
  00098	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0009c	40		 inc	 eax
  0009d	3b d1		 cmp	 edx, ecx
  0009f	75 31		 jne	 SHORT $LN7@deflate_rl
  000a1	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000a5	40		 inc	 eax
  000a6	3b d1		 cmp	 edx, ecx
  000a8	75 28		 jne	 SHORT $LN7@deflate_rl
  000aa	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000ae	40		 inc	 eax
  000af	3b d1		 cmp	 edx, ecx
  000b1	75 1f		 jne	 SHORT $LN7@deflate_rl
  000b3	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000b7	40		 inc	 eax
  000b8	3b d1		 cmp	 edx, ecx
  000ba	75 16		 jne	 SHORT $LN7@deflate_rl
  000bc	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000c0	40		 inc	 eax
  000c1	3b d1		 cmp	 edx, ecx
  000c3	75 0d		 jne	 SHORT $LN7@deflate_rl
  000c5	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000c9	40		 inc	 eax
  000ca	3b d1		 cmp	 edx, ecx
  000cc	75 04		 jne	 SHORT $LN7@deflate_rl
  000ce	3b c3		 cmp	 eax, ebx
  000d0	72 b4		 jb	 SHORT $LL10@deflate_rl
$LN7@deflate_rl:

; 1775 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  000d2	2b c3		 sub	 eax, ebx
  000d4	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  000d7	05 02 01 00 00	 add	 eax, 258		; 00000102H
  000dc	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1776 :                 if (s->match_length > s->lookahead)

  000df	3b c7		 cmp	 eax, edi
  000e1	76 08		 jbe	 SHORT $LN6@deflate_rl

; 1777 :                     s->match_length = s->lookahead;

  000e3	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  000e6	eb 03		 jmp	 SHORT $LN6@deflate_rl
$LN36@deflate_rl:
  000e8	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
$LN6@deflate_rl:

; 1778 :             }
; 1779 :         }
; 1780 : 
; 1781 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1782 :         if (s->match_length >= MIN_MATCH) {

  000eb	83 7e 60 03	 cmp	 DWORD PTR [esi+96], 3
  000ef	72 75		 jb	 SHORT $LN5@deflate_rl

; 1783 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1784 : 
; 1785 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  000f1	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  000f7	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  000fd	8a 56 60	 mov	 dl, BYTE PTR [esi+96]
  00100	bf 01 00 00 00	 mov	 edi, 1
  00105	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00109	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  0010f	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00115	80 ea 03	 sub	 dl, 3
  00118	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0011b	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00121	0f b6 c2	 movzx	 eax, dl
  00124	33 c9		 xor	 ecx, ecx
  00126	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  0012d	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  00135	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code
  0013c	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  00144	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  0014a	48		 dec	 eax
  0014b	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1786 : 
; 1787 :             s->lookahead -= s->match_length;

  00151	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00154	0f 94 c1	 sete	 cl
  00157	29 46 74	 sub	 DWORD PTR [esi+116], eax

; 1788 :             s->strstart += s->match_length;

  0015a	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1789 :             s->match_length = 0;

  0015d	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 1790 :         } else {

  00164	eb 53		 jmp	 SHORT $LN4@deflate_rl
$LN5@deflate_rl:

; 1791 :             /* No match, output a literal byte */
; 1792 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1793 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00166	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00169	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0016c	33 ff		 xor	 edi, edi
  0016e	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00171	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00177	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0017d	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00181	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00187	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0018d	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00190	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00196	0f b6 c2	 movzx	 eax, dl
  00199	33 c9		 xor	 ecx, ecx
  0019b	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  001a3	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  001a9	48		 dec	 eax
  001aa	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  001b0	0f 94 c1	 sete	 cl

; 1794 :             s->lookahead--;

  001b3	ff 4e 74	 dec	 DWORD PTR [esi+116]

; 1795 :             s->strstart++;

  001b6	ff 46 6c	 inc	 DWORD PTR [esi+108]
$LN4@deflate_rl:

; 1796 :         }
; 1797 :         if (bflush) FLUSH_BLOCK(s, 0);

  001b9	85 c9		 test	 ecx, ecx
  001bb	0f 84 4f fe ff
	ff		 je	 $LL17@deflate_rl
  001c1	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  001c4	85 d2		 test	 edx, edx
  001c6	78 07		 js	 SHORT $LN22@deflate_rl
  001c8	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  001cb	03 ca		 add	 ecx, edx
  001cd	eb 02		 jmp	 SHORT $LN23@deflate_rl
$LN22@deflate_rl:
  001cf	33 c9		 xor	 ecx, ecx
$LN23@deflate_rl:
  001d1	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  001d4	6a 00		 push	 0
  001d6	2b c2		 sub	 eax, edx
  001d8	50		 push	 eax
  001d9	51		 push	 ecx
  001da	56		 push	 esi
  001db	e8 00 00 00 00	 call	 __tr_flush_block
  001e0	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  001e3	ff 36		 push	 DWORD PTR [esi]
  001e5	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  001e8	e8 00 00 00 00	 call	 _flush_pending
  001ed	8b 06		 mov	 eax, DWORD PTR [esi]
  001ef	83 c4 14	 add	 esp, 20			; 00000014H
  001f2	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  001f6	0f 85 14 fe ff
	ff		 jne	 $LL17@deflate_rl
$LN31@deflate_rl:
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	33 c0		 xor	 eax, eax
  00200	5b		 pop	 ebx

; 1801 : }

  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
$LN30@deflate_rl:

; 1798 :     }
; 1799 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00203	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00206	85 d2		 test	 edx, edx
  00208	78 07		 js	 SHORT $LN24@deflate_rl
  0020a	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0020d	03 ca		 add	 ecx, edx
  0020f	eb 02		 jmp	 SHORT $LN25@deflate_rl
$LN24@deflate_rl:
  00211	33 c9		 xor	 ecx, ecx
$LN25@deflate_rl:
  00213	33 c0		 xor	 eax, eax
  00215	83 fb 04	 cmp	 ebx, 4
  00218	0f 94 c0	 sete	 al
  0021b	50		 push	 eax
  0021c	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0021f	2b c2		 sub	 eax, edx
  00221	50		 push	 eax
  00222	51		 push	 ecx
  00223	56		 push	 esi
  00224	e8 00 00 00 00	 call	 __tr_flush_block
  00229	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0022c	ff 36		 push	 DWORD PTR [esi]
  0022e	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00231	e8 00 00 00 00	 call	 _flush_pending
  00236	8b 06		 mov	 eax, DWORD PTR [esi]
  00238	83 c4 14	 add	 esp, 20			; 00000014H
  0023b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0023f	75 12		 jne	 SHORT $LN1@deflate_rl
  00241	5f		 pop	 edi
  00242	33 c0		 xor	 eax, eax
  00244	83 fb 04	 cmp	 ebx, 4
  00247	b9 02 00 00 00	 mov	 ecx, 2
  0024c	5e		 pop	 esi
  0024d	0f 44 c1	 cmove	 eax, ecx
  00250	5b		 pop	 ebx

; 1801 : }

  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
$LN1@deflate_rl:

; 1800 :     return flush == Z_FINISH ? finish_done : block_done;

  00253	33 c0		 xor	 eax, eax
  00255	83 fb 04	 cmp	 ebx, 4
  00258	0f 94 c0	 sete	 al
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx
  0025e	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]

; 1801 : }

  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
_deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate_slow
_TEXT	SEGMENT
_bflush$1$ = -4						; size = 4
_max_insert$1$ = 8					; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_slow PROC					; COMDAT

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000c	57		 push	 edi
  0000d	8d 49 00	 npad	 3
$LL23@deflate_sl:

; 1620 :     IPos hash_head;          /* head of hash chain */
; 1621 :     int bflush;              /* set if current block must be flushed */
; 1622 : 
; 1623 :     /* Process the input block. */
; 1624 :     for (;;) {
; 1625 :         /* Make sure that we always have enough lookahead, except
; 1626 :          * at the end of the input file. We need MAX_MATCH bytes
; 1627 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1628 :          * string following the next match.
; 1629 :          */
; 1630 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00013	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00018	73 23		 jae	 SHORT $LN19@deflate_sl

; 1631 :             fill_window(s);

  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _fill_window

; 1632 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00020	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00023	83 c4 04	 add	 esp, 4
  00026	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0002b	73 08		 jae	 SHORT $LN20@deflate_sl
  0002d	85 db		 test	 ebx, ebx
  0002f	0f 84 2f 02 00
	00		 je	 $LN40@deflate_sl
$LN20@deflate_sl:

; 1633 :                 return need_more;
; 1634 :             }
; 1635 :             if (s->lookahead == 0) break; /* flush the current block */

  00035	85 c0		 test	 eax, eax
  00037	0f 84 e0 02 00
	00		 je	 $LN38@deflate_sl
$LN19@deflate_sl:

; 1636 :         }
; 1637 : 
; 1638 :         /* Insert the string window[strstart .. strstart+2] in the
; 1639 :          * dictionary, and set hash_head to the head of the hash chain:
; 1640 :          */
; 1641 :         hash_head = NIL;

  0003d	33 ff		 xor	 edi, edi

; 1642 :         if (s->lookahead >= MIN_MATCH) {

  0003f	83 f8 03	 cmp	 eax, 3
  00042	72 4c		 jb	 SHORT $LN18@deflate_sl

; 1643 :             INSERT_STRING(s, s->strstart, hash_head);

  00044	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
  00047	8b 5e 48	 mov	 ebx, DWORD PTR [esi+72]
  0004a	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0004d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00050	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00053	0f b6 44 38 02	 movzx	 eax, BYTE PTR [eax+edi+2]
  00058	d3 e3		 shl	 ebx, cl
  0005a	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0005d	23 d7		 and	 edx, edi
  0005f	33 d8		 xor	 ebx, eax
  00061	23 5e 54	 and	 ebx, DWORD PTR [esi+84]
  00064	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00067	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  0006a	0f b7 04 58	 movzx	 eax, WORD PTR [eax+ebx*2]
  0006e	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00071	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00075	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00078	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  0007b	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0007e	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00081	0f b7 3c 48	 movzx	 edi, WORD PTR [eax+ecx*2]
  00085	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  00089	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0008c	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
$LN18@deflate_sl:

; 1644 :         }
; 1645 : 
; 1646 :         /* Find the longest match, discarding those <= prev_length.
; 1647 :          */
; 1648 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  00090	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00093	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00096	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00099	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 1649 :         s->match_length = MIN_MATCH-1;

  0009c	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2

; 1650 : 
; 1651 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1652 :             s->strstart - hash_head <= MAX_DIST(s)) {

  000a3	85 ff		 test	 edi, edi
  000a5	74 50		 je	 SHORT $LN16@deflate_sl
  000a7	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  000aa	3b 86 80 00 00
	00		 cmp	 eax, DWORD PTR [esi+128]
  000b0	73 45		 jae	 SHORT $LN16@deflate_sl
  000b2	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  000b5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b8	2b cf		 sub	 ecx, edi
  000ba	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000bf	3b c8		 cmp	 ecx, eax
  000c1	77 34		 ja	 SHORT $LN16@deflate_sl

; 1653 :             /* To simplify the code, we prevent matches with the string
; 1654 :              * of window index 0 (in particular we have to avoid a match
; 1655 :              * of the string with itself at the start of the input file).
; 1656 :              */
; 1657 :             s->match_length = longest_match (s, hash_head);

  000c3	57		 push	 edi
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 _longest_match
  000ca	83 c4 08	 add	 esp, 8
  000cd	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1658 :             /* longest_match() sets match_start */
; 1659 : 
; 1660 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1661 : #if TOO_FAR <= 32767
; 1662 :                 || (s->match_length == MIN_MATCH &&
; 1663 :                     s->strstart - s->match_start > TOO_FAR)
; 1664 : #endif
; 1665 :                 )) {

  000d0	83 f8 05	 cmp	 eax, 5
  000d3	77 22		 ja	 SHORT $LN16@deflate_sl
  000d5	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  000dc	74 12		 je	 SHORT $LN15@deflate_sl
  000de	83 f8 03	 cmp	 eax, 3
  000e1	75 14		 jne	 SHORT $LN16@deflate_sl
  000e3	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000e6	2b 46 70	 sub	 eax, DWORD PTR [esi+112]
  000e9	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000ee	76 07		 jbe	 SHORT $LN16@deflate_sl
$LN15@deflate_sl:

; 1666 : 
; 1667 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1668 :                  * but we will ignore the current match anyway.
; 1669 :                  */
; 1670 :                 s->match_length = MIN_MATCH-1;

  000f0	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2
$LN16@deflate_sl:

; 1671 :             }
; 1672 :         }
; 1673 :         /* If there was a match at the previous step and the current
; 1674 :          * match is not better, output the previous match:
; 1675 :          */
; 1676 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  000f7	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  000fa	83 f8 03	 cmp	 eax, 3
  000fd	0f 82 6a 01 00
	00		 jb	 $LN14@deflate_sl
  00103	39 46 60	 cmp	 DWORD PTR [esi+96], eax
  00106	0f 87 61 01 00
	00		 ja	 $LN14@deflate_sl

; 1677 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0010c	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0010f	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]

; 1678 :             /* Do not insert strings in hash table beyond this. */
; 1679 : 
; 1680 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1681 : 
; 1682 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1683 :                            s->prev_length - MIN_MATCH, bflush);

  00112	8a d0		 mov	 dl, al
  00114	66 8b 46 6c	 mov	 ax, WORD PTR [esi+108]
  00118	66 2b 46 64	 sub	 ax, WORD PTR [esi+100]
  0011c	83 c1 fd	 add	 ecx, -3			; fffffffdH
  0011f	66 48		 dec	 ax
  00121	0f b7 d8	 movzx	 ebx, ax
  00124	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0012a	03 f9		 add	 edi, ecx
  0012c	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00132	80 ea 03	 sub	 dl, 3
  00135	66 89 1c 48	 mov	 WORD PTR [eax+ecx*2], bx
  00139	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  0013f	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00145	81 c3 ff ff 00
	00		 add	 ebx, 65535		; 0000ffffH
  0014b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0014e	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00154	0f b6 c2	 movzx	 eax, dl
  00157	89 7d 08	 mov	 DWORD PTR _max_insert$1$[ebp], edi
  0015a	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  00161	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  00169	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0016e	66 3b d8	 cmp	 bx, ax
  00171	0f b7 c3	 movzx	 eax, bx
  00174	73 09		 jae	 SHORT $LN26@deflate_sl
  00176	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax]
  0017d	eb 0a		 jmp	 SHORT $LN27@deflate_sl
$LN26@deflate_sl:
  0017f	c1 e8 07	 shr	 eax, 7
  00182	0f b6 80 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax+256]
$LN27@deflate_sl:
  00189	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  00191	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00197	48		 dec	 eax
  00198	33 c9		 xor	 ecx, ecx
  0019a	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1684 : 
; 1685 :             /* Insert in hash table all strings up to the end of the match.
; 1686 :              * strstart-1 and strstart are already inserted. If there is not
; 1687 :              * enough lookahead, the last two strings are not inserted in
; 1688 :              * the hash table.
; 1689 :              */
; 1690 :             s->lookahead -= s->prev_length-1;

  001a0	b8 01 00 00 00	 mov	 eax, 1
  001a5	0f 94 c1	 sete	 cl
  001a8	89 4d fc	 mov	 DWORD PTR _bflush$1$[ebp], ecx
  001ab	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  001ae	2b c1		 sub	 eax, ecx
  001b0	01 46 74	 add	 DWORD PTR [esi+116], eax

; 1691 :             s->prev_length -= 2;

  001b3	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  001b6	89 46 78	 mov	 DWORD PTR [esi+120], eax
  001b9	8d a4 24 00 00
	00 00		 npad	 7
$LL13@deflate_sl:

; 1692 :             do {
; 1693 :                 if (++s->strstart <= max_insert) {

  001c0	ff 46 6c	 inc	 DWORD PTR [esi+108]
  001c3	8b 5e 6c	 mov	 ebx, DWORD PTR [esi+108]
  001c6	3b df		 cmp	 ebx, edi
  001c8	77 3c		 ja	 SHORT $LN12@deflate_sl

; 1694 :                     INSERT_STRING(s, s->strstart, hash_head);

  001ca	8b 7e 48	 mov	 edi, DWORD PTR [esi+72]
  001cd	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001d0	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001d3	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  001d6	0f b6 44 18 02	 movzx	 eax, BYTE PTR [eax+ebx+2]
  001db	d3 e7		 shl	 edi, cl
  001dd	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  001e0	33 f8		 xor	 edi, eax
  001e2	23 7e 54	 and	 edi, DWORD PTR [esi+84]
  001e5	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  001e8	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  001eb	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  001ef	8b 7d 08	 mov	 edi, DWORD PTR _max_insert$1$[ebp]
  001f2	23 d3		 and	 edx, ebx
  001f4	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  001f8	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  001fc	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  001ff	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00202	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
$LN12@deflate_sl:

; 1695 :                 }
; 1696 :             } while (--s->prev_length != 0);

  00206	ff 4e 78	 dec	 DWORD PTR [esi+120]
  00209	75 b5		 jne	 SHORT $LL13@deflate_sl

; 1697 :             s->match_available = 0;
; 1698 :             s->match_length = MIN_MATCH-1;
; 1699 :             s->strstart++;

  0020b	ff 46 6c	 inc	 DWORD PTR [esi+108]

; 1700 : 
; 1701 :             if (bflush) FLUSH_BLOCK(s, 0);

  0020e	83 7d fc 00	 cmp	 DWORD PTR _bflush$1$[ebp], 0
  00212	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00215	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00218	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  0021f	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2
  00226	0f 84 e4 fd ff
	ff		 je	 $LL23@deflate_sl
  0022c	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0022f	85 c9		 test	 ecx, ecx
  00231	78 07		 js	 SHORT $LN28@deflate_sl
  00233	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00236	03 c1		 add	 eax, ecx
  00238	eb 02		 jmp	 SHORT $LN29@deflate_sl
$LN28@deflate_sl:
  0023a	33 c0		 xor	 eax, eax
$LN29@deflate_sl:
  0023c	6a 00		 push	 0
  0023e	2b d1		 sub	 edx, ecx
  00240	52		 push	 edx
  00241	50		 push	 eax
  00242	56		 push	 esi
  00243	e8 00 00 00 00	 call	 __tr_flush_block
  00248	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0024b	ff 36		 push	 DWORD PTR [esi]
  0024d	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00250	e8 00 00 00 00	 call	 _flush_pending
  00255	8b 06		 mov	 eax, DWORD PTR [esi]
  00257	83 c4 14	 add	 esp, 20			; 00000014H
  0025a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0025e	0f 85 ac fd ff
	ff		 jne	 $LL23@deflate_sl
$LN40@deflate_sl:
  00264	5f		 pop	 edi
  00265	5e		 pop	 esi

; 1712 :             }
; 1713 :             s->strstart++;
; 1714 :             s->lookahead--;
; 1715 :             if (s->strm->avail_out == 0) return need_more;

  00266	33 c0		 xor	 eax, eax
  00268	5b		 pop	 ebx

; 1733 : }

  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c3		 ret	 0
$LN14@deflate_sl:

; 1702 : 
; 1703 :         } else if (s->match_available) {

  0026d	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00271	0f 84 94 00 00
	00		 je	 $LN6@deflate_sl

; 1704 :             /* If there was no match at the previous position, output a
; 1705 :              * single literal. If there was a match but the current match
; 1706 :              * is longer, truncate the previous match to a single literal.
; 1707 :              */
; 1708 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1709 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00277	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0027a	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0027d	33 ff		 xor	 edi, edi
  0027f	8a 54 01 ff	 mov	 dl, BYTE PTR [ecx+eax-1]
  00283	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00289	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0028f	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00293	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00299	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0029f	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  002a2	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  002a8	0f b6 c2	 movzx	 eax, dl
  002ab	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  002b3	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  002b9	48		 dec	 eax
  002ba	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1710 :             if (bflush) {

  002c0	75 2f		 jne	 SHORT $LN5@deflate_sl

; 1711 :                 FLUSH_BLOCK_ONLY(s, 0);

  002c2	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  002c5	85 d2		 test	 edx, edx
  002c7	78 07		 js	 SHORT $LN30@deflate_sl
  002c9	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  002cc	03 ca		 add	 ecx, edx
  002ce	eb 02		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  002d0	33 c9		 xor	 ecx, ecx
$LN31@deflate_sl:
  002d2	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  002d5	6a 00		 push	 0
  002d7	2b c2		 sub	 eax, edx
  002d9	50		 push	 eax
  002da	51		 push	 ecx
  002db	56		 push	 esi
  002dc	e8 00 00 00 00	 call	 __tr_flush_block
  002e1	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  002e4	ff 36		 push	 DWORD PTR [esi]
  002e6	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  002e9	e8 00 00 00 00	 call	 _flush_pending
  002ee	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;
; 1714 :             s->lookahead--;
; 1715 :             if (s->strm->avail_out == 0) return need_more;

  002f1	8b 06		 mov	 eax, DWORD PTR [esi]
  002f3	ff 46 6c	 inc	 DWORD PTR [esi+108]
  002f6	ff 4e 74	 dec	 DWORD PTR [esi+116]
  002f9	39 78 10	 cmp	 DWORD PTR [eax+16], edi
  002fc	0f 85 0e fd ff
	ff		 jne	 $LL23@deflate_sl
  00302	5f		 pop	 edi
  00303	5e		 pop	 esi
  00304	33 c0		 xor	 eax, eax
  00306	5b		 pop	 ebx

; 1733 : }

  00307	8b e5		 mov	 esp, ebp
  00309	5d		 pop	 ebp
  0030a	c3		 ret	 0
$LN6@deflate_sl:

; 1716 :         } else {
; 1717 :             /* There is no previous match to compare with, wait for
; 1718 :              * the next step to decide.
; 1719 :              */
; 1720 :             s->match_available = 1;
; 1721 :             s->strstart++;

  0030b	ff 46 6c	 inc	 DWORD PTR [esi+108]

; 1722 :             s->lookahead--;

  0030e	ff 4e 74	 dec	 DWORD PTR [esi+116]
  00311	c7 46 68 01 00
	00 00		 mov	 DWORD PTR [esi+104], 1

; 1723 :         }
; 1724 :     }

  00318	e9 f3 fc ff ff	 jmp	 $LL23@deflate_sl
$LN38@deflate_sl:

; 1725 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1726 :     if (s->match_available) {

  0031d	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00321	74 3f		 je	 SHORT $LN2@deflate_sl

; 1727 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1728 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00323	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00326	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00329	33 ff		 xor	 edi, edi
  0032b	8a 54 01 ff	 mov	 dl, BYTE PTR [ecx+eax-1]
  0032f	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00335	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0033b	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  0033f	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00345	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0034b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0034e	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00354	0f b6 c2	 movzx	 eax, dl
  00357	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]

; 1729 :         s->match_available = 0;

  0035f	89 7e 68	 mov	 DWORD PTR [esi+104], edi
$LN2@deflate_sl:

; 1730 :     }
; 1731 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00362	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00365	85 d2		 test	 edx, edx
  00367	78 07		 js	 SHORT $LN32@deflate_sl
  00369	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0036c	03 ca		 add	 ecx, edx
  0036e	eb 02		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  00370	33 c9		 xor	 ecx, ecx
$LN33@deflate_sl:
  00372	33 c0		 xor	 eax, eax
  00374	83 fb 04	 cmp	 ebx, 4
  00377	0f 94 c0	 sete	 al
  0037a	50		 push	 eax
  0037b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0037e	2b c2		 sub	 eax, edx
  00380	50		 push	 eax
  00381	51		 push	 ecx
  00382	56		 push	 esi
  00383	e8 00 00 00 00	 call	 __tr_flush_block
  00388	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0038b	ff 36		 push	 DWORD PTR [esi]
  0038d	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00390	e8 00 00 00 00	 call	 _flush_pending
  00395	8b 06		 mov	 eax, DWORD PTR [esi]
  00397	83 c4 14	 add	 esp, 20			; 00000014H
  0039a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0039e	75 14		 jne	 SHORT $LN1@deflate_sl
  003a0	5f		 pop	 edi
  003a1	33 c0		 xor	 eax, eax
  003a3	83 fb 04	 cmp	 ebx, 4
  003a6	b9 02 00 00 00	 mov	 ecx, 2
  003ab	5e		 pop	 esi
  003ac	0f 44 c1	 cmove	 eax, ecx
  003af	5b		 pop	 ebx

; 1733 : }

  003b0	8b e5		 mov	 esp, ebp
  003b2	5d		 pop	 ebp
  003b3	c3		 ret	 0
$LN1@deflate_sl:

; 1732 :     return flush == Z_FINISH ? finish_done : block_done;

  003b4	33 c0		 xor	 eax, eax
  003b6	83 fb 04	 cmp	 ebx, 4
  003b9	0f 94 c0	 sete	 al
  003bc	5f		 pop	 edi
  003bd	5e		 pop	 esi
  003be	5b		 pop	 ebx
  003bf	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]

; 1733 : }

  003c6	8b e5		 mov	 esp, ebp
  003c8	5d		 pop	 ebp
  003c9	c3		 ret	 0
_deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate_fast
_TEXT	SEGMENT
_bflush$1$ = 8						; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_fast PROC					; COMDAT

; 1523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000b	57		 push	 edi
  0000c	8d 64 24 00	 npad	 4
$LL17@deflate_fa:

; 1524 :     IPos hash_head;       /* head of the hash chain */
; 1525 :     int bflush;           /* set if current block must be flushed */
; 1526 : 
; 1527 :     for (;;) {
; 1528 :         /* Make sure that we always have enough lookahead, except
; 1529 :          * at the end of the input file. We need MAX_MATCH bytes
; 1530 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1531 :          * string following the next match.
; 1532 :          */
; 1533 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00013	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00018	73 23		 jae	 SHORT $LN13@deflate_fa

; 1534 :             fill_window(s);

  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _fill_window

; 1535 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00020	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00023	83 c4 04	 add	 esp, 4
  00026	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0002b	73 08		 jae	 SHORT $LN14@deflate_fa
  0002d	85 db		 test	 ebx, ebx
  0002f	0f 84 36 02 00
	00		 je	 $LN31@deflate_fa
$LN14@deflate_fa:

; 1536 :                 return need_more;
; 1537 :             }
; 1538 :             if (s->lookahead == 0) break; /* flush the current block */

  00035	85 c0		 test	 eax, eax
  00037	0f 84 35 02 00
	00		 je	 $LN30@deflate_fa
$LN13@deflate_fa:

; 1539 :         }
; 1540 : 
; 1541 :         /* Insert the string window[strstart .. strstart+2] in the
; 1542 :          * dictionary, and set hash_head to the head of the hash chain:
; 1543 :          */
; 1544 :         hash_head = NIL;
; 1545 :         if (s->lookahead >= MIN_MATCH) {

  0003d	83 f8 03	 cmp	 eax, 3
  00040	72 6b		 jb	 SHORT $LN11@deflate_fa

; 1546 :             INSERT_STRING(s, s->strstart, hash_head);

  00042	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
  00045	8b 5e 48	 mov	 ebx, DWORD PTR [esi+72]
  00048	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0004b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0004e	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00051	0f b6 44 38 02	 movzx	 eax, BYTE PTR [eax+edi+2]
  00056	d3 e3		 shl	 ebx, cl
  00058	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0005b	23 d7		 and	 edx, edi
  0005d	33 d8		 xor	 ebx, eax
  0005f	23 5e 54	 and	 ebx, DWORD PTR [esi+84]
  00062	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00065	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  00068	0f b7 04 58	 movzx	 eax, WORD PTR [eax+ebx*2]
  0006c	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00070	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00073	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  00076	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00079	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  0007c	0f b7 3c 48	 movzx	 edi, WORD PTR [eax+ecx*2]
  00080	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  00084	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00087	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 1547 :         }
; 1548 : 
; 1549 :         /* Find the longest match, discarding those <= prev_length.
; 1550 :          * At this point we have always match_length < MIN_MATCH
; 1551 :          */
; 1552 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  0008b	85 ff		 test	 edi, edi
  0008d	74 1e		 je	 SHORT $LN11@deflate_fa
  0008f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00092	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00095	2b cf		 sub	 ecx, edi
  00097	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0009c	3b c8		 cmp	 ecx, eax
  0009e	77 0d		 ja	 SHORT $LN11@deflate_fa

; 1553 :             /* To simplify the code, we prevent matches with the string
; 1554 :              * of window index 0 (in particular we have to avoid a match
; 1555 :              * of the string with itself at the start of the input file).
; 1556 :              */
; 1557 :             s->match_length = longest_match (s, hash_head);

  000a0	57		 push	 edi
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 _longest_match
  000a7	83 c4 08	 add	 esp, 8
  000aa	89 46 60	 mov	 DWORD PTR [esi+96], eax
$LN11@deflate_fa:

; 1558 :             /* longest_match() sets match_start */
; 1559 :         }
; 1560 :         if (s->match_length >= MIN_MATCH) {

  000ad	83 7e 60 03	 cmp	 DWORD PTR [esi+96], 3
  000b1	0f 82 1b 01 00
	00		 jb	 $LN10@deflate_fa

; 1561 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1562 : 
; 1563 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1564 :                            s->match_length - MIN_MATCH, bflush);

  000b7	66 8b 46 6c	 mov	 ax, WORD PTR [esi+108]
  000bb	66 2b 46 70	 sub	 ax, WORD PTR [esi+112]
  000bf	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  000c5	8a 56 60	 mov	 dl, BYTE PTR [esi+96]
  000c8	0f b7 f8	 movzx	 edi, ax
  000cb	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  000d1	80 ea 03	 sub	 dl, 3
  000d4	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  000d8	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  000de	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  000e4	81 c7 ff ff 00
	00		 add	 edi, 65535		; 0000ffffH
  000ea	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  000ed	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  000f3	0f b6 c2	 movzx	 eax, dl
  000f6	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  000fd	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  00105	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0010a	66 3b f8	 cmp	 di, ax
  0010d	0f b7 c7	 movzx	 eax, di
  00110	73 09		 jae	 SHORT $LN20@deflate_fa
  00112	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax]
  00119	eb 0a		 jmp	 SHORT $LN21@deflate_fa
$LN20@deflate_fa:
  0011b	c1 e8 07	 shr	 eax, 7
  0011e	0f b6 80 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax+256]
$LN21@deflate_fa:
  00125	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  0012d	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00133	48		 dec	 eax
  00134	33 db		 xor	 ebx, ebx
  00136	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1565 : 
; 1566 :             s->lookahead -= s->match_length;

  0013c	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  0013f	0f 94 c3	 sete	 bl
  00142	29 46 74	 sub	 DWORD PTR [esi+116], eax
  00145	89 5d 08	 mov	 DWORD PTR _bflush$1$[ebp], ebx

; 1567 : 
; 1568 :             /* Insert new strings in the hash table only if the match length
; 1569 :              * is not too large. This saves time but degrades compression.
; 1570 :              */
; 1571 : #ifndef FASTEST
; 1572 :             if (s->match_length <= s->max_insert_length &&
; 1573 :                 s->lookahead >= MIN_MATCH) {

  00148	3b 86 80 00 00
	00		 cmp	 eax, DWORD PTR [esi+128]
  0014e	77 59		 ja	 SHORT $LN9@deflate_fa
  00150	83 7e 74 03	 cmp	 DWORD PTR [esi+116], 3
  00154	72 53		 jb	 SHORT $LN9@deflate_fa

; 1574 :                 s->match_length--; /* string at strstart already in table */

  00156	48		 dec	 eax
  00157	89 46 60	 mov	 DWORD PTR [esi+96], eax
  0015a	8d 9b 00 00 00
	00		 npad	 6
$LL8@deflate_fa:

; 1575 :                 do {
; 1576 :                     s->strstart++;

  00160	ff 46 6c	 inc	 DWORD PTR [esi+108]
  00163	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]

; 1577 :                     INSERT_STRING(s, s->strstart, hash_head);

  00166	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00169	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0016c	0f b6 5c 07 02	 movzx	 ebx, BYTE PTR [edi+eax+2]
  00171	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00174	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00177	d3 e0		 shl	 eax, cl
  00179	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0017c	23 d7		 and	 edx, edi
  0017e	33 d8		 xor	 ebx, eax
  00180	23 5e 54	 and	 ebx, DWORD PTR [esi+84]
  00183	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00186	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  00189	0f b7 04 58	 movzx	 eax, WORD PTR [eax+ebx*2]
  0018d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00191	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  00195	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00198	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0019b	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 1578 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1579 :                      * always MIN_MATCH bytes ahead.
; 1580 :                      */
; 1581 :                 } while (--s->match_length != 0);

  0019f	ff 4e 60	 dec	 DWORD PTR [esi+96]
  001a2	75 bc		 jne	 SHORT $LL8@deflate_fa

; 1582 :                 s->strstart++;
; 1583 :             } else

  001a4	8b 5d 08	 mov	 ebx, DWORD PTR _bflush$1$[ebp]
  001a7	eb 79		 jmp	 SHORT $LN34@deflate_fa
$LN9@deflate_fa:

; 1584 : #endif
; 1585 :             {
; 1586 :                 s->strstart += s->match_length;

  001a9	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1587 :                 s->match_length = 0;
; 1588 :                 s->ins_h = s->window[s->strstart];

  001ac	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001af	03 46 6c	 add	 eax, DWORD PTR [esi+108]

; 1589 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  001b2	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001b5	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  001bc	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  001bf	89 56 48	 mov	 DWORD PTR [esi+72], edx
  001c2	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  001c6	d3 e2		 shl	 edx, cl
  001c8	33 d0		 xor	 edx, eax
  001ca	23 56 54	 and	 edx, DWORD PTR [esi+84]
  001cd	89 56 48	 mov	 DWORD PTR [esi+72], edx

; 1590 : #if MIN_MATCH != 3
; 1591 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1592 : #endif
; 1593 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1594 :                  * matter since it will be recomputed at next deflate call.
; 1595 :                  */
; 1596 :             }
; 1597 :         } else {

  001d0	eb 53		 jmp	 SHORT $LN4@deflate_fa
$LN10@deflate_fa:

; 1598 :             /* No match, output a literal byte */
; 1599 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1600 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001d2	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  001d5	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001d8	33 ff		 xor	 edi, edi
  001da	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001dd	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  001e3	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  001e9	33 db		 xor	 ebx, ebx
  001eb	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  001ef	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  001f5	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  001fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  001fe	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00204	0f b6 c2	 movzx	 eax, dl
  00207	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  0020f	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00215	48		 dec	 eax
  00216	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  0021c	0f 94 c3	 sete	 bl

; 1601 :             s->lookahead--;

  0021f	ff 4e 74	 dec	 DWORD PTR [esi+116]
$LN34@deflate_fa:

; 1602 :             s->strstart++;

  00222	ff 46 6c	 inc	 DWORD PTR [esi+108]
$LN4@deflate_fa:

; 1603 :         }
; 1604 :         if (bflush) FLUSH_BLOCK(s, 0);

  00225	85 db		 test	 ebx, ebx
  00227	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  0022a	0f 84 e0 fd ff
	ff		 je	 $LL17@deflate_fa
  00230	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00233	85 d2		 test	 edx, edx
  00235	78 07		 js	 SHORT $LN22@deflate_fa
  00237	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0023a	03 ca		 add	 ecx, edx
  0023c	eb 02		 jmp	 SHORT $LN23@deflate_fa
$LN22@deflate_fa:
  0023e	33 c9		 xor	 ecx, ecx
$LN23@deflate_fa:
  00240	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00243	6a 00		 push	 0
  00245	2b c2		 sub	 eax, edx
  00247	50		 push	 eax
  00248	51		 push	 ecx
  00249	56		 push	 esi
  0024a	e8 00 00 00 00	 call	 __tr_flush_block
  0024f	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00252	ff 36		 push	 DWORD PTR [esi]
  00254	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00257	e8 00 00 00 00	 call	 _flush_pending
  0025c	8b 06		 mov	 eax, DWORD PTR [esi]
  0025e	83 c4 14	 add	 esp, 20			; 00000014H
  00261	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00265	0f 85 a5 fd ff
	ff		 jne	 $LL17@deflate_fa
$LN31@deflate_fa:
  0026b	5f		 pop	 edi
  0026c	5e		 pop	 esi
  0026d	33 c0		 xor	 eax, eax
  0026f	5b		 pop	 ebx

; 1608 : }

  00270	5d		 pop	 ebp
  00271	c3		 ret	 0
$LN30@deflate_fa:

; 1605 :     }
; 1606 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00272	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00275	85 d2		 test	 edx, edx
  00277	78 07		 js	 SHORT $LN24@deflate_fa
  00279	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0027c	03 ca		 add	 ecx, edx
  0027e	eb 02		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00280	33 c9		 xor	 ecx, ecx
$LN25@deflate_fa:
  00282	33 c0		 xor	 eax, eax
  00284	83 fb 04	 cmp	 ebx, 4
  00287	0f 94 c0	 sete	 al
  0028a	50		 push	 eax
  0028b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0028e	2b c2		 sub	 eax, edx
  00290	50		 push	 eax
  00291	51		 push	 ecx
  00292	56		 push	 esi
  00293	e8 00 00 00 00	 call	 __tr_flush_block
  00298	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0029b	ff 36		 push	 DWORD PTR [esi]
  0029d	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  002a0	e8 00 00 00 00	 call	 _flush_pending
  002a5	8b 06		 mov	 eax, DWORD PTR [esi]
  002a7	83 c4 14	 add	 esp, 20			; 00000014H
  002aa	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  002ae	75 12		 jne	 SHORT $LN1@deflate_fa
  002b0	5f		 pop	 edi
  002b1	33 c0		 xor	 eax, eax
  002b3	83 fb 04	 cmp	 ebx, 4
  002b6	b9 02 00 00 00	 mov	 ecx, 2
  002bb	5e		 pop	 esi
  002bc	0f 44 c1	 cmove	 eax, ecx
  002bf	5b		 pop	 ebx

; 1608 : }

  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN1@deflate_fa:

; 1607 :     return flush == Z_FINISH ? finish_done : block_done;

  002c2	33 c0		 xor	 eax, eax
  002c4	83 fb 04	 cmp	 ebx, 4
  002c7	0f 94 c0	 sete	 al
  002ca	5f		 pop	 edi
  002cb	5e		 pop	 esi
  002cc	5b		 pop	 ebx
  002cd	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]

; 1608 : }

  002d4	5d		 pop	 ebp
  002d5	c3		 ret	 0
_deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate_stored
_TEXT	SEGMENT
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_stored PROC					; COMDAT

; 1465 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1466 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1467 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1468 :      */
; 1469 :     ulg max_block_size = 0xffff;
; 1470 :     ulg max_start;
; 1471 : 
; 1472 :     if (max_block_size > s->pending_buf_size - 5) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	57		 push	 edi
  00008	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000b	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  00010	83 c0 fb	 add	 eax, -5			; fffffffbH
  00013	3b c7		 cmp	 eax, edi
  00015	0f 42 f8	 cmovb	 edi, eax
$LL11@deflate_st:

; 1473 :         max_block_size = s->pending_buf_size - 5;
; 1474 :     }
; 1475 : 
; 1476 :     /* Copy as much as possible from input to output: */
; 1477 :     for (;;) {
; 1478 :         /* Fill the window as much as possible: */
; 1479 :         if (s->lookahead <= 1) {

  00018	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	77 14		 ja	 SHORT $LN7@deflate_st

; 1480 : 
; 1481 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1482 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1483 : 
; 1484 :             fill_window(s);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 _fill_window

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00026	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 a3 00 00
	00		 je	 $LN29@deflate_st
$LN7@deflate_st:

; 1486 : 
; 1487 :             if (s->lookahead == 0) break; /* flush the current block */
; 1488 :         }
; 1489 :         Assert(s->block_start >= 0L, "block gone");
; 1490 : 
; 1491 :         s->strstart += s->lookahead;
; 1492 :         s->lookahead = 0;
; 1493 : 
; 1494 :         /* Emit a stored block if pending_buf will be full: */
; 1495 :         max_start = s->block_start + max_block_size;

  00034	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00037	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1496 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  0003a	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0003d	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  00044	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00047	74 04		 je	 SHORT $LN5@deflate_st
  00049	3b c8		 cmp	 ecx, eax
  0004b	72 39		 jb	 SHORT $LN4@deflate_st
$LN5@deflate_st:

; 1497 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1498 :             s->lookahead = (uInt)(s->strstart - max_start);

  0004d	2b c8		 sub	 ecx, eax
  0004f	89 4e 74	 mov	 DWORD PTR [esi+116], ecx

; 1499 :             s->strstart = (uInt)max_start;

  00052	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 1500 :             FLUSH_BLOCK(s, 0);

  00055	85 d2		 test	 edx, edx
  00057	78 07		 js	 SHORT $LN15@deflate_st
  00059	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0005c	03 ca		 add	 ecx, edx
  0005e	eb 02		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:
  00060	33 c9		 xor	 ecx, ecx
$LN16@deflate_st:
  00062	6a 00		 push	 0
  00064	2b c2		 sub	 eax, edx
  00066	50		 push	 eax
  00067	51		 push	 ecx
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 __tr_flush_block
  0006e	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00071	ff 36		 push	 DWORD PTR [esi]
  00073	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00076	e8 00 00 00 00	 call	 _flush_pending
  0007b	8b 06		 mov	 eax, DWORD PTR [esi]
  0007d	83 c4 14	 add	 esp, 20			; 00000014H
  00080	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00084	74 4b		 je	 SHORT $LN25@deflate_st
$LN4@deflate_st:

; 1501 :         }
; 1502 :         /* Flush if we may have to slide, otherwise block_start may become
; 1503 :          * negative and the data will be gone:
; 1504 :          */
; 1505 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  00086	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00089	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0008c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0008f	2b ca		 sub	 ecx, edx
  00091	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00096	3b c8		 cmp	 ecx, eax
  00098	0f 82 7a ff ff
	ff		 jb	 $LL11@deflate_st

; 1506 :             FLUSH_BLOCK(s, 0);

  0009e	85 d2		 test	 edx, edx
  000a0	78 07		 js	 SHORT $LN17@deflate_st
  000a2	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000a5	03 c2		 add	 eax, edx
  000a7	eb 02		 jmp	 SHORT $LN18@deflate_st
$LN17@deflate_st:
  000a9	33 c0		 xor	 eax, eax
$LN18@deflate_st:
  000ab	6a 00		 push	 0
  000ad	51		 push	 ecx
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 __tr_flush_block
  000b5	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000b8	ff 36		 push	 DWORD PTR [esi]
  000ba	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000bd	e8 00 00 00 00	 call	 _flush_pending
  000c2	8b 06		 mov	 eax, DWORD PTR [esi]
  000c4	83 c4 14	 add	 esp, 20			; 00000014H
  000c7	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000cb	0f 85 47 ff ff
	ff		 jne	 $LL11@deflate_st
$LN25@deflate_st:
  000d1	5f		 pop	 edi

; 1500 :             FLUSH_BLOCK(s, 0);

  000d2	33 c0		 xor	 eax, eax
  000d4	5e		 pop	 esi

; 1511 : }

  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
$LN29@deflate_st:

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  000d7	8b 7d 0c	 mov	 edi, DWORD PTR _flush$[ebp]
  000da	85 ff		 test	 edi, edi
  000dc	74 f3		 je	 SHORT $LN25@deflate_st

; 1507 :         }
; 1508 :     }
; 1509 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  000de	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  000e1	85 d2		 test	 edx, edx
  000e3	78 07		 js	 SHORT $LN19@deflate_st
  000e5	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000e8	03 ca		 add	 ecx, edx
  000ea	eb 02		 jmp	 SHORT $LN20@deflate_st
$LN19@deflate_st:
  000ec	33 c9		 xor	 ecx, ecx
$LN20@deflate_st:
  000ee	33 c0		 xor	 eax, eax
  000f0	83 ff 04	 cmp	 edi, 4
  000f3	0f 94 c0	 sete	 al
  000f6	50		 push	 eax
  000f7	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000fa	2b c2		 sub	 eax, edx
  000fc	50		 push	 eax
  000fd	51		 push	 ecx
  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 __tr_flush_block
  00104	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00107	ff 36		 push	 DWORD PTR [esi]
  00109	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0010c	e8 00 00 00 00	 call	 _flush_pending
  00111	8b 06		 mov	 eax, DWORD PTR [esi]
  00113	83 c4 14	 add	 esp, 20			; 00000014H
  00116	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0011a	75 11		 jne	 SHORT $LN1@deflate_st
  0011c	33 c0		 xor	 eax, eax
  0011e	83 ff 04	 cmp	 edi, 4
  00121	b9 02 00 00 00	 mov	 ecx, 2
  00126	5f		 pop	 edi
  00127	0f 44 c1	 cmove	 eax, ecx
  0012a	5e		 pop	 esi

; 1511 : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN1@deflate_st:

; 1510 :     return flush == Z_FINISH ? finish_done : block_done;

  0012d	33 c0		 xor	 eax, eax
  0012f	83 ff 04	 cmp	 edi, 4
  00132	0f 94 c0	 sete	 al
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]

; 1511 : }

  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
_deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _fill_window
_TEXT	SEGMENT
_s$ = 8							; size = 4
_fill_window PROC					; COMDAT

; 1307 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1308 :     register unsigned n, m;
; 1309 :     register Posf *p;
; 1310 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1311 :     uInt wsize = s->w_size;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
  00009	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0000c	8d 64 24 00	 npad	 4
$LL23@fill_windo:

; 1312 : 
; 1313 :     do {
; 1314 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00010	8b 5f 3c	 mov	 ebx, DWORD PTR [edi+60]

; 1315 : 
; 1316 :         /* Deal with !@#$% 64K limit: */
; 1317 :         if (sizeof(int) <= 2) {
; 1318 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1319 :                 more = wsize;
; 1320 : 
; 1321 :             } else if (more == (unsigned)(-1)) {
; 1322 :                 /* Very unlikely, but possible on 16 bit machine if
; 1323 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1324 :                  */
; 1325 :                 more--;
; 1326 :             }
; 1327 :         }
; 1328 : 
; 1329 :         /* If the window is almost full and there is insufficient lookahead,
; 1330 :          * move the upper half to the lower one to make room in the upper half.
; 1331 :          */
; 1332 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  00013	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00016	2b 5f 74	 sub	 ebx, DWORD PTR [edi+116]
  00019	05 fa fe ff ff	 add	 eax, -262		; fffffefaH
  0001e	2b 5f 6c	 sub	 ebx, DWORD PTR [edi+108]
  00021	03 c6		 add	 eax, esi
  00023	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  00026	72 61		 jb	 SHORT $LN16@fill_windo

; 1333 : 
; 1334 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  00028	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0002b	56		 push	 esi
  0002c	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _memcpy

; 1335 :             s->match_start -= wsize;
; 1336 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1337 :             s->block_start -= (long) wsize;
; 1338 : 
; 1339 :             /* Slide the hash table (could be avoided with 32 bit values
; 1340 :                at the expense of memory usage). We slide even when level == 0
; 1341 :                to keep the hash table consistent if we switch back to level > 0
; 1342 :                later. (Using level 0 permanently is not an optimal usage of
; 1343 :                zlib, so we don't care about this pathological case.)
; 1344 :              */
; 1345 :             n = s->hash_size;

  00036	8b 57 4c	 mov	 edx, DWORD PTR [edi+76]

; 1346 :             p = &s->head[n];

  00039	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0003c	29 77 70	 sub	 DWORD PTR [edi+112], esi
  0003f	29 77 6c	 sub	 DWORD PTR [edi+108], esi
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	29 77 5c	 sub	 DWORD PTR [edi+92], esi
  00048	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0004b	eb 03 8d 49 00	 npad	 5
$LL15@fill_windo:

; 1347 :             do {
; 1348 :                 m = *--p;

  00050	0f b7 41 fe	 movzx	 eax, WORD PTR [ecx-2]
  00054	8d 49 fe	 lea	 ecx, DWORD PTR [ecx-2]

; 1349 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00057	3b c6		 cmp	 eax, esi
  00059	72 04		 jb	 SHORT $LN26@fill_windo
  0005b	2b c6		 sub	 eax, esi
  0005d	eb 02		 jmp	 SHORT $LN27@fill_windo
$LN26@fill_windo:
  0005f	33 c0		 xor	 eax, eax
$LN27@fill_windo:
  00061	66 89 01	 mov	 WORD PTR [ecx], ax

; 1350 :             } while (--n);

  00064	4a		 dec	 edx
  00065	75 e9		 jne	 SHORT $LL15@fill_windo

; 1351 : 
; 1352 :             n = wsize;
; 1353 : #ifndef FASTEST
; 1354 :             p = &s->prev[n];

  00067	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  0006a	8b d6		 mov	 edx, esi
  0006c	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  0006f	90		 npad	 1
$LL12@fill_windo:

; 1355 :             do {
; 1356 :                 m = *--p;

  00070	0f b7 41 fe	 movzx	 eax, WORD PTR [ecx-2]
  00074	8d 49 fe	 lea	 ecx, DWORD PTR [ecx-2]

; 1357 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00077	3b c6		 cmp	 eax, esi
  00079	72 04		 jb	 SHORT $LN28@fill_windo
  0007b	2b c6		 sub	 eax, esi
  0007d	eb 02		 jmp	 SHORT $LN29@fill_windo
$LN28@fill_windo:
  0007f	33 c0		 xor	 eax, eax
$LN29@fill_windo:
  00081	66 89 01	 mov	 WORD PTR [ecx], ax

; 1358 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1359 :                  * its value will never be used.
; 1360 :                  */
; 1361 :             } while (--n);

  00084	4a		 dec	 edx
  00085	75 e9		 jne	 SHORT $LL12@fill_windo

; 1362 : #endif
; 1363 :             more += wsize;

  00087	03 de		 add	 ebx, esi
$LN16@fill_windo:

; 1364 :         }
; 1365 :         if (s->strm->avail_in == 0) return;

  00089	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0008f	0f 84 c2 00 00
	00		 je	 $LN2@fill_windo

; 1366 : 
; 1367 :         /* If there was no sliding:
; 1368 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1369 :          *    more == window_size - lookahead - strstart
; 1370 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1371 :          * => more >= window_size - 2*WSIZE + 2
; 1372 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1373 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1374 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1375 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1376 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1377 :          */
; 1378 :         Assert(more >= 2, "more < 2");
; 1379 : 
; 1380 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  00095	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00098	03 47 6c	 add	 eax, DWORD PTR [edi+108]
  0009b	53		 push	 ebx
  0009c	03 47 38	 add	 eax, DWORD PTR [edi+56]
  0009f	50		 push	 eax
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _read_buf

; 1381 :         s->lookahead += n;

  000a6	01 47 74	 add	 DWORD PTR [edi+116], eax
  000a9	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1382 : 
; 1383 :         /* Initialize the hash value now that we have some input: */
; 1384 :         if (s->lookahead >= MIN_MATCH) {

  000af	83 fb 03	 cmp	 ebx, 3
  000b2	72 1d		 jb	 SHORT $LN22@fill_windo

; 1385 :             s->ins_h = s->window[s->strstart];

  000b4	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000b7	03 47 6c	 add	 eax, DWORD PTR [edi+108]

; 1386 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  000ba	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  000bd	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000c0	89 57 48	 mov	 DWORD PTR [edi+72], edx
  000c3	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  000c7	d3 e2		 shl	 edx, cl
  000c9	33 d0		 xor	 edx, eax
  000cb	23 57 54	 and	 edx, DWORD PTR [edi+84]
  000ce	89 57 48	 mov	 DWORD PTR [edi+72], edx
$LN22@fill_windo:

; 1387 : #if MIN_MATCH != 3
; 1388 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1389 : #endif
; 1390 :         }
; 1391 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1392 :          * but this is not important since only literal bytes will be emitted.
; 1393 :          */
; 1394 : 
; 1395 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  000d1	81 fb 06 01 00
	00		 cmp	 ebx, 262		; 00000106H
  000d7	73 0c		 jae	 SHORT $LN7@fill_windo
  000d9	8b 07		 mov	 eax, DWORD PTR [edi]
  000db	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000df	0f 85 2b ff ff
	ff		 jne	 $LL23@fill_windo
$LN7@fill_windo:

; 1396 : 
; 1397 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1398 :      * written, then zero those bytes in order to avoid memory check reports of
; 1399 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1400 :      * the longest match routines.  Update the high water mark for the next
; 1401 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1402 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1403 :      */
; 1404 :     if (s->high_water < s->window_size) {

  000e5	8b 8f c0 16 00
	00		 mov	 ecx, DWORD PTR [edi+5824]
  000eb	8b 5f 3c	 mov	 ebx, DWORD PTR [edi+60]
  000ee	3b cb		 cmp	 ecx, ebx
  000f0	73 65		 jae	 SHORT $LN2@fill_windo

; 1405 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  000f2	8b 77 6c	 mov	 esi, DWORD PTR [edi+108]
  000f5	03 77 74	 add	 esi, DWORD PTR [edi+116]

; 1406 :         ulg init;
; 1407 : 
; 1408 :         if (s->high_water < curr) {

  000f8	3b ce		 cmp	 ecx, esi
  000fa	73 2b		 jae	 SHORT $LN5@fill_windo

; 1409 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1410 :              * bytes or up to end of window, whichever is less.
; 1411 :              */
; 1412 :             init = s->window_size - curr;
; 1413 :             if (init > WIN_INIT)

  000fc	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00101	2b de		 sub	 ebx, esi
  00103	3b d8		 cmp	 ebx, eax
  00105	0f 47 d8	 cmova	 ebx, eax

; 1414 :                 init = WIN_INIT;
; 1415 :             zmemzero(s->window + curr, (unsigned)init);

  00108	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  0010b	53		 push	 ebx
  0010c	03 c6		 add	 eax, esi
  0010e	6a 00		 push	 0
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _memset
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1416 :             s->high_water = curr + init;

  00119	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0011c	89 87 c0 16 00
	00		 mov	 DWORD PTR [edi+5824], eax
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx

; 1428 :         }
; 1429 :     }
; 1430 : }

  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
$LN5@fill_windo:

; 1417 :         }
; 1418 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  00127	8d 86 02 01 00
	00		 lea	 eax, DWORD PTR [esi+258]
  0012d	3b c8		 cmp	 ecx, eax
  0012f	73 26		 jae	 SHORT $LN2@fill_windo

; 1419 :             /* High water mark at or above current data, but below current data
; 1420 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1421 :              * to end of window, whichever is less.
; 1422 :              */
; 1423 :             init = (ulg)curr + WIN_INIT - s->high_water;
; 1424 :             if (init > s->window_size - s->high_water)
; 1425 :                 init = s->window_size - s->high_water;
; 1426 :             zmemzero(s->window + s->high_water, (unsigned)init);

  00131	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00134	2b f1		 sub	 esi, ecx
  00136	2b d9		 sub	 ebx, ecx
  00138	81 c6 02 01 00
	00		 add	 esi, 258		; 00000102H
  0013e	3b f3		 cmp	 esi, ebx
  00140	0f 47 f3	 cmova	 esi, ebx
  00143	56		 push	 esi
  00144	03 c1		 add	 eax, ecx
  00146	6a 00		 push	 0
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _memset
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1427 :             s->high_water += init;

  00151	01 b7 c0 16 00
	00		 add	 DWORD PTR [edi+5824], esi
$LN2@fill_windo:
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx

; 1428 :         }
; 1429 :     }
; 1430 : }

  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
_fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateInit2_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_method$ = 16						; size = 4
_windowBits$ = 20					; size = 4
_memLevel$ = 24						; size = 4
_strategy$ = 28						; size = 4
_version$ = 32						; size = 4
_stream_size$ = 36					; size = 4
_deflateInit2_ PROC					; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 221  :     deflate_state *s;
; 222  :     int wrap = 1;
; 223  :     static const char my_version[] = ZLIB_VERSION;
; 224  : 
; 225  :     ushf *overlay;
; 226  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 227  :      * output size for (length,distance) codes is <= 24 bits.
; 228  :      */
; 229  : 
; 230  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 231  :         stream_size != sizeof(z_stream)) {

  00003	8b 45 20	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	be 01 00 00 00	 mov	 esi, 1
  0000c	85 c0		 test	 eax, eax
  0000e	0f 84 09 02 00
	00		 je	 $LN14@deflateIni
  00014	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00017	0f 85 00 02 00
	00		 jne	 $LN14@deflateIni
  0001d	83 7d 24 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00021	0f 85 f6 01 00
	00		 jne	 $LN14@deflateIni

; 233  :     }
; 234  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00027	57		 push	 edi
  00028	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0002b	85 ff		 test	 edi, edi
  0002d	75 07		 jne	 SHORT $LN13@deflateIni
  0002f	5f		 pop	 edi
  00030	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]
  00033	5e		 pop	 esi

; 308  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN13@deflateIni:

; 235  : 
; 236  :     strm->msg = Z_NULL;
; 237  :     if (strm->zalloc == (alloc_func)0) {

  00036	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0003a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00041	75 0e		 jne	 SHORT $LN12@deflateIni

; 238  :         strm->zalloc = zcalloc;

  00043	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET _zcalloc

; 239  :         strm->opaque = (voidpf)0;

  0004a	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
$LN12@deflateIni:

; 240  :     }
; 241  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00051	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00055	75 07		 jne	 SHORT $LN11@deflateIni
  00057	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], OFFSET _zcfree
$LN11@deflateIni:

; 242  : 
; 243  : #ifdef FASTEST
; 244  :     if (level != 0) level = 1;
; 245  : #else
; 246  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  00061	83 f9 ff	 cmp	 ecx, -1
  00064	53		 push	 ebx

; 247  : #endif
; 248  : 
; 249  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00065	8b 5d 14	 mov	 ebx, DWORD PTR _windowBits$[ebp]
  00068	b8 06 00 00 00	 mov	 eax, 6
  0006d	0f 44 c8	 cmove	 ecx, eax
  00070	89 4d 0c	 mov	 DWORD PTR _level$[ebp], ecx
  00073	85 db		 test	 ebx, ebx
  00075	79 06		 jns	 SHORT $LN9@deflateIni

; 250  :         wrap = 0;

  00077	33 f6		 xor	 esi, esi

; 251  :         windowBits = -windowBits;

  00079	f7 db		 neg	 ebx
  0007b	eb 0d		 jmp	 SHORT $LN7@deflateIni
$LN9@deflateIni:

; 252  :     }
; 253  : #ifdef GZIP
; 254  :     else if (windowBits > 15) {

  0007d	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00080	7e 08		 jle	 SHORT $LN7@deflateIni

; 255  :         wrap = 2;       /* write gzip wrapper instead */

  00082	be 02 00 00 00	 mov	 esi, 2

; 256  :         windowBits -= 16;

  00087	83 eb 10	 sub	 ebx, 16			; 00000010H
$LN7@deflateIni:

; 257  :     }
; 258  : #endif
; 259  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 260  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 261  :         strategy < 0 || strategy > Z_FIXED) {

  0008a	8b 45 18	 mov	 eax, DWORD PTR _memLevel$[ebp]
  0008d	48		 dec	 eax
  0008e	83 f8 08	 cmp	 eax, 8
  00091	0f 87 7c 01 00
	00		 ja	 $LN5@deflateIni
  00097	83 7d 10 08	 cmp	 DWORD PTR _method$[ebp], 8
  0009b	0f 85 72 01 00
	00		 jne	 $LN5@deflateIni
  000a1	8d 43 f8	 lea	 eax, DWORD PTR [ebx-8]
  000a4	83 f8 07	 cmp	 eax, 7
  000a7	0f 87 66 01 00
	00		 ja	 $LN5@deflateIni
  000ad	83 f9 09	 cmp	 ecx, 9
  000b0	0f 87 5d 01 00
	00		 ja	 $LN5@deflateIni
  000b6	83 7d 1c 04	 cmp	 DWORD PTR _strategy$[ebp], 4
  000ba	0f 87 53 01 00
	00		 ja	 $LN5@deflateIni

; 263  :     }
; 264  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
; 265  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000c0	68 c4 16 00 00	 push	 5828			; 000016c4H
  000c5	b8 09 00 00 00	 mov	 eax, 9
  000ca	83 fb 08	 cmp	 ebx, 8
  000cd	6a 01		 push	 1
  000cf	ff 77 28	 push	 DWORD PTR [edi+40]
  000d2	0f 44 d8	 cmove	 ebx, eax
  000d5	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000d8	ff d0		 call	 eax
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  :     if (s == Z_NULL) return Z_MEM_ERROR;

  000dd	85 c0		 test	 eax, eax
  000df	0f 84 24 01 00
	00		 je	 $LN20@deflateIni

; 267  :     strm->state = (struct internal_state FAR *)s;

  000e5	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 268  :     s->strm = strm;
; 269  : 
; 270  :     s->wrap = wrap;

  000e8	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 271  :     s->gzhead = Z_NULL;
; 272  :     s->w_bits = windowBits;

  000eb	89 58 30	 mov	 DWORD PTR [eax+48], ebx

; 273  :     s->w_size = 1 << s->w_bits;

  000ee	8b cb		 mov	 ecx, ebx
  000f0	8b d8		 mov	 ebx, eax
  000f2	89 38		 mov	 DWORD PTR [eax], edi
  000f4	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  000fb	be 01 00 00 00	 mov	 esi, 1
  00100	d3 e6		 shl	 esi, cl

; 274  :     s->w_mask = s->w_size - 1;
; 275  : 
; 276  :     s->hash_bits = memLevel + 7;

  00102	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  00105	83 c1 07	 add	 ecx, 7
  00108	89 4b 50	 mov	 DWORD PTR [ebx+80], ecx

; 277  :     s->hash_size = 1 << s->hash_bits;
; 278  :     s->hash_mask = s->hash_size - 1;
; 279  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
; 280  : 
; 281  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  0010b	6a 02		 push	 2
  0010d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00110	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00113	b8 01 00 00 00	 mov	 eax, 1
  00118	d3 e0		 shl	 eax, cl
  0011a	83 c1 02	 add	 ecx, 2
  0011d	89 73 2c	 mov	 DWORD PTR [ebx+44], esi
  00120	56		 push	 esi
  00121	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
  00124	48		 dec	 eax
  00125	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  00128	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0012d	f7 e1		 mul	 ecx
  0012f	d1 ea		 shr	 edx, 1
  00131	89 53 58	 mov	 DWORD PTR [ebx+88], edx
  00134	ff 77 28	 push	 DWORD PTR [edi+40]
  00137	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0013a	ff d0		 call	 eax

; 282  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0013c	6a 02		 push	 2
  0013e	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00141	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00144	ff 77 28	 push	 DWORD PTR [edi+40]
  00147	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0014a	ff d0		 call	 eax

; 283  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  0014c	6a 02		 push	 2
  0014e	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00151	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00154	ff 77 28	 push	 DWORD PTR [edi+40]
  00157	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0015a	ff d0		 call	 eax

; 284  : 
; 285  :     s->high_water = 0;      /* nothing written to s->window yet */
; 286  : 
; 287  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  0015c	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  0015f	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  00162	8d 49 06	 lea	 ecx, DWORD PTR [ecx+6]
  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	d3 e0		 shl	 eax, cl

; 288  : 
; 289  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  0016c	6a 04		 push	 4
  0016e	c7 83 c0 16 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+5824], 0
  00178	50		 push	 eax
  00179	89 83 9c 16 00
	00		 mov	 DWORD PTR [ebx+5788], eax
  0017f	ff 77 28	 push	 DWORD PTR [edi+40]
  00182	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00185	ff d0		 call	 eax

; 290  :     s->pending_buf = (uchf *) overlay;
; 291  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00187	8b b3 9c 16 00
	00		 mov	 esi, DWORD PTR [ebx+5788]
  0018d	83 c4 30	 add	 esp, 48			; 00000030H

; 292  : 
; 293  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 294  :         s->pending_buf == Z_NULL) {

  00190	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00194	8b d0		 mov	 edx, eax
  00196	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0019d	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  001a0	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  001a3	74 4c		 je	 SHORT $LN1@deflateIni
  001a5	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  001a9	74 46		 je	 SHORT $LN1@deflateIni
  001ab	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0
  001af	74 40		 je	 SHORT $LN1@deflateIni
  001b1	85 d2		 test	 edx, edx
  001b3	74 3c		 je	 SHORT $LN1@deflateIni

; 299  :     }
; 300  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001b5	8b c6		 mov	 eax, esi
  001b7	d1 e8		 shr	 eax, 1

; 301  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 302  : 
; 303  :     s->level = level;
; 304  :     s->strategy = strategy;
; 305  :     s->method = (Byte)method;
; 306  : 
; 307  :     return deflateReset(strm);

  001b9	57		 push	 edi
  001ba	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  001bd	89 83 a4 16 00
	00		 mov	 DWORD PTR [ebx+5796], eax
  001c3	8d 04 72	 lea	 eax, DWORD PTR [edx+esi*2]
  001c6	03 c6		 add	 eax, esi
  001c8	89 83 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], eax
  001ce	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  001d1	89 83 84 00 00
	00		 mov	 DWORD PTR [ebx+132], eax
  001d7	8b 45 1c	 mov	 eax, DWORD PTR _strategy$[ebp]
  001da	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  001e0	c6 43 24 08	 mov	 BYTE PTR [ebx+36], 8
  001e4	e8 00 00 00 00	 call	 _deflateReset
  001e9	83 c4 04	 add	 esp, 4
  001ec	5b		 pop	 ebx
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi

; 308  : }

  001ef	5d		 pop	 ebp
  001f0	c3		 ret	 0
$LN1@deflateIni:

; 295  :         s->status = FINISH_STATE;

  001f1	c7 43 04 9a 02
	00 00		 mov	 DWORD PTR [ebx+4], 666	; 0000029aH

; 296  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  001f8	a1 18 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+24

; 297  :         deflateEnd (strm);

  001fd	57		 push	 edi
  001fe	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00201	e8 00 00 00 00	 call	 _deflateEnd
  00206	83 c4 04	 add	 esp, 4
$LN20@deflateIni:

; 298  :         return Z_MEM_ERROR;

  00209	5b		 pop	 ebx
  0020a	5f		 pop	 edi
  0020b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00210	5e		 pop	 esi

; 308  : }

  00211	5d		 pop	 ebp
  00212	c3		 ret	 0
$LN5@deflateIni:
  00213	5b		 pop	 ebx
  00214	5f		 pop	 edi

; 262  :         return Z_STREAM_ERROR;

  00215	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0021a	5e		 pop	 esi

; 308  : }

  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
$LN14@deflateIni:

; 232  :         return Z_VERSION_ERROR;

  0021d	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00222	5e		 pop	 esi

; 308  : }

  00223	5d		 pop	 ebp
  00224	c3		 ret	 0
_deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateInit_
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_deflateInit_ PROC					; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 205  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00003	ff 75 14	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _version$[ebp]
  00009	6a 00		 push	 0
  0000b	6a 08		 push	 8
  0000d	6a 0f		 push	 15			; 0000000fH
  0000f	6a 08		 push	 8
  00011	ff 75 0c	 push	 DWORD PTR _level$[ebp]
  00014	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  00017	e8 00 00 00 00	 call	 _deflateInit2_
  0001c	83 c4 20	 add	 esp, 32			; 00000020H

; 206  :     /* To do: ignore strm->next_in if we use it as window */
; 207  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateSetHeader
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_deflateSetHeader PROC					; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 17		 je	 SHORT $LN2@deflateSet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 10		 je	 SHORT $LN2@deflateSet

; 394  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  00011	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  00015	75 0a		 jne	 SHORT $LN2@deflateSet

; 395  :     strm->state->gzhead = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 396  :     return Z_OK;

  0001d	33 c0		 xor	 eax, eax

; 397  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@deflateSet:

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00021	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 397  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflatePrime
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_deflatePrime PROC					; COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2c		 je	 SHORT $LN1@deflatePri
  0000a	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 25		 je	 SHORT $LN1@deflatePri

; 406  :     strm->state->bi_valid = bits;

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	89 8a bc 16 00
	00		 mov	 DWORD PTR [edx+5820], ecx

; 407  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  0001a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	66 d3 e2	 shl	 dx, cl
  00025	66 4a		 dec	 dx
  00027	66 23 55 10	 and	 dx, WORD PTR _value$[ebp]
  0002b	66 89 90 b8 16
	00 00		 mov	 WORD PTR [eax+5816], dx

; 408  :     return Z_OK;

  00032	33 c0		 xor	 eax, eax

; 409  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN1@deflatePri:

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 409  : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateBound
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_complen$1$ = 12					; size = 4
_sourceLen$ = 12					; size = 4
_deflateBound PROC					; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 490  :     deflate_state *s;
; 491  :     uLong complen, wraplen;
; 492  :     Bytef *str;
; 493  : 
; 494  :     /* conservative upper bound for compressed data */
; 495  :     complen = sourceLen +
; 496  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
; 497  : 
; 498  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _sourceLen$[ebp]
  0000a	8d 4b 3f	 lea	 ecx, DWORD PTR [ebx+63]
  0000d	c1 e9 06	 shr	 ecx, 6
  00010	8d 43 07	 lea	 eax, DWORD PTR [ebx+7]
  00013	c1 e8 03	 shr	 eax, 3
  00016	03 cb		 add	 ecx, ebx
  00018	83 c0 05	 add	 eax, 5
  0001b	03 c8		 add	 ecx, eax
  0001d	89 4d 0c	 mov	 DWORD PTR _complen$1$[ebp], ecx
  00020	85 d2		 test	 edx, edx
  00022	0f 84 b4 00 00
	00		 je	 $LN20@deflateBou
  00028	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0002b	85 d2		 test	 edx, edx
  0002d	0f 84 a9 00 00
	00		 je	 $LN20@deflateBou

; 501  : 
; 502  :     /* compute wrapper length */
; 503  :     s = strm->state;
; 504  :     switch (s->wrap) {

  00033	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00036	56		 push	 esi
  00037	83 e8 00	 sub	 eax, 0
  0003a	0f 84 91 00 00
	00		 je	 $LN17@deflateBou
  00040	48		 dec	 eax
  00041	74 7f		 je	 SHORT $LN16@deflateBou
  00043	48		 dec	 eax
  00044	74 07		 je	 SHORT $LN15@deflateBou

; 530  :     default:                                /* for compiler happiness */
; 531  :         wraplen = 6;

  00046	be 06 00 00 00	 mov	 esi, 6
  0004b	eb 4b		 jmp	 SHORT $LN18@deflateBou
$LN15@deflateBou:
  0004d	57		 push	 edi

; 511  :     case 2:                                 /* gzip wrapper */
; 512  :         wraplen = 18;
; 513  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  0004e	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00051	be 12 00 00 00	 mov	 esi, 18			; 00000012H
  00056	85 ff		 test	 edi, edi
  00058	74 3d		 je	 SHORT $LN30@deflateBou

; 514  :             if (s->gzhead->extra != Z_NULL)

  0005a	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0005e	74 06		 je	 SHORT $LN13@deflateBou

; 515  :                 wraplen += 2 + s->gzhead->extra_len;

  00060	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00063	83 c6 14	 add	 esi, 20			; 00000014H
$LN13@deflateBou:

; 516  :             str = s->gzhead->name;

  00066	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 517  :             if (str != Z_NULL)

  00069	85 c9		 test	 ecx, ecx
  0006b	74 0d		 je	 SHORT $LN9@deflateBou
  0006d	8d 49 00	 npad	 3
$LL11@deflateBou:

; 518  :                 do {
; 519  :                     wraplen++;
; 520  :                 } while (*str++);

  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	46		 inc	 esi
  00073	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00076	84 c0		 test	 al, al
  00078	75 f6		 jne	 SHORT $LL11@deflateBou
$LN9@deflateBou:

; 521  :             str = s->gzhead->comment;

  0007a	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]

; 522  :             if (str != Z_NULL)

  0007d	85 c9		 test	 ecx, ecx
  0007f	74 0a		 je	 SHORT $LN5@deflateBou
$LL7@deflateBou:

; 523  :                 do {
; 524  :                     wraplen++;
; 525  :                 } while (*str++);

  00081	8a 01		 mov	 al, BYTE PTR [ecx]
  00083	46		 inc	 esi
  00084	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00087	84 c0		 test	 al, al
  00089	75 f6		 jne	 SHORT $LL7@deflateBou
$LN5@deflateBou:

; 526  :             if (s->gzhead->hcrc)

  0008b	83 7f 2c 00	 cmp	 DWORD PTR [edi+44], 0

; 528  :         }
; 529  :         break;

  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _complen$1$[ebp]
  00092	74 03		 je	 SHORT $LN30@deflateBou

; 527  :                 wraplen += 2;

  00094	83 c6 02	 add	 esi, 2
$LN30@deflateBou:
  00097	5f		 pop	 edi
$LN18@deflateBou:

; 532  :     }
; 533  : 
; 534  :     /* if not default parameters, return conservative bound */
; 535  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  00098	83 7a 30 0f	 cmp	 DWORD PTR [edx+48], 15	; 0000000fH
  0009c	75 37		 jne	 SHORT $LN1@deflateBou
  0009e	83 7a 50 0f	 cmp	 DWORD PTR [edx+80], 15	; 0000000fH
  000a2	75 31		 jne	 SHORT $LN1@deflateBou

; 537  : 
; 538  :     /* default settings: return tight bound for that case */
; 539  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  000a4	8b cb		 mov	 ecx, ebx
  000a6	c1 e9 0e	 shr	 ecx, 14			; 0000000eH
  000a9	8b d3		 mov	 edx, ebx
  000ab	8b c3		 mov	 eax, ebx
  000ad	03 ce		 add	 ecx, esi
  000af	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000b2	c1 ea 19	 shr	 edx, 25			; 00000019H
  000b5	03 ca		 add	 ecx, edx
  000b7	83 c0 07	 add	 eax, 7
  000ba	03 c1		 add	 eax, ecx
  000bc	5e		 pop	 esi
  000bd	03 c3		 add	 eax, ebx
  000bf	5b		 pop	 ebx

; 541  : }

  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
$LN16@deflateBou:

; 507  :         break;
; 508  :     case 1:                                 /* zlib wrapper */
; 509  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000c2	8b 72 6c	 mov	 esi, DWORD PTR [edx+108]
  000c5	f7 de		 neg	 esi
  000c7	1b f6		 sbb	 esi, esi
  000c9	83 e6 04	 and	 esi, 4
  000cc	83 c6 06	 add	 esi, 6

; 510  :         break;

  000cf	eb c7		 jmp	 SHORT $LN18@deflateBou
$LN17@deflateBou:

; 505  :     case 0:                                 /* raw deflate */
; 506  :         wraplen = 0;

  000d1	33 f6		 xor	 esi, esi
  000d3	eb c3		 jmp	 SHORT $LN18@deflateBou
$LN1@deflateBou:

; 536  :         return complen + wraplen;

  000d5	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 541  : }

  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN20@deflateBou:

; 500  :         return complen + 6;

  000dc	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  000df	5b		 pop	 ebx

; 541  : }

  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateTune
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_good_length$ = 12					; size = 4
_max_lazy$ = 16						; size = 4
_nice_length$ = 20					; size = 4
_max_chain$ = 24					; size = 4
_deflateTune PROC					; COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 2c		 je	 SHORT $LN1@deflateTun
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 25		 je	 SHORT $LN1@deflateTun

; 461  :     s = strm->state;
; 462  :     s->good_match = good_length;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _good_length$[ebp]
  00014	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 463  :     s->max_lazy_match = max_lazy;

  0001a	8b 45 10	 mov	 eax, DWORD PTR _max_lazy$[ebp]
  0001d	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 464  :     s->nice_match = nice_length;

  00023	8b 45 14	 mov	 eax, DWORD PTR _nice_length$[ebp]
  00026	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 465  :     s->max_chain_length = max_chain;

  0002c	8b 45 18	 mov	 eax, DWORD PTR _max_chain$[ebp]
  0002f	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 466  :     return Z_OK;

  00032	33 c0		 xor	 eax, eax

; 467  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN1@deflateTun:

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 467  : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateParams
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_deflateParams PROC					; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;
; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 d2		 test	 edx, edx
  00009	0f 84 d1 00 00
	00		 je	 $LN7@deflatePar
  0000f	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00012	85 ff		 test	 edi, edi
  00014	0f 84 c6 00 00
	00		 je	 $LN7@deflatePar

; 422  :     s = strm->state;
; 423  : 
; 424  : #ifdef FASTEST
; 425  :     if (level != 0) level = 1;
; 426  : #else
; 427  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _level$[ebp]
  0001f	83 fe ff	 cmp	 esi, -1
  00022	75 07		 jne	 SHORT $LN6@deflatePar
  00024	be 06 00 00 00	 mov	 esi, 6

; 428  : #endif
; 429  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00029	eb 11		 jmp	 SHORT $LN12@deflatePar
$LN6@deflatePar:
  0002b	85 f6		 test	 esi, esi
  0002d	0f 88 a3 00 00
	00		 js	 $LN4@deflatePar
  00033	83 fe 09	 cmp	 esi, 9
  00036	0f 8f 9a 00 00
	00		 jg	 $LN4@deflatePar
$LN12@deflatePar:
  0003c	8b 5d 10	 mov	 ebx, DWORD PTR _strategy$[ebp]
  0003f	83 fb 04	 cmp	 ebx, 4
  00042	0f 87 8e 00 00
	00		 ja	 $LN4@deflatePar

; 431  :     }
; 432  :     func = configuration_table[s->level].func;
; 433  : 
; 434  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 435  :         strm->total_in != 0) {

  00048	3b 9f 88 00 00
	00		 cmp	 ebx, DWORD PTR [edi+136]
  0004e	75 1c		 jne	 SHORT $LN2@deflatePar
  00050	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  00056	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00059	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0005c	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _configuration_table[eax*4+8]
  00063	3b 04 8d 08 00
	00 00		 cmp	 eax, DWORD PTR _configuration_table[ecx*4+8]
  0006a	74 15		 je	 SHORT $LN14@deflatePar
$LN2@deflatePar:
  0006c	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00070	74 0f		 je	 SHORT $LN14@deflatePar

; 436  :         /* Flush the last buffer: */
; 437  :         err = deflate(strm, Z_BLOCK);

  00072	6a 05		 push	 5
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _deflate
  0007a	83 c4 08	 add	 esp, 8
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 02		 jmp	 SHORT $LN3@deflatePar
$LN14@deflatePar:
  00081	33 d2		 xor	 edx, edx
$LN3@deflatePar:

; 438  :     }
; 439  :     if (s->level != level) {

  00083	39 b7 84 00 00
	00		 cmp	 DWORD PTR [edi+132], esi
  00089	74 3e		 je	 SHORT $LN1@deflatePar

; 440  :         s->level = level;
; 441  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  0008b	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  0008e	89 b7 84 00 00
	00		 mov	 DWORD PTR [edi+132], esi
  00094	0f b7 04 8d 02
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+2]
  0009c	89 87 80 00 00
	00		 mov	 DWORD PTR [edi+128], eax

; 442  :         s->good_match       = configuration_table[level].good_length;

  000a2	0f b7 04 8d 00
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4]
  000aa	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax

; 443  :         s->nice_match       = configuration_table[level].nice_length;

  000b0	0f b7 04 8d 04
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+4]
  000b8	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax

; 444  :         s->max_chain_length = configuration_table[level].max_chain;

  000be	0f b7 04 8d 06
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+6]
  000c6	89 47 7c	 mov	 DWORD PTR [edi+124], eax
$LN1@deflatePar:

; 445  :     }
; 446  :     s->strategy = strategy;

  000c9	5e		 pop	 esi
  000ca	89 9f 88 00 00
	00		 mov	 DWORD PTR [edi+136], ebx
  000d0	5b		 pop	 ebx

; 447  :     return err;

  000d1	8b c2		 mov	 eax, edx
  000d3	5f		 pop	 edi

; 448  : }

  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN4@deflatePar:
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 430  :         return Z_STREAM_ERROR;

  000d8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000dd	5f		 pop	 edi

; 448  : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN7@deflatePar:

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;
; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e0	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e5	5f		 pop	 edi

; 448  : }

  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateReset
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateReset PROC					; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 356  :     deflate_state *s;
; 357  : 
; 358  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 359  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 a2 00 00
	00		 je	 $LN2@deflateRes
  00010	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 97 00 00
	00		 je	 $LN2@deflateRes
  0001b	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001f	0f 84 8d 00 00
	00		 je	 $LN2@deflateRes
  00025	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00029	0f 84 83 00 00
	00		 je	 $LN2@deflateRes

; 361  :     }
; 362  : 
; 363  :     strm->total_in = strm->total_out = 0;

  0002f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00036	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 364  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  0003d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 365  :     strm->data_type = Z_UNKNOWN;

  00044	c7 46 2c 02 00
	00 00		 mov	 DWORD PTR [esi+44], 2

; 366  : 
; 367  :     s = (deflate_state *)strm->state;
; 368  :     s->pending = 0;
; 369  :     s->pending_out = s->pending_buf;

  0004b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004e	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 370  : 
; 371  :     if (s->wrap < 0) {

  00051	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00054	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0005b	85 c0		 test	 eax, eax
  0005d	79 05		 jns	 SHORT $LN1@deflateRes

; 372  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  0005f	f7 d8		 neg	 eax
  00061	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN1@deflateRes:

; 373  :     }
; 374  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  00064	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00067	85 c9		 test	 ecx, ecx

; 375  :     strm->adler =
; 376  : #ifdef GZIP
; 377  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 378  : #endif
; 379  :         adler32(0L, Z_NULL, 0);

  00069	6a 00		 push	 0
  0006b	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  00070	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  00075	0f 45 c2	 cmovne	 eax, edx
  00078	6a 00		 push	 0
  0007a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0007d	6a 00		 push	 0
  0007f	83 f9 02	 cmp	 ecx, 2
  00082	75 07		 jne	 SHORT $LN6@deflateRes
  00084	e8 00 00 00 00	 call	 _crc32
  00089	eb 05		 jmp	 SHORT $LN8@deflateRes
$LN6@deflateRes:
  0008b	e8 00 00 00 00	 call	 _adler32
$LN8@deflateRes:
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 380  :     s->last_flush = Z_NO_FLUSH;
; 381  : 
; 382  :     _tr_init(s);

  00096	57		 push	 edi
  00097	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  0009e	e8 00 00 00 00	 call	 __tr_init

; 383  :     lm_init(s);

  000a3	57		 push	 edi
  000a4	e8 00 00 00 00	 call	 _lm_init
  000a9	83 c4 08	 add	 esp, 8

; 384  : 
; 385  :     return Z_OK;

  000ac	33 c0		 xor	 eax, eax
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi

; 386  : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN2@deflateRes:
  000b2	5f		 pop	 edi

; 360  :         return Z_STREAM_ERROR;

  000b3	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000b8	5e		 pop	 esi

; 386  : }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateCopy
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_overlay$1$ = 12					; size = 4
_ss$1$ = 12						; size = 4
_source$ = 12						; size = 4
_deflateCopy PROC					; COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 934  : #ifdef MAXSEG_64K
; 935  :     return Z_STREAM_ERROR;
; 936  : #else
; 937  :     deflate_state *ds;
; 938  :     deflate_state *ss;
; 939  :     ushf *overlay;
; 940  : 
; 941  : 
; 942  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  00005	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 72 01 00
	00		 je	 $LN4@deflateCop
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  00013	85 db		 test	 ebx, ebx
  00015	0f 84 67 01 00
	00		 je	 $LN4@deflateCop
  0001b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001e	89 45 0c	 mov	 DWORD PTR _ss$1$[ebp], eax
  00021	85 c0		 test	 eax, eax
  00023	0f 84 59 01 00
	00		 je	 $LN4@deflateCop

; 944  :     }
; 945  : 
; 946  :     ss = source->state;
; 947  : 
; 948  :     zmemcpy(dest, source, sizeof(z_stream));
; 949  : 
; 950  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00029	57		 push	 edi
  0002a	68 c4 16 00 00	 push	 5828			; 000016c4H
  0002f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00034	8b fb		 mov	 edi, ebx
  00036	f3 a5		 rep movsd
  00038	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0003b	6a 01		 push	 1
  0003d	ff 73 28	 push	 DWORD PTR [ebx+40]
  00040	ff d0		 call	 eax
  00042	8b f0		 mov	 esi, eax
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 951  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00047	85 f6		 test	 esi, esi
  00049	0f 84 29 01 00
	00		 je	 $LN9@deflateCop

; 952  :     dest->state = (struct internal_state FAR *) ds;
; 953  :     zmemcpy(ds, ss, sizeof(deflate_state));

  0004f	8b 7d 0c	 mov	 edi, DWORD PTR _ss$1$[ebp]
  00052	68 c4 16 00 00	 push	 5828			; 000016c4H
  00057	57		 push	 edi
  00058	56		 push	 esi
  00059	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
  0005c	e8 00 00 00 00	 call	 _memcpy

; 954  :     ds->strm = dest;
; 955  : 
; 956  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  00061	6a 02		 push	 2
  00063	ff 76 2c	 push	 DWORD PTR [esi+44]
  00066	89 1e		 mov	 DWORD PTR [esi], ebx
  00068	ff 73 28	 push	 DWORD PTR [ebx+40]
  0006b	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0006e	ff d0		 call	 eax

; 957  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00070	6a 02		 push	 2
  00072	ff 76 2c	 push	 DWORD PTR [esi+44]
  00075	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00078	ff 73 28	 push	 DWORD PTR [ebx+40]
  0007b	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0007e	ff d0		 call	 eax

; 958  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00080	6a 02		 push	 2
  00082	ff 76 4c	 push	 DWORD PTR [esi+76]
  00085	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00088	ff 73 28	 push	 DWORD PTR [ebx+40]
  0008b	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0008e	ff d0		 call	 eax

; 959  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  00090	6a 04		 push	 4
  00092	ff b6 9c 16 00
	00		 push	 DWORD PTR [esi+5788]
  00098	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0009b	ff 73 28	 push	 DWORD PTR [ebx+40]
  0009e	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000a1	ff d0		 call	 eax

; 960  :     ds->pending_buf = (uchf *) overlay;
; 961  : 
; 962  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 963  :         ds->pending_buf == Z_NULL) {

  000a3	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000a6	83 c4 3c	 add	 esp, 60			; 0000003cH
  000a9	89 45 0c	 mov	 DWORD PTR _overlay$1$[ebp], eax
  000ac	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000af	85 c9		 test	 ecx, ecx
  000b1	0f 84 b8 00 00
	00		 je	 $LN1@deflateCop
  000b7	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  000bb	0f 84 ae 00 00
	00		 je	 $LN1@deflateCop
  000c1	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  000c5	0f 84 a4 00 00
	00		 je	 $LN1@deflateCop
  000cb	85 c0		 test	 eax, eax
  000cd	0f 84 9c 00 00
	00		 je	 $LN1@deflateCop

; 966  :     }
; 967  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 968  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  000d3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000d6	03 c0		 add	 eax, eax
  000d8	50		 push	 eax
  000d9	ff 77 38	 push	 DWORD PTR [edi+56]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _memcpy

; 969  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  000e2	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000e5	03 c0		 add	 eax, eax
  000e7	50		 push	 eax
  000e8	ff 77 40	 push	 DWORD PTR [edi+64]
  000eb	ff 76 40	 push	 DWORD PTR [esi+64]
  000ee	e8 00 00 00 00	 call	 _memcpy

; 970  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  000f3	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  000f6	03 c0		 add	 eax, eax
  000f8	50		 push	 eax
  000f9	ff 77 44	 push	 DWORD PTR [edi+68]
  000fc	ff 76 44	 push	 DWORD PTR [esi+68]
  000ff	e8 00 00 00 00	 call	 _memcpy

; 971  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  00104	ff 76 0c	 push	 DWORD PTR [esi+12]
  00107	ff 77 08	 push	 DWORD PTR [edi+8]
  0010a	ff 76 08	 push	 DWORD PTR [esi+8]
  0010d	e8 00 00 00 00	 call	 _memcpy

; 972  : 
; 973  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  00112	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00115	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00118	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 974  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  0011b	8b 8e 9c 16 00
	00		 mov	 ecx, DWORD PTR [esi+5788]
  00121	8b 7d 0c	 mov	 edi, DWORD PTR _overlay$1$[ebp]
  00124	03 c2		 add	 eax, edx
  00126	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00129	8b c1		 mov	 eax, ecx
  0012b	d1 e8		 shr	 eax, 1
  0012d	83 c4 30	 add	 esp, 48			; 00000030H
  00130	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
  00133	89 86 a4 16 00
	00		 mov	 DWORD PTR [esi+5796], eax

; 975  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  00139	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0013c	03 c1		 add	 eax, ecx
  0013e	89 86 98 16 00
	00		 mov	 DWORD PTR [esi+5784], eax

; 976  : 
; 977  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  00144	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]
  0014a	89 86 18 0b 00
	00		 mov	 DWORD PTR [esi+2840], eax

; 978  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  00150	8d 86 88 09 00
	00		 lea	 eax, DWORD PTR [esi+2440]
  00156	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax

; 979  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  0015c	8d 86 7c 0a 00
	00		 lea	 eax, DWORD PTR [esi+2684]
  00162	5f		 pop	 edi
  00163	89 86 30 0b 00
	00		 mov	 DWORD PTR [esi+2864], eax
  00169	5e		 pop	 esi

; 980  : 
; 981  :     return Z_OK;

  0016a	33 c0		 xor	 eax, eax
  0016c	5b		 pop	 ebx

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
$LN1@deflateCop:

; 964  :         deflateEnd (dest);

  0016f	53		 push	 ebx
  00170	e8 00 00 00 00	 call	 _deflateEnd
  00175	83 c4 04	 add	 esp, 4
$LN9@deflateCop:

; 965  :         return Z_MEM_ERROR;

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0017f	5b		 pop	 ebx

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
$LN4@deflateCop:
  00182	5e		 pop	 esi

; 943  :         return Z_STREAM_ERROR;

  00183	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00188	5b		 pop	 ebx

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
_deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateSetDictionary
_TEXT	SEGMENT
tv369 = 8						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_length$1$ = 16						; size = 4
_dictLength$ = 16					; size = 4
_deflateSetDictionary PROC				; COMDAT

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 316  :     deflate_state *s;
; 317  :     uInt length = dictLength;
; 318  :     uInt n;
; 319  :     IPos hash_head = 0;
; 320  : 
; 321  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 322  :         strm->state->wrap == 2 ||
; 323  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 10	 mov	 edi, DWORD PTR _dictLength$[ebp]
  0000c	8b cf		 mov	 ecx, edi
  0000e	89 4d 10	 mov	 DWORD PTR _length$1$[ebp], ecx
  00011	85 c0		 test	 eax, eax
  00013	0f 84 dd 00 00
	00		 je	 $LN8@deflateSet
  00019	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  0001c	85 f6		 test	 esi, esi
  0001e	0f 84 d2 00 00
	00		 je	 $LN8@deflateSet
  00024	8b 5d 0c	 mov	 ebx, DWORD PTR _dictionary$[ebp]
  00027	85 db		 test	 ebx, ebx
  00029	0f 84 c7 00 00
	00		 je	 $LN8@deflateSet
  0002f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00032	83 fa 02	 cmp	 edx, 2
  00035	0f 84 bb 00 00
	00		 je	 $LN8@deflateSet
  0003b	83 fa 01	 cmp	 edx, 1
  0003e	75 0a		 jne	 SHORT $LN9@deflateSet
  00040	83 7e 04 2a	 cmp	 DWORD PTR [esi+4], 42	; 0000002aH
  00044	0f 85 ac 00 00
	00		 jne	 $LN8@deflateSet
$LN9@deflateSet:

; 325  : 
; 326  :     s = strm->state;
; 327  :     if (s->wrap)

  0004a	85 d2		 test	 edx, edx
  0004c	74 15		 je	 SHORT $LN7@deflateSet

; 328  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0004e	57		 push	 edi
  0004f	53		 push	 ebx
  00050	ff 70 30	 push	 DWORD PTR [eax+48]
  00053	e8 00 00 00 00	 call	 _adler32
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00061	8b cf		 mov	 ecx, edi
$LN7@deflateSet:

; 329  : 
; 330  :     if (length < MIN_MATCH) return Z_OK;

  00063	83 ff 03	 cmp	 edi, 3
  00066	0f 82 83 00 00
	00		 jb	 $LN15@deflateSet

; 331  :     if (length > s->w_size) {

  0006c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006f	3b f8		 cmp	 edi, eax
  00071	76 09		 jbe	 SHORT $LN5@deflateSet

; 332  :         length = s->w_size;

  00073	8b c8		 mov	 ecx, eax

; 333  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  00075	2b f9		 sub	 edi, ecx
  00077	89 4d 10	 mov	 DWORD PTR _length$1$[ebp], ecx
  0007a	03 df		 add	 ebx, edi
$LN5@deflateSet:

; 334  :     }
; 335  :     zmemcpy(s->window, dictionary, length);

  0007c	51		 push	 ecx
  0007d	53		 push	 ebx
  0007e	ff 76 38	 push	 DWORD PTR [esi+56]
  00081	e8 00 00 00 00	 call	 _memcpy

; 336  :     s->strstart = length;

  00086	8b 7d 10	 mov	 edi, DWORD PTR _length$1$[ebp]

; 337  :     s->block_start = (long)length;
; 338  : 
; 339  :     /* Insert all strings in the hash table (except for the last two bytes).
; 340  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 341  :      * call of fill_window.
; 342  :      */
; 343  :     s->ins_h = s->window[0];

  00089	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 344  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  0008c	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0008f	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  00092	89 7e 5c	 mov	 DWORD PTR [esi+92], edi
  00095	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00098	89 56 48	 mov	 DWORD PTR [esi+72], edx
  0009b	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  0009f	d3 e2		 shl	 edx, cl
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	33 d0		 xor	 edx, eax
  000a6	23 56 54	 and	 edx, DWORD PTR [esi+84]

; 345  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  000a9	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  000ac	89 56 48	 mov	 DWORD PTR [esi+72], edx
  000af	33 db		 xor	 ebx, ebx
  000b1	89 45 08	 mov	 DWORD PTR tv369[ebp], eax
$LL4@deflateSet:

; 346  :         INSERT_STRING(s, n, hash_head);

  000b4	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000b7	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  000ba	0f b6 7c 18 02	 movzx	 edi, BYTE PTR [eax+ebx+2]
  000bf	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  000c2	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000c5	d3 e0		 shl	 eax, cl
  000c7	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  000ca	23 d3		 and	 edx, ebx
  000cc	33 f8		 xor	 edi, eax
  000ce	23 7e 54	 and	 edi, DWORD PTR [esi+84]
  000d1	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000d4	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  000d7	66 8b 04 78	 mov	 ax, WORD PTR [eax+edi*2]
  000db	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  000df	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  000e2	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000e5	66 89 1c 48	 mov	 WORD PTR [eax+ecx*2], bx
  000e9	43		 inc	 ebx
  000ea	3b 5d 08	 cmp	 ebx, DWORD PTR tv369[ebp]
  000ed	76 c5		 jbe	 SHORT $LL4@deflateSet
$LN15@deflateSet:
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi

; 347  :     }
; 348  :     if (hash_head) hash_head = 0;  /* to make compiler happy */
; 349  :     return Z_OK;

  000f1	33 c0		 xor	 eax, eax
  000f3	5b		 pop	 ebx

; 350  : }

  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
$LN8@deflateSet:
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi

; 324  :         return Z_STREAM_ERROR;

  000f8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000fd	5b		 pop	 ebx

; 350  : }

  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflateEnd
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateEnd PROC					; COMDAT

; 897  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 b9 00 00
	00		 je	 $LN6@deflateEnd
  0000f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00012	85 c0		 test	 eax, eax
  00014	0f 84 ae 00 00
	00		 je	 $LN6@deflateEnd

; 901  : 
; 902  :     status = strm->state->status;

  0001a	57		 push	 edi
  0001b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 903  :     if (status != INIT_STATE &&
; 904  :         status != EXTRA_STATE &&
; 905  :         status != NAME_STATE &&
; 906  :         status != COMMENT_STATE &&
; 907  :         status != HCRC_STATE &&
; 908  :         status != BUSY_STATE &&
; 909  :         status != FINISH_STATE) {

  0001e	83 ff 2a	 cmp	 edi, 42			; 0000002aH
  00021	74 2a		 je	 SHORT $LN5@deflateEnd
  00023	83 ff 45	 cmp	 edi, 69			; 00000045H
  00026	74 25		 je	 SHORT $LN5@deflateEnd
  00028	83 ff 49	 cmp	 edi, 73			; 00000049H
  0002b	74 20		 je	 SHORT $LN5@deflateEnd
  0002d	83 ff 5b	 cmp	 edi, 91			; 0000005bH
  00030	74 1b		 je	 SHORT $LN5@deflateEnd
  00032	83 ff 67	 cmp	 edi, 103		; 00000067H
  00035	74 16		 je	 SHORT $LN5@deflateEnd
  00037	83 ff 71	 cmp	 edi, 113		; 00000071H
  0003a	74 11		 je	 SHORT $LN5@deflateEnd
  0003c	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  00042	74 09		 je	 SHORT $LN5@deflateEnd

; 910  :       return Z_STREAM_ERROR;

  00044	5f		 pop	 edi
  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	5e		 pop	 esi

; 923  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN5@deflateEnd:

; 911  :     }
; 912  : 
; 913  :     /* Deallocate in reverse order of allocations: */
; 914  :     TRY_FREE(strm, strm->state->pending_buf);

  0004d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 0c		 je	 SHORT $LN4@deflateEnd
  00054	50		 push	 eax
  00055	ff 76 28	 push	 DWORD PTR [esi+40]
  00058	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0005b	ff d0		 call	 eax
  0005d	83 c4 08	 add	 esp, 8
$LN4@deflateEnd:

; 915  :     TRY_FREE(strm, strm->state->head);

  00060	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00063	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00066	85 c0		 test	 eax, eax
  00068	74 0c		 je	 SHORT $LN3@deflateEnd
  0006a	50		 push	 eax
  0006b	ff 76 28	 push	 DWORD PTR [esi+40]
  0006e	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00071	ff d0		 call	 eax
  00073	83 c4 08	 add	 esp, 8
$LN3@deflateEnd:

; 916  :     TRY_FREE(strm, strm->state->prev);

  00076	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00079	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0007c	85 c0		 test	 eax, eax
  0007e	74 0c		 je	 SHORT $LN2@deflateEnd
  00080	50		 push	 eax
  00081	ff 76 28	 push	 DWORD PTR [esi+40]
  00084	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00087	ff d0		 call	 eax
  00089	83 c4 08	 add	 esp, 8
$LN2@deflateEnd:

; 917  :     TRY_FREE(strm, strm->state->window);

  0008c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008f	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00092	85 c0		 test	 eax, eax
  00094	74 0c		 je	 SHORT $LN1@deflateEnd
  00096	50		 push	 eax
  00097	ff 76 28	 push	 DWORD PTR [esi+40]
  0009a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0009d	ff d0		 call	 eax
  0009f	83 c4 08	 add	 esp, 8
$LN1@deflateEnd:

; 918  : 
; 919  :     ZFREE(strm, strm->state);

  000a2	ff 76 1c	 push	 DWORD PTR [esi+28]
  000a5	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000a8	ff 76 28	 push	 DWORD PTR [esi+40]
  000ab	ff d0		 call	 eax
  000ad	83 c4 08	 add	 esp, 8

; 920  :     strm->state = Z_NULL;
; 921  : 
; 922  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000b0	33 c0		 xor	 eax, eax
  000b2	83 ff 71	 cmp	 edi, 113		; 00000071H
  000b5	b9 fd ff ff ff	 mov	 ecx, -3			; fffffffdH
  000ba	5f		 pop	 edi
  000bb	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  000c2	0f 44 c1	 cmove	 eax, ecx
  000c5	5e		 pop	 esi

; 923  : }

  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN6@deflateEnd:

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000c8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000cd	5e		 pop	 esi

; 923  : }

  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
_deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\deflate.c
;	COMDAT _deflate
_TEXT	SEGMENT
_old_flush$1$ = -4					; size = 4
_val$1$ = 8						; size = 4
_val$1$ = 8						; size = 4
_beg$1$ = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_deflate PROC						; COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 586  :     int old_flush; /* value of flush param for previous deflate call */
; 587  :     deflate_state *s;
; 588  : 
; 589  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 590  :         flush > Z_BLOCK || flush < 0) {

  00006	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	0f 84 2f 08 00
	00		 je	 $LN82@deflate
  00011	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00014	85 f6		 test	 esi, esi
  00016	0f 84 24 08 00
	00		 je	 $LN82@deflate
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0001f	83 f8 05	 cmp	 eax, 5
  00022	0f 87 18 08 00
	00		 ja	 $LN82@deflate

; 591  :         return Z_STREAM_ERROR;
; 592  :     }
; 593  :     s = strm->state;
; 594  : 
; 595  :     if (strm->next_out == Z_NULL ||
; 596  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 597  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  00028	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0002c	0f 84 06 08 00
	00		 je	 $LN80@deflate
  00032	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00035	75 0a		 jne	 SHORT $LN79@deflate
  00037	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003b	0f 85 f7 07 00
	00		 jne	 $LN80@deflate
$LN79@deflate:
  00041	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00044	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  0004a	75 09		 jne	 SHORT $LN81@deflate
  0004c	83 f8 04	 cmp	 eax, 4
  0004f	0f 85 e3 07 00
	00		 jne	 $LN80@deflate
$LN81@deflate:

; 599  :     }
; 600  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  00055	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00059	75 13		 jne	 SHORT $LN78@deflate
  0005b	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  00060	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00063	5f		 pop	 edi
  00064	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00069	5e		 pop	 esi

; 892  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN78@deflate:

; 601  : 
; 602  :     s->strm = strm; /* just in case */
; 603  :     old_flush = s->last_flush;

  0006e	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00071	53		 push	 ebx
  00072	89 3e		 mov	 DWORD PTR [esi], edi
  00074	89 55 fc	 mov	 DWORD PTR _old_flush$1$[ebp], edx

; 604  :     s->last_flush = flush;

  00077	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 605  : 
; 606  :     /* Write the header */
; 607  :     if (s->status == INIT_STATE) {

  0007a	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  0007d	0f 85 a4 02 00
	00		 jne	 $LN71@deflate

; 608  : #ifdef GZIP
; 609  :         if (s->wrap == 2) {

  00083	83 7e 18 02	 cmp	 DWORD PTR [esi+24], 2
  00087	0f 85 f5 01 00
	00		 jne	 $LN76@deflate

; 610  :             strm->adler = crc32(0L, Z_NULL, 0);

  0008d	6a 00		 push	 0
  0008f	6a 00		 push	 0
  00091	6a 00		 push	 0
  00093	e8 00 00 00 00	 call	 _crc32
  00098	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 611  :             put_byte(s, 31);

  0009b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0009e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	c6 04 01 1f	 mov	 BYTE PTR [ecx+eax], 31	; 0000001fH
  000a8	ff 46 14	 inc	 DWORD PTR [esi+20]
  000ab	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 612  :             put_byte(s, 139);

  000ae	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b1	c6 04 01 8b	 mov	 BYTE PTR [ecx+eax], 139	; 0000008bH
  000b5	ff 46 14	 inc	 DWORD PTR [esi+20]
  000b8	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 613  :             put_byte(s, 8);

  000bb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000be	c6 04 01 08	 mov	 BYTE PTR [ecx+eax], 8
  000c2	ff 46 14	 inc	 DWORD PTR [esi+20]

; 614  :             if (s->gzhead == Z_NULL) {

  000c5	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  000c8	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  000cb	85 d2		 test	 edx, edx
  000cd	0f 85 85 00 00
	00		 jne	 $LN75@deflate

; 615  :                 put_byte(s, 0);

  000d3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d6	88 14 03	 mov	 BYTE PTR [ebx+eax], dl
  000d9	ff 46 14	 inc	 DWORD PTR [esi+20]
  000dc	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 616  :                 put_byte(s, 0);

  000df	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000e2	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  000e5	ff 46 14	 inc	 DWORD PTR [esi+20]
  000e8	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 617  :                 put_byte(s, 0);

  000eb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ee	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  000f1	ff 46 14	 inc	 DWORD PTR [esi+20]
  000f4	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 618  :                 put_byte(s, 0);

  000f7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fa	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  000fd	ff 46 14	 inc	 DWORD PTR [esi+20]
  00100	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 619  :                 put_byte(s, 0);

  00103	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00106	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00109	ff 46 14	 inc	 DWORD PTR [esi+20]

; 620  :                 put_byte(s, s->level == 9 ? 2 :
; 621  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 622  :                              4 : 0));

  0010c	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00112	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00115	83 f8 09	 cmp	 eax, 9
  00118	75 05		 jne	 SHORT $LN88@deflate
  0011a	8d 48 f9	 lea	 ecx, DWORD PTR [eax-7]
  0011d	eb 17		 jmp	 SHORT $LN87@deflate
$LN88@deflate:
  0011f	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  00126	7d 09		 jge	 SHORT $LN86@deflate
  00128	83 f8 02	 cmp	 eax, 2
  0012b	7c 04		 jl	 SHORT $LN86@deflate
  0012d	33 c9		 xor	 ecx, ecx
  0012f	eb 05		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  00131	b9 04 00 00 00	 mov	 ecx, 4
$LN87@deflate:
  00136	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00139	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0013c	ff 46 14	 inc	 DWORD PTR [esi+20]
  0013f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 623  :                 put_byte(s, OS_CODE);

  00142	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00145	c6 04 01 0b	 mov	 BYTE PTR [ecx+eax], 11	; 0000000bH
  00149	ff 46 14	 inc	 DWORD PTR [esi+20]

; 624  :                 s->status = BUSY_STATE;

  0014c	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H

; 625  :             }
; 626  :             else {

  00153	e9 cf 01 00 00	 jmp	 $LN71@deflate
$LN75@deflate:

; 627  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 628  :                             (s->gzhead->hcrc ? 2 : 0) +
; 629  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 630  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 631  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 632  :                         );

  00158	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0015b	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0015e	f7 d9		 neg	 ecx
  00160	1a c9		 sbb	 cl, cl
  00162	80 e1 10	 and	 cl, 16			; 00000010H
  00165	f7 d8		 neg	 eax
  00167	1a c0		 sbb	 al, al
  00169	24 02		 and	 al, 2
  0016b	02 c8		 add	 cl, al
  0016d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00170	f7 d8		 neg	 eax
  00172	1a c0		 sbb	 al, al
  00174	24 08		 and	 al, 8
  00176	02 c8		 add	 cl, al
  00178	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0017b	f7 d8		 neg	 eax
  0017d	1a c0		 sbb	 al, al
  0017f	24 04		 and	 al, 4
  00181	02 c8		 add	 cl, al
  00183	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00186	0f 95 c0	 setne	 al
  00189	02 c8		 add	 cl, al
  0018b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0018e	88 0c 03	 mov	 BYTE PTR [ebx+eax], cl
  00191	ff 46 14	 inc	 DWORD PTR [esi+20]
  00194	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 633  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  00197	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0019a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019d	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  001a1	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001a4	ff 46 14	 inc	 DWORD PTR [esi+20]

; 634  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  001a7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001aa	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001ad	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  001b1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b4	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001b7	ff 46 14	 inc	 DWORD PTR [esi+20]

; 635  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  001ba	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001bd	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001c0	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  001c4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c7	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001ca	ff 46 14	 inc	 DWORD PTR [esi+20]

; 636  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  001cd	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001d0	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001d3	0f b6 40 07	 movzx	 eax, BYTE PTR [eax+7]
  001d7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001da	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001dd	ff 46 14	 inc	 DWORD PTR [esi+20]

; 637  :                 put_byte(s, s->level == 9 ? 2 :
; 638  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 639  :                              4 : 0));

  001e0	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  001e6	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001e9	83 f8 09	 cmp	 eax, 9
  001ec	75 05		 jne	 SHORT $LN92@deflate
  001ee	8d 48 f9	 lea	 ecx, DWORD PTR [eax-7]
  001f1	eb 17		 jmp	 SHORT $LN91@deflate
$LN92@deflate:
  001f3	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  001fa	7d 09		 jge	 SHORT $LN90@deflate
  001fc	83 f8 02	 cmp	 eax, 2
  001ff	7c 04		 jl	 SHORT $LN90@deflate
  00201	33 c9		 xor	 ecx, ecx
  00203	eb 05		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  00205	b9 04 00 00 00	 mov	 ecx, 4
$LN91@deflate:
  0020a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0020d	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00210	ff 46 14	 inc	 DWORD PTR [esi+20]

; 640  :                 put_byte(s, s->gzhead->os & 0xff);

  00213	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00216	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00219	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0021c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0021f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 641  :                 if (s->gzhead->extra != Z_NULL) {

  00222	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00225	ff 46 14	 inc	 DWORD PTR [esi+20]
  00228	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0022c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0022f	74 23		 je	 SHORT $LN73@deflate

; 642  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  00231	0f b6 40 14	 movzx	 eax, BYTE PTR [eax+20]
  00235	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00238	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0023b	ff 46 14	 inc	 DWORD PTR [esi+20]

; 643  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  0023e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00241	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00244	0f b6 40 15	 movzx	 eax, BYTE PTR [eax+21]
  00248	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0024b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0024e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00251	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
$LN73@deflate:

; 644  :                 }
; 645  :                 if (s->gzhead->hcrc)

  00254	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00257	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0025b	74 12		 je	 SHORT $LN72@deflate

; 646  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 647  :                                         s->pending);

  0025d	52		 push	 edx
  0025e	ff 76 08	 push	 DWORD PTR [esi+8]
  00261	ff 77 30	 push	 DWORD PTR [edi+48]
  00264	e8 00 00 00 00	 call	 _crc32
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN72@deflate:

; 648  :                 s->gzindex = 0;

  0026f	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 649  :                 s->status = EXTRA_STATE;

  00276	c7 46 04 45 00
	00 00		 mov	 DWORD PTR [esi+4], 69	; 00000045H

; 650  :             }
; 651  :         }
; 652  :         else

  0027d	e9 a5 00 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 653  : #endif
; 654  :         {
; 655  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00282	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00285	83 e9 08	 sub	 ecx, 8
  00288	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  0028b	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H

; 656  :             uInt level_flags;
; 657  : 
; 658  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  00291	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  00298	7d 24		 jge	 SHORT $LN69@deflate
  0029a	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  002a0	83 fa 02	 cmp	 edx, 2
  002a3	7c 19		 jl	 SHORT $LN69@deflate

; 660  :             else if (s->level < 6)

  002a5	83 fa 06	 cmp	 edx, 6
  002a8	7d 07		 jge	 SHORT $LN67@deflate

; 661  :                 level_flags = 1;

  002aa	b8 01 00 00 00	 mov	 eax, 1
  002af	eb 0f		 jmp	 SHORT $LN64@deflate
$LN67@deflate:

; 662  :             else if (s->level == 6)

  002b1	33 c0		 xor	 eax, eax
  002b3	83 fa 06	 cmp	 edx, 6
  002b6	0f 95 c0	 setne	 al
  002b9	83 c0 02	 add	 eax, 2

; 663  :                 level_flags = 2;
; 664  :             else
; 665  :                 level_flags = 3;

  002bc	eb 02		 jmp	 SHORT $LN64@deflate
$LN69@deflate:

; 659  :                 level_flags = 0;

  002be	33 c0		 xor	 eax, eax
$LN64@deflate:

; 666  :             header |= (level_flags << 6);

  002c0	c1 e0 06	 shl	 eax, 6
  002c3	0b c8		 or	 ecx, eax

; 667  :             if (s->strstart != 0) header |= PRESET_DICT;

  002c5	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  002c9	74 03		 je	 SHORT $LN63@deflate
  002cb	83 c9 20	 or	 ecx, 32			; 00000020H
$LN63@deflate:

; 668  :             header += 31 - (header % 31);

  002ce	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  002d3	f7 e1		 mul	 ecx
  002d5	2b ca		 sub	 ecx, edx
  002d7	d1 e9		 shr	 ecx, 1
  002d9	03 ca		 add	 ecx, edx
  002db	c1 e9 04	 shr	 ecx, 4

; 669  : 
; 670  :             s->status = BUSY_STATE;
; 671  :             putShortMSB(s, header);

  002de	41		 inc	 ecx
  002df	8b c1		 mov	 eax, ecx
  002e1	c1 e0 05	 shl	 eax, 5
  002e4	2b c1		 sub	 eax, ecx
  002e6	50		 push	 eax
  002e7	56		 push	 esi
  002e8	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
  002ef	e8 00 00 00 00	 call	 _putShortMSB
  002f4	83 c4 08	 add	 esp, 8

; 672  : 
; 673  :             /* Save the adler32 of the preset dictionary: */
; 674  :             if (s->strstart != 0) {

  002f7	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  002fb	74 19		 je	 SHORT $LN62@deflate

; 675  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  002fd	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  00301	50		 push	 eax
  00302	56		 push	 esi
  00303	e8 00 00 00 00	 call	 _putShortMSB

; 676  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00308	0f b7 47 30	 movzx	 eax, WORD PTR [edi+48]
  0030c	50		 push	 eax
  0030d	56		 push	 esi
  0030e	e8 00 00 00 00	 call	 _putShortMSB
  00313	83 c4 10	 add	 esp, 16			; 00000010H
$LN62@deflate:

; 677  :             }
; 678  :             strm->adler = adler32(0L, Z_NULL, 0);

  00316	6a 00		 push	 0
  00318	6a 00		 push	 0
  0031a	6a 00		 push	 0
  0031c	e8 00 00 00 00	 call	 _adler32
  00321	83 c4 0c	 add	 esp, 12			; 0000000cH
  00324	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN71@deflate:

; 679  :         }
; 680  :     }
; 681  : #ifdef GZIP
; 682  :     if (s->status == EXTRA_STATE) {

  00327	83 7e 04 45	 cmp	 DWORD PTR [esi+4], 69	; 00000045H
  0032b	0f 85 c8 00 00
	00		 jne	 $LN52@deflate

; 683  :         if (s->gzhead->extra != Z_NULL) {

  00331	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00334	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00338	0f 84 b4 00 00
	00		 je	 $LN60@deflate

; 684  :             uInt beg = s->pending;  /* start of bytes to update crc */
; 685  : 
; 686  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  0033e	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  00342	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00345	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  00348	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  0034b	73 6c		 jae	 SHORT $LN108@deflate
  0034d	8d 49 00	 npad	 3
$LL59@deflate:

; 687  :                 if (s->pending == s->pending_buf_size) {

  00350	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00353	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  00356	75 3a		 jne	 SHORT $LN55@deflate

; 688  :                     if (s->gzhead->hcrc && s->pending > beg)

  00358	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0035b	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0035f	74 1b		 je	 SHORT $LN56@deflate
  00361	3b d9		 cmp	 ebx, ecx
  00363	76 17		 jbe	 SHORT $LN56@deflate

; 689  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 690  :                                             s->pending - beg);

  00365	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00368	2b d9		 sub	 ebx, ecx
  0036a	53		 push	 ebx
  0036b	03 c1		 add	 eax, ecx
  0036d	50		 push	 eax
  0036e	ff 77 30	 push	 DWORD PTR [edi+48]
  00371	e8 00 00 00 00	 call	 _crc32
  00376	83 c4 0c	 add	 esp, 12			; 0000000cH
  00379	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN56@deflate:

; 691  :                     flush_pending(strm);

  0037c	57		 push	 edi
  0037d	e8 00 00 00 00	 call	 _flush_pending

; 692  :                     beg = s->pending;

  00382	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00385	83 c4 04	 add	 esp, 4
  00388	8b cb		 mov	 ecx, ebx
  0038a	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx

; 693  :                     if (s->pending == s->pending_buf_size)

  0038d	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  00390	74 27		 je	 SHORT $LN108@deflate
$LN55@deflate:

; 694  :                         break;
; 695  :                 }
; 696  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  00392	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00395	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00398	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0039b	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0039e	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  003a1	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al
  003a4	ff 46 14	 inc	 DWORD PTR [esi+20]

; 697  :                 s->gzindex++;

  003a7	ff 46 20	 inc	 DWORD PTR [esi+32]
  003aa	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  003ad	8b 4d 08	 mov	 ecx, DWORD PTR _beg$1$[ebp]
  003b0	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  003b4	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  003b7	72 97		 jb	 SHORT $LL59@deflate
$LN108@deflate:

; 698  :             }
; 699  :             if (s->gzhead->hcrc && s->pending > beg)

  003b9	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  003bc	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  003c0	74 1e		 je	 SHORT $LN54@deflate
  003c2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003c5	3b c1		 cmp	 eax, ecx
  003c7	76 17		 jbe	 SHORT $LN54@deflate

; 700  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 701  :                                     s->pending - beg);

  003c9	2b c1		 sub	 eax, ecx
  003cb	50		 push	 eax
  003cc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003cf	03 c1		 add	 eax, ecx
  003d1	50		 push	 eax
  003d2	ff 77 30	 push	 DWORD PTR [edi+48]
  003d5	e8 00 00 00 00	 call	 _crc32
  003da	83 c4 0c	 add	 esp, 12			; 0000000cH
  003dd	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN54@deflate:

; 702  :             if (s->gzindex == s->gzhead->extra_len) {

  003e0	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  003e3	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  003e6	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  003e9	75 0e		 jne	 SHORT $LN52@deflate

; 703  :                 s->gzindex = 0;

  003eb	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN60@deflate:

; 704  :                 s->status = NAME_STATE;
; 705  :             }
; 706  :         }
; 707  :         else
; 708  :             s->status = NAME_STATE;

  003f2	c7 46 04 49 00
	00 00		 mov	 DWORD PTR [esi+4], 73	; 00000049H
$LN52@deflate:

; 709  :     }
; 710  :     if (s->status == NAME_STATE) {

  003f9	83 7e 04 49	 cmp	 DWORD PTR [esi+4], 73	; 00000049H
  003fd	0f 85 b9 00 00
	00		 jne	 $LN41@deflate

; 711  :         if (s->gzhead->name != Z_NULL) {

  00403	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00406	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0040a	0f 84 a5 00 00
	00		 je	 $LN50@deflate

; 712  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00410	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
$LL49@deflate:

; 713  :             int val;
; 714  : 
; 715  :             do {
; 716  :                 if (s->pending == s->pending_buf_size) {

  00413	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00416	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00419	75 37		 jne	 SHORT $LN44@deflate

; 717  :                     if (s->gzhead->hcrc && s->pending > beg)

  0041b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0041e	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00422	74 1b		 je	 SHORT $LN45@deflate
  00424	3b d3		 cmp	 edx, ebx
  00426	76 17		 jbe	 SHORT $LN45@deflate

; 718  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 719  :                                             s->pending - beg);

  00428	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0042b	2b d3		 sub	 edx, ebx
  0042d	52		 push	 edx
  0042e	03 c3		 add	 eax, ebx
  00430	50		 push	 eax
  00431	ff 77 30	 push	 DWORD PTR [edi+48]
  00434	e8 00 00 00 00	 call	 _crc32
  00439	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043c	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN45@deflate:

; 720  :                     flush_pending(strm);

  0043f	57		 push	 edi
  00440	e8 00 00 00 00	 call	 _flush_pending

; 721  :                     beg = s->pending;

  00445	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00448	83 c4 04	 add	 esp, 4
  0044b	8b da		 mov	 ebx, edx

; 722  :                     if (s->pending == s->pending_buf_size) {

  0044d	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00450	74 28		 je	 SHORT $LN102@deflate
$LN44@deflate:

; 724  :                         break;
; 725  :                     }
; 726  :                 }
; 727  :                 val = s->gzhead->name[s->gzindex++];

  00452	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00455	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00458	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0045b	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0045f	89 45 08	 mov	 DWORD PTR _val$1$[ebp], eax
  00462	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 728  :                 put_byte(s, val);

  00465	8b 4d 08	 mov	 ecx, DWORD PTR _val$1$[ebp]
  00468	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0046b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0046e	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00471	ff 46 14	 inc	 DWORD PTR [esi+20]

; 729  :             } while (val != 0);

  00474	85 c9		 test	 ecx, ecx
  00476	75 9b		 jne	 SHORT $LL49@deflate
  00478	eb 07		 jmp	 SHORT $LN47@deflate
$LN102@deflate:

; 723  :                         val = 1;

  0047a	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _val$1$[ebp], 1
$LN47@deflate:

; 730  :             if (s->gzhead->hcrc && s->pending > beg)

  00481	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00484	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00488	74 1e		 je	 SHORT $LN43@deflate
  0048a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0048d	3b c3		 cmp	 eax, ebx
  0048f	76 17		 jbe	 SHORT $LN43@deflate

; 731  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 732  :                                     s->pending - beg);

  00491	2b c3		 sub	 eax, ebx
  00493	50		 push	 eax
  00494	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00497	03 c3		 add	 eax, ebx
  00499	50		 push	 eax
  0049a	ff 77 30	 push	 DWORD PTR [edi+48]
  0049d	e8 00 00 00 00	 call	 _crc32
  004a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a5	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN43@deflate:

; 733  :             if (val == 0) {

  004a8	83 7d 08 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  004ac	75 0e		 jne	 SHORT $LN41@deflate

; 734  :                 s->gzindex = 0;

  004ae	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN50@deflate:

; 735  :                 s->status = COMMENT_STATE;
; 736  :             }
; 737  :         }
; 738  :         else
; 739  :             s->status = COMMENT_STATE;

  004b5	c7 46 04 5b 00
	00 00		 mov	 DWORD PTR [esi+4], 91	; 0000005bH
$LN41@deflate:

; 740  :     }
; 741  :     if (s->status == COMMENT_STATE) {

  004bc	83 7e 04 5b	 cmp	 DWORD PTR [esi+4], 91	; 0000005bH
  004c0	0f 85 b2 00 00
	00		 jne	 $LN30@deflate

; 742  :         if (s->gzhead->comment != Z_NULL) {

  004c6	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  004c9	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  004cd	0f 84 9e 00 00
	00		 je	 $LN39@deflate

; 743  :             uInt beg = s->pending;  /* start of bytes to update crc */

  004d3	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
$LL38@deflate:

; 744  :             int val;
; 745  : 
; 746  :             do {
; 747  :                 if (s->pending == s->pending_buf_size) {

  004d6	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  004d9	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  004dc	75 37		 jne	 SHORT $LN33@deflate

; 748  :                     if (s->gzhead->hcrc && s->pending > beg)

  004de	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  004e1	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  004e5	74 1b		 je	 SHORT $LN34@deflate
  004e7	3b d3		 cmp	 edx, ebx
  004e9	76 17		 jbe	 SHORT $LN34@deflate

; 749  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 750  :                                             s->pending - beg);

  004eb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004ee	2b d3		 sub	 edx, ebx
  004f0	52		 push	 edx
  004f1	03 c3		 add	 eax, ebx
  004f3	50		 push	 eax
  004f4	ff 77 30	 push	 DWORD PTR [edi+48]
  004f7	e8 00 00 00 00	 call	 _crc32
  004fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ff	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN34@deflate:

; 751  :                     flush_pending(strm);

  00502	57		 push	 edi
  00503	e8 00 00 00 00	 call	 _flush_pending

; 752  :                     beg = s->pending;

  00508	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0050b	83 c4 04	 add	 esp, 4
  0050e	8b da		 mov	 ebx, edx

; 753  :                     if (s->pending == s->pending_buf_size) {

  00510	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00513	74 28		 je	 SHORT $LN103@deflate
$LN33@deflate:

; 755  :                         break;
; 756  :                     }
; 757  :                 }
; 758  :                 val = s->gzhead->comment[s->gzindex++];

  00515	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00518	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0051b	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0051e	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00522	89 45 08	 mov	 DWORD PTR _val$1$[ebp], eax
  00525	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 759  :                 put_byte(s, val);

  00528	8b 4d 08	 mov	 ecx, DWORD PTR _val$1$[ebp]
  0052b	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0052e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00531	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00534	ff 46 14	 inc	 DWORD PTR [esi+20]

; 760  :             } while (val != 0);

  00537	85 c9		 test	 ecx, ecx
  00539	75 9b		 jne	 SHORT $LL38@deflate
  0053b	eb 07		 jmp	 SHORT $LN36@deflate
$LN103@deflate:

; 754  :                         val = 1;

  0053d	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _val$1$[ebp], 1
$LN36@deflate:

; 761  :             if (s->gzhead->hcrc && s->pending > beg)

  00544	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00547	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0054b	74 1e		 je	 SHORT $LN32@deflate
  0054d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00550	3b c3		 cmp	 eax, ebx
  00552	76 17		 jbe	 SHORT $LN32@deflate

; 762  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 763  :                                     s->pending - beg);

  00554	2b c3		 sub	 eax, ebx
  00556	50		 push	 eax
  00557	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0055a	03 c3		 add	 eax, ebx
  0055c	50		 push	 eax
  0055d	ff 77 30	 push	 DWORD PTR [edi+48]
  00560	e8 00 00 00 00	 call	 _crc32
  00565	83 c4 0c	 add	 esp, 12			; 0000000cH
  00568	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN32@deflate:

; 764  :             if (val == 0)

  0056b	83 7d 08 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  0056f	75 07		 jne	 SHORT $LN30@deflate
$LN39@deflate:

; 765  :                 s->status = HCRC_STATE;
; 766  :         }
; 767  :         else
; 768  :             s->status = HCRC_STATE;

  00571	c7 46 04 67 00
	00 00		 mov	 DWORD PTR [esi+4], 103	; 00000067H
$LN30@deflate:

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  00578	83 7e 04 67	 cmp	 DWORD PTR [esi+4], 103	; 00000067H
  0057c	75 5d		 jne	 SHORT $LN25@deflate

; 771  :         if (s->gzhead->hcrc) {

  0057e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00581	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00585	74 4d		 je	 SHORT $LN28@deflate

; 772  :             if (s->pending + 2 > s->pending_buf_size)

  00587	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0058a	83 c0 02	 add	 eax, 2
  0058d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00590	76 09		 jbe	 SHORT $LN27@deflate

; 773  :                 flush_pending(strm);

  00592	57		 push	 edi
  00593	e8 00 00 00 00	 call	 _flush_pending
  00598	83 c4 04	 add	 esp, 4
$LN27@deflate:

; 774  :             if (s->pending + 2 <= s->pending_buf_size) {

  0059b	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0059e	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  005a1	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  005a4	77 35		 ja	 SHORT $LN25@deflate

; 775  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  005a6	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]
  005aa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 776  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
; 777  :                 strm->adler = crc32(0L, Z_NULL, 0);

  005ad	6a 00		 push	 0
  005af	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005b2	ff 46 14	 inc	 DWORD PTR [esi+20]
  005b5	0f b6 47 31	 movzx	 eax, BYTE PTR [edi+49]
  005b9	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  005bc	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005bf	6a 00		 push	 0
  005c1	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005c4	ff 46 14	 inc	 DWORD PTR [esi+20]
  005c7	6a 00		 push	 0
  005c9	e8 00 00 00 00	 call	 _crc32
  005ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  005d1	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN28@deflate:

; 778  :                 s->status = BUSY_STATE;
; 779  :             }
; 780  :         }
; 781  :         else
; 782  :             s->status = BUSY_STATE;

  005d4	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
$LN25@deflate:

; 783  :     }
; 784  : #endif
; 785  : 
; 786  :     /* Flush as much pending output as possible */
; 787  :     if (s->pending != 0) {

  005db	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  005df	74 1f		 je	 SHORT $LN24@deflate

; 788  :         flush_pending(strm);

  005e1	57		 push	 edi
  005e2	e8 00 00 00 00	 call	 _flush_pending
  005e7	83 c4 04	 add	 esp, 4

; 789  :         if (strm->avail_out == 0) {

  005ea	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  005ee	75 37		 jne	 SHORT $LN109@deflate
$LN115@deflate:

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;

  005f0	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1
$LN13@deflate:
  005f7	5b		 pop	 ebx
  005f8	5f		 pop	 edi

; 797  :             return Z_OK;

  005f9	33 c0		 xor	 eax, eax
  005fb	5e		 pop	 esi

; 892  : }

  005fc	8b e5		 mov	 esp, ebp
  005fe	5d		 pop	 ebp
  005ff	c3		 ret	 0
$LN24@deflate:

; 798  :         }
; 799  : 
; 800  :     /* Make sure there is something to do and avoid duplicate consecutive
; 801  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 802  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 803  :      */
; 804  :     } else if (strm->avail_in == 0 && flush <= old_flush &&
; 805  :                flush != Z_FINISH) {

  00600	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00604	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00607	75 21		 jne	 SHORT $LN21@deflate
  00609	3b 5d fc	 cmp	 ebx, DWORD PTR _old_flush$1$[ebp]
  0060c	7f 1c		 jg	 SHORT $LN21@deflate
  0060e	83 fb 04	 cmp	 ebx, 4
  00611	74 17		 je	 SHORT $LN21@deflate

; 806  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00613	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  00618	5b		 pop	 ebx
  00619	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0061c	5f		 pop	 edi
  0061d	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00622	5e		 pop	 esi

; 892  : }

  00623	8b e5		 mov	 esp, ebp
  00625	5d		 pop	 ebp
  00626	c3		 ret	 0
$LN109@deflate:
  00627	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
$LN21@deflate:

; 807  :     }
; 808  : 
; 809  :     /* User must not provide more input after the first FINISH: */
; 810  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  0062a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0062d	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00632	75 1a		 jne	 SHORT $LN20@deflate
  00634	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00638	74 1a		 je	 SHORT $LN113@deflate

; 811  :         ERR_RETURN(strm, Z_BUF_ERROR);

  0063a	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  0063f	5b		 pop	 ebx
  00640	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00643	5f		 pop	 edi
  00644	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00649	5e		 pop	 esi

; 892  : }

  0064a	8b e5		 mov	 esp, ebp
  0064c	5d		 pop	 ebp
  0064d	c3		 ret	 0
$LN20@deflate:

; 812  :     }
; 813  : 
; 814  :     /* Start a new block or continue the current one.
; 815  :      */
; 816  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  0064e	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00652	75 19		 jne	 SHORT $LN18@deflate
$LN113@deflate:
  00654	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00658	75 13		 jne	 SHORT $LN18@deflate
  0065a	85 db		 test	 ebx, ebx
  0065c	0f 84 da 00 00
	00		 je	 $LN6@deflate
  00662	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00667	0f 84 cf 00 00
	00		 je	 $LN6@deflate
$LN18@deflate:

; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 821  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 822  :                         (*(configuration_table[s->level].func))(s, flush));

  0066d	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  00673	53		 push	 ebx
  00674	56		 push	 esi
  00675	83 f8 02	 cmp	 eax, 2
  00678	75 07		 jne	 SHORT $LN96@deflate
  0067a	e8 00 00 00 00	 call	 _deflate_huff
  0067f	eb 1e		 jmp	 SHORT $LN114@deflate
$LN96@deflate:
  00681	83 f8 03	 cmp	 eax, 3
  00684	75 07		 jne	 SHORT $LN94@deflate
  00686	e8 00 00 00 00	 call	 _deflate_rle
  0068b	eb 12		 jmp	 SHORT $LN114@deflate
$LN94@deflate:
  0068d	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00693	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00696	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _configuration_table[eax*4+8]
  0069d	ff d0		 call	 eax
$LN114@deflate:
  0069f	83 c4 08	 add	 esp, 8

; 823  : 
; 824  :         if (bstate == finish_started || bstate == finish_done) {

  006a2	83 f8 02	 cmp	 eax, 2
  006a5	74 05		 je	 SHORT $LN16@deflate
  006a7	83 f8 03	 cmp	 eax, 3
  006aa	75 07		 jne	 SHORT $LN17@deflate
$LN16@deflate:

; 825  :             s->status = FINISH_STATE;

  006ac	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH
$LN17@deflate:

; 826  :         }
; 827  :         if (bstate == need_more || bstate == finish_started) {

  006b3	85 c0		 test	 eax, eax
  006b5	0f 84 63 01 00
	00		 je	 $LN14@deflate
  006bb	83 f8 02	 cmp	 eax, 2
  006be	0f 84 5a 01 00
	00		 je	 $LN14@deflate

; 829  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
; 830  :             }
; 831  :             return Z_OK;
; 832  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 833  :              * of deflate should use the same flush parameter to make sure
; 834  :              * that the flush is complete. So we don't have to output an
; 835  :              * empty block here, this will be done at next call. This also
; 836  :              * ensures that for a very small output buffer, we emit at most
; 837  :              * one empty block.
; 838  :              */
; 839  :         }
; 840  :         if (bstate == block_done) {

  006c4	83 f8 01	 cmp	 eax, 1
  006c7	75 73		 jne	 SHORT $LN6@deflate

; 841  :             if (flush == Z_PARTIAL_FLUSH) {

  006c9	3b d8		 cmp	 ebx, eax
  006cb	75 0b		 jne	 SHORT $LN11@deflate

; 842  :                 _tr_align(s);

  006cd	56		 push	 esi
  006ce	e8 00 00 00 00	 call	 __tr_align
  006d3	83 c4 04	 add	 esp, 4
  006d6	eb 51		 jmp	 SHORT $LN7@deflate
$LN11@deflate:

; 843  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  006d8	83 fb 05	 cmp	 ebx, 5
  006db	74 4c		 je	 SHORT $LN7@deflate

; 844  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  006dd	6a 00		 push	 0
  006df	6a 00		 push	 0
  006e1	6a 00		 push	 0
  006e3	56		 push	 esi
  006e4	e8 00 00 00 00	 call	 __tr_stored_block
  006e9	83 c4 10	 add	 esp, 16			; 00000010H

; 845  :                 /* For a full flush, this empty block will be recognized
; 846  :                  * as a special marker by inflate_sync().
; 847  :                  */
; 848  :                 if (flush == Z_FULL_FLUSH) {

  006ec	83 fb 03	 cmp	 ebx, 3
  006ef	75 38		 jne	 SHORT $LN7@deflate

; 849  :                     CLEAR_HASH(s);             /* forget history */

  006f1	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  006f4	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  006f7	33 d2		 xor	 edx, edx
  006f9	66 89 54 48 fe	 mov	 WORD PTR [eax+ecx*2-2], dx
  006fe	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00701	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR [eax*2-2]
  00708	50		 push	 eax
  00709	52		 push	 edx
  0070a	ff 76 44	 push	 DWORD PTR [esi+68]
  0070d	e8 00 00 00 00	 call	 _memset
  00712	83 c4 0c	 add	 esp, 12			; 0000000cH

; 850  :                     if (s->lookahead == 0) {

  00715	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00719	75 0e		 jne	 SHORT $LN7@deflate

; 851  :                         s->strstart = 0;

  0071b	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 852  :                         s->block_start = 0L;

  00722	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
$LN7@deflate:

; 853  :                     }
; 854  :                 }
; 855  :             }
; 856  :             flush_pending(strm);

  00729	57		 push	 edi
  0072a	e8 00 00 00 00	 call	 _flush_pending
  0072f	83 c4 04	 add	 esp, 4

; 857  :             if (strm->avail_out == 0) {

  00732	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00736	0f 84 b4 fe ff
	ff		 je	 $LN115@deflate
$LN6@deflate:

; 858  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 859  :               return Z_OK;
; 860  :             }
; 861  :         }
; 862  :     }
; 863  :     Assert(strm->avail_out > 0, "bug2");
; 864  : 
; 865  :     if (flush != Z_FINISH) return Z_OK;

  0073c	83 fb 04	 cmp	 ebx, 4
  0073f	0f 85 b2 fe ff
	ff		 jne	 $LN13@deflate

; 866  :     if (s->wrap <= 0) return Z_STREAM_END;

  00745	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00748	85 c0		 test	 eax, eax
  0074a	7f 0a		 jg	 SHORT $LN4@deflate
  0074c	8d 43 fd	 lea	 eax, DWORD PTR [ebx-3]
  0074f	5b		 pop	 ebx
  00750	5f		 pop	 edi
  00751	5e		 pop	 esi

; 892  : }

  00752	8b e5		 mov	 esp, ebp
  00754	5d		 pop	 ebp
  00755	c3		 ret	 0
$LN4@deflate:

; 867  : 
; 868  :     /* Write the trailer */
; 869  : #ifdef GZIP
; 870  :     if (s->wrap == 2) {

  00756	83 f8 02	 cmp	 eax, 2
  00759	0f 85 82 00 00
	00		 jne	 $LN3@deflate

; 871  :         put_byte(s, (Byte)(strm->adler & 0xff));

  0075f	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]
  00763	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00766	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00769	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0076c	ff 46 14	 inc	 DWORD PTR [esi+20]

; 872  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  0076f	0f b6 47 31	 movzx	 eax, BYTE PTR [edi+49]
  00773	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00776	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00779	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0077c	ff 46 14	 inc	 DWORD PTR [esi+20]

; 873  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  0077f	0f b6 47 32	 movzx	 eax, BYTE PTR [edi+50]
  00783	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00786	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00789	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0078c	ff 46 14	 inc	 DWORD PTR [esi+20]

; 874  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  0078f	0f b6 47 33	 movzx	 eax, BYTE PTR [edi+51]
  00793	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00796	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00799	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0079c	ff 46 14	 inc	 DWORD PTR [esi+20]

; 875  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  0079f	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  007a3	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  007a6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007a9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007ac	ff 46 14	 inc	 DWORD PTR [esi+20]

; 876  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  007af	0f b6 47 09	 movzx	 eax, BYTE PTR [edi+9]
  007b3	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  007b6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007b9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007bc	ff 46 14	 inc	 DWORD PTR [esi+20]

; 877  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  007bf	0f b6 47 0a	 movzx	 eax, BYTE PTR [edi+10]
  007c3	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  007c6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007c9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007cc	ff 46 14	 inc	 DWORD PTR [esi+20]

; 878  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  007cf	0f b6 47 0b	 movzx	 eax, BYTE PTR [edi+11]
  007d3	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  007d6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007d9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007dc	ff 46 14	 inc	 DWORD PTR [esi+20]

; 879  :     }
; 880  :     else

  007df	eb 19		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 881  : #endif
; 882  :     {
; 883  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  007e1	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  007e5	50		 push	 eax
  007e6	56		 push	 esi
  007e7	e8 00 00 00 00	 call	 _putShortMSB

; 884  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  007ec	0f b7 47 30	 movzx	 eax, WORD PTR [edi+48]
  007f0	50		 push	 eax
  007f1	56		 push	 esi
  007f2	e8 00 00 00 00	 call	 _putShortMSB
  007f7	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@deflate:

; 885  :     }
; 886  :     flush_pending(strm);

  007fa	57		 push	 edi
  007fb	e8 00 00 00 00	 call	 _flush_pending

; 887  :     /* If avail_out is zero, the application will call deflate again
; 888  :      * to flush the rest.
; 889  :      */
; 890  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  00800	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00803	83 c4 04	 add	 esp, 4
  00806	85 c0		 test	 eax, eax
  00808	7e 05		 jle	 SHORT $LN1@deflate
  0080a	f7 d8		 neg	 eax
  0080c	89 46 18	 mov	 DWORD PTR [esi+24], eax
$LN1@deflate:

; 891  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0080f	33 c0		 xor	 eax, eax
  00811	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00814	5b		 pop	 ebx
  00815	5f		 pop	 edi
  00816	0f 94 c0	 sete	 al
  00819	5e		 pop	 esi

; 892  : }

  0081a	8b e5		 mov	 esp, ebp
  0081c	5d		 pop	 ebp
  0081d	c3		 ret	 0
$LN14@deflate:

; 828  :             if (strm->avail_out == 0) {

  0081e	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00822	0f 85 cf fd ff
	ff		 jne	 $LN13@deflate

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;

  00828	5b		 pop	 ebx
  00829	5f		 pop	 edi
  0082a	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1

; 797  :             return Z_OK;

  00831	33 c0		 xor	 eax, eax
  00833	5e		 pop	 esi

; 892  : }

  00834	8b e5		 mov	 esp, ebp
  00836	5d		 pop	 ebp
  00837	c3		 ret	 0
$LN80@deflate:

; 598  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  00838	a1 10 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+16
  0083d	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN82@deflate:
  00840	5f		 pop	 edi
  00841	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00846	5e		 pop	 esi

; 892  : }

  00847	8b e5		 mov	 esp, ebp
  00849	5d		 pop	 ebp
  0084a	c3		 ret	 0
_deflate ENDP
_TEXT	ENDS
END
