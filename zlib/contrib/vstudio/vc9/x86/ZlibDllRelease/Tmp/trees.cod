; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Mattia\Desktop\Audio plugin developement\esempi\CompzocchioGui 2.10\zlib\trees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__length_code
PUBLIC	__dist_code
_DATA	SEGMENT
_static_l_desc DD FLAT:_static_ltree
	DD	FLAT:_extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
_static_d_desc DD FLAT:_static_dtree
	DD	FLAT:_extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
_static_bl_desc DD 00H
	DD	FLAT:_extra_blbits
	DD	00H
	DD	013H
	DD	07H
_DATA	ENDS
CONST	SEGMENT
__length_code DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
__dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
_extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
_bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
_extra_blbits DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
_static_ltree DW 0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
_static_dtree DW 00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
_base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
_base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
CONST	ENDS
PUBLIC	__tr_init
PUBLIC	__tr_tally
PUBLIC	__tr_flush_block
PUBLIC	__tr_align
PUBLIC	__tr_stored_block
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _copy_block
_TEXT	SEGMENT
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_header$ = 20						; size = 4
_copy_block PROC					; COMDAT

; 1227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1228 :     bi_windup(s);        /* align on byte boundary */

  00005	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 _bi_windup

; 1229 :     s->last_eob_len = 8; /* enough lookahead for inflate */
; 1230 : 
; 1231 :     if (header) {

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00011	83 c4 04	 add	 esp, 4
  00014	83 7d 14 00	 cmp	 DWORD PTR _header$[ebp], 0
  00018	c7 86 b4 16 00
	00 08 00 00 00	 mov	 DWORD PTR [esi+5812], 8
  00022	74 40		 je	 SHORT $LN6@copy_block

; 1232 :         put_short(s, (ush)len);

  00024	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  0002d	ff 46 14	 inc	 DWORD PTR [esi+20]
  00030	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00033	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00036	8b cb		 mov	 ecx, ebx
  00038	c1 e9 08	 shr	 ecx, 8
  0003b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0003e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00041	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 1233 :         put_short(s, (ush)~len);

  00044	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00047	8a cb		 mov	 cl, bl
  00049	f6 d1		 not	 cl
  0004b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0004e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00051	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00054	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00057	8b cb		 mov	 ecx, ebx
  00059	f7 d1		 not	 ecx
  0005b	c1 e9 08	 shr	 ecx, 8
  0005e	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00061	ff 46 14	 inc	 DWORD PTR [esi+20]
$LN6@copy_block:

; 1234 : #ifdef DEBUG
; 1235 :         s->bits_sent += 2*16;
; 1236 : #endif
; 1237 :     }
; 1238 : #ifdef DEBUG
; 1239 :     s->bits_sent += (ulg)len<<3;
; 1240 : #endif
; 1241 :     while (len--) {

  00064	85 db		 test	 ebx, ebx
  00066	74 1d		 je	 SHORT $LN7@copy_block
  00068	57		 push	 edi
  00069	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  0006c	8d 64 24 00	 npad	 4
$LL2@copy_block:

; 1242 :         put_byte(s, *buf++);

  00070	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00073	8a 07		 mov	 al, BYTE PTR [edi]
  00075	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00078	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0007b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0007e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00081	4b		 dec	 ebx
  00082	75 ec		 jne	 SHORT $LL2@copy_block
  00084	5f		 pop	 edi
$LN7@copy_block:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1243 :     }
; 1244 : }

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_copy_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _bi_flush
_TEXT	SEGMENT
_s$ = 8							; size = 4
_bi_flush PROC						; COMDAT

; 1188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1189 :     if (s->bi_valid == 16) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  0000d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00010	75 38		 jne	 SHORT $LN3@bi_flush

; 1190 :         put_short(s, s->bi_buf);

  00012	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00015	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0001c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0001f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00022	ff 46 14	 inc	 DWORD PTR [esi+20]
  00025	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  0002c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00032	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00035	ff 46 14	 inc	 DWORD PTR [esi+20]

; 1191 :         s->bi_buf = 0;

  00038	33 c0		 xor	 eax, eax

; 1192 :         s->bi_valid = 0;

  0003a	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax

; 1195 :         s->bi_buf >>= 8;

  00040	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  00047	5e		 pop	 esi

; 1197 :     }
; 1198 : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN3@bi_flush:

; 1193 :     } else if (s->bi_valid >= 8) {

  0004a	83 f8 08	 cmp	 eax, 8
  0004d	7c 27		 jl	 SHORT $LN1@bi_flush

; 1194 :         put_byte(s, (Byte)s->bi_buf);

  0004f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00052	8a 86 b8 16 00
	00		 mov	 al, BYTE PTR [esi+5816]
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1195 :         s->bi_buf >>= 8;

  0005e	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  00065	ff 46 14	 inc	 DWORD PTR [esi+20]

; 1196 :         s->bi_valid -= 8;

  00068	83 86 bc 16 00
	00 f8		 add	 DWORD PTR [esi+5820], -8 ; fffffff8H
  0006f	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
$LN1@bi_flush:
  00076	5e		 pop	 esi

; 1197 :     }
; 1198 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_bi_flush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _bi_windup
_TEXT	SEGMENT
_s$ = 8							; size = 4
_bi_windup PROC						; COMDAT

; 1205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1206 :     if (s->bi_valid > 8) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  0000d	83 f8 08	 cmp	 eax, 8
  00010	7e 22		 jle	 SHORT $LN3@bi_windup

; 1207 :         put_short(s, s->bi_buf);

  00012	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00015	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0001c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0001f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00022	ff 46 14	 inc	 DWORD PTR [esi+20]
  00025	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002b	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  00032	eb 10		 jmp	 SHORT $LN6@bi_windup
$LN3@bi_windup:

; 1208 :     } else if (s->bi_valid > 0) {

  00034	85 c0		 test	 eax, eax
  00036	7e 12		 jle	 SHORT $LN1@bi_windup

; 1209 :         put_byte(s, (Byte)s->bi_buf);

  00038	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003e	8a 86 b8 16 00
	00		 mov	 al, BYTE PTR [esi+5816]
$LN6@bi_windup:
  00044	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00047	ff 46 14	 inc	 DWORD PTR [esi+20]
$LN1@bi_windup:

; 1210 :     }
; 1211 :     s->bi_buf = 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax

; 1212 :     s->bi_valid = 0;

  00053	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  00059	5e		 pop	 esi

; 1213 : #ifdef DEBUG
; 1214 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1215 : #endif
; 1216 : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_bi_windup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _bi_reverse
_TEXT	SEGMENT
_code$ = 8						; size = 4
_len$ = 12						; size = 4
_bi_reverse PROC					; COMDAT

; 1174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1175 :     register unsigned res = 0;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _code$[ebp]
  0000a	33 c0		 xor	 eax, eax
  0000c	8d 64 24 00	 npad	 4
$LL3@bi_reverse:

; 1176 :     do {
; 1177 :         res |= code & 1;

  00010	8b ce		 mov	 ecx, esi
  00012	83 e1 01	 and	 ecx, 1
  00015	0b c1		 or	 eax, ecx

; 1178 :         code >>= 1, res <<= 1;
; 1179 :     } while (--len > 0);

  00017	4a		 dec	 edx
  00018	d1 ee		 shr	 esi, 1
  0001a	03 c0		 add	 eax, eax
  0001c	85 d2		 test	 edx, edx
  0001e	7f f0		 jg	 SHORT $LL3@bi_reverse

; 1180 :     return res >> 1;

  00020	d1 e8		 shr	 eax, 1
  00022	5e		 pop	 esi

; 1181 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_bi_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _detect_data_type
_TEXT	SEGMENT
_s$ = 8							; size = 4
_detect_data_type PROC					; COMDAT

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1140 :     /* black_mask is the bit mask of black-listed bytes
; 1141 :      * set bits 0..6, 14..25, and 28..31
; 1142 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1143 :      */
; 1144 :     unsigned long black_mask = 0xf3ffc07fUL;

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	b8 7f c0 ff f3	 mov	 eax, -201342849		; f3ffc07fH

; 1145 :     int n;
; 1146 : 
; 1147 :     /* Check for non-textual ("black-listed") bytes. */
; 1148 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  0000c	33 d2		 xor	 edx, edx
  0000e	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
$LL10@detect_dat:

; 1149 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00014	a8 01		 test	 al, 1
  00016	74 06		 je	 SHORT $LN9@detect_dat
  00018	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  0001c	75 46		 jne	 SHORT $LN15@detect_dat
$LN9@detect_dat:

; 1145 :     int n;
; 1146 : 
; 1147 :     /* Check for non-textual ("black-listed") bytes. */
; 1148 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  0001e	42		 inc	 edx
  0001f	83 c1 04	 add	 ecx, 4
  00022	d1 e8		 shr	 eax, 1
  00024	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00027	7e eb		 jle	 SHORT $LL10@detect_dat

; 1150 :             return Z_BINARY;
; 1151 : 
; 1152 :     /* Check for textual ("white-listed") bytes. */
; 1153 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1154 :             || s->dyn_ltree[13].Freq != 0)

  00029	66 83 be b8 00
	00 00 00	 cmp	 WORD PTR [esi+184], 0
  00031	75 36		 jne	 SHORT $LN5@detect_dat
  00033	66 83 be bc 00
	00 00 00	 cmp	 WORD PTR [esi+188], 0
  0003b	75 2c		 jne	 SHORT $LN5@detect_dat
  0003d	66 83 be c8 00
	00 00 00	 cmp	 WORD PTR [esi+200], 0
  00045	75 22		 jne	 SHORT $LN5@detect_dat

; 1156 :     for (n = 32; n < LITERALS; n++)

  00047	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004c	8d 86 14 01 00
	00		 lea	 eax, DWORD PTR [esi+276]
$LL4@detect_dat:

; 1157 :         if (s->dyn_ltree[n].Freq != 0)

  00052	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00056	75 11		 jne	 SHORT $LN5@detect_dat

; 1156 :     for (n = 32; n < LITERALS; n++)

  00058	41		 inc	 ecx
  00059	83 c0 04	 add	 eax, 4
  0005c	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00062	7c ee		 jl	 SHORT $LL4@detect_dat
$LN15@detect_dat:

; 1158 :             return Z_TEXT;
; 1159 : 
; 1160 :     /* There are no "black-listed" or "white-listed" bytes:
; 1161 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1162 :      */
; 1163 :     return Z_BINARY;

  00064	33 c0		 xor	 eax, eax
  00066	5e		 pop	 esi

; 1164 : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN5@detect_dat:

; 1155 :         return Z_TEXT;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	5e		 pop	 esi

; 1164 : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_detect_data_type ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _compress_block
_TEXT	SEGMENT
_lx$1$ = -16						; size = 4
_extra$1$ = -12						; size = 4
_lc$1$ = -12						; size = 4
_len$1$ = -8						; size = 4
_code$2$ = -8						; size = 4
_len$1$ = -4						; size = 4
_code$1$ = -4						; size = 4
_s$ = 8							; size = 4
_len$1$ = 12						; size = 4
_ltree$ = 12						; size = 4
_dtree$ = 16						; size = 4
_compress_block PROC					; COMDAT

; 1080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1081 :     unsigned dist;      /* distance of matched string */
; 1082 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1083 :     unsigned lx = 0;    /* running index in l_buf */
; 1084 :     unsigned code;      /* the code to send */
; 1085 :     int extra;          /* number of extra bits to send */
; 1086 : 
; 1087 :     if (s->last_lit != 0) do {

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	33 d2		 xor	 edx, edx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8d 72 10	 lea	 esi, DWORD PTR [edx+16]
  00011	39 90 a0 16 00
	00		 cmp	 DWORD PTR [eax+5792], edx
  00017	0f 84 2d 03 00
	00		 je	 $LN17@compress_b
  0001d	8d 49 00	 npad	 3
$LL19@compress_b:

; 1088 :         dist = s->d_buf[lx];

  00020	8b 88 a4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5796]

; 1089 :         lc = s->l_buf[lx++];

  00026	42		 inc	 edx
  00027	0f b7 5c 51 fe	 movzx	 ebx, WORD PTR [ecx+edx*2-2]
  0002c	8b 88 98 16 00
	00		 mov	 ecx, DWORD PTR [eax+5784]
  00032	89 55 f0	 mov	 DWORD PTR _lx$1$[ebp], edx
  00035	0f b6 7c 0a ff	 movzx	 edi, BYTE PTR [edx+ecx-1]
  0003a	89 7d f4	 mov	 DWORD PTR _lc$1$[ebp], edi

; 1090 :         if (dist == 0) {

  0003d	85 db		 test	 ebx, ebx
  0003f	0f 85 86 00 00
	00		 jne	 $LN16@compress_b

; 1091 :             send_code(s, lc, ltree); /* send a literal byte */

  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _ltree$[ebp]
  00048	8b d6		 mov	 edx, esi
  0004a	0f b7 5c b9 02	 movzx	 ebx, WORD PTR [ecx+edi*4+2]
  0004f	8d 3c b9	 lea	 edi, DWORD PTR [ecx+edi*4]
  00052	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00058	2b d3		 sub	 edx, ebx
  0005a	3b ca		 cmp	 ecx, edx
  0005c	7e 59		 jle	 SHORT $LN15@compress_b
  0005e	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  00061	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00064	66 8b d7	 mov	 dx, di
  00067	66 d3 e2	 shl	 dx, cl
  0006a	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00071	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00074	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  0007b	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0007e	ff 40 14	 inc	 DWORD PTR [eax+20]
  00081	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00088	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0008b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0008e	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00091	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00097	ff 40 14	 inc	 DWORD PTR [eax+20]
  0009a	b1 10		 mov	 cl, 16			; 00000010H
  0009c	2a ca		 sub	 cl, dl
  0009e	66 d3 ef	 shr	 di, cl
  000a1	8d 4b f0	 lea	 ecx, DWORD PTR [ebx-16]
  000a4	03 ca		 add	 ecx, edx
  000a6	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  000ab	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  000b2	e9 7e 02 00 00	 jmp	 $LN27@compress_b
$LN15@compress_b:
  000b7	66 8b 17	 mov	 dx, WORD PTR [edi]
  000ba	66 d3 e2	 shl	 dx, cl
  000bd	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  000c4	03 cb		 add	 ecx, ebx

; 1092 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1093 :         } else {

  000c6	e9 6a 02 00 00	 jmp	 $LN27@compress_b
$LN16@compress_b:

; 1094 :             /* Here, lc is the match length - MIN_MATCH */
; 1095 :             code = _length_code[lc];

  000cb	0f b6 8f 00 00
	00 00		 movzx	 ecx, BYTE PTR __length_code[edi]

; 1096 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  000d2	8b 55 0c	 mov	 edx, DWORD PTR _ltree$[ebp]
  000d5	89 4d fc	 mov	 DWORD PTR _code$1$[ebp], ecx
  000d8	0f b7 8c 8a 06
	04 00 00	 movzx	 ecx, WORD PTR [edx+ecx*4+1030]
  000e0	89 4d f8	 mov	 DWORD PTR _len$1$[ebp], ecx
  000e3	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  000e9	8b d6		 mov	 edx, esi
  000eb	8b 75 f8	 mov	 esi, DWORD PTR _len$1$[ebp]
  000ee	2b d6		 sub	 edx, esi
  000f0	3b ca		 cmp	 ecx, edx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _code$1$[ebp]
  000f5	7e 5f		 jle	 SHORT $LN12@compress_b
  000f7	8b 75 0c	 mov	 esi, DWORD PTR _ltree$[ebp]
  000fa	0f b7 bc 96 04
	04 00 00	 movzx	 edi, WORD PTR [esi+edx*4+1028]
  00102	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00105	66 8b d7	 mov	 dx, di
  00108	66 d3 e2	 shl	 dx, cl
  0010b	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00112	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00115	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  0011c	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0011f	ff 40 14	 inc	 DWORD PTR [eax+20]
  00122	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00129	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0012c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0012f	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00132	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00138	ff 40 14	 inc	 DWORD PTR [eax+20]
  0013b	b1 10		 mov	 cl, 16			; 00000010H
  0013d	2a ca		 sub	 cl, dl
  0013f	66 d3 ef	 shr	 di, cl
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _len$1$[ebp]
  00145	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00148	03 ca		 add	 ecx, edx
  0014a	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00151	8b 7d f4	 mov	 edi, DWORD PTR _lc$1$[ebp]
  00154	eb 1a		 jmp	 SHORT $LN28@compress_b
$LN12@compress_b:
  00156	8b 45 0c	 mov	 eax, DWORD PTR _ltree$[ebp]
  00159	66 8b 94 90 04
	04 00 00	 mov	 dx, WORD PTR [eax+edx*4+1028]
  00161	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00164	66 d3 e2	 shl	 dx, cl
  00167	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0016e	03 ce		 add	 ecx, esi
$LN28@compress_b:
  00170	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx

; 1097 :             extra = extra_lbits[code];

  00176	8b 4d fc	 mov	 ecx, DWORD PTR _code$1$[ebp]
  00179	8b 34 8d 00 00
	00 00		 mov	 esi, DWORD PTR _extra_lbits[ecx*4]
  00180	89 75 f4	 mov	 DWORD PTR _extra$1$[ebp], esi

; 1098 :             if (extra != 0) {

  00183	85 f6		 test	 esi, esi
  00185	74 7b		 je	 SHORT $LN8@compress_b

; 1099 :                 lc -= base_length[code];

  00187	2b 3c 8d 00 00
	00 00		 sub	 edi, DWORD PTR _base_length[ecx*4]

; 1100 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  0018e	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00194	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00199	2b d6		 sub	 edx, esi
  0019b	3b ca		 cmp	 ecx, edx
  0019d	7e 51		 jle	 SHORT $LN9@compress_b
  0019f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  001a2	66 8b d7	 mov	 dx, di
  001a5	66 d3 e2	 shl	 dx, cl
  001a8	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  001af	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001b2	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  001b9	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  001bc	ff 40 14	 inc	 DWORD PTR [eax+20]
  001bf	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  001c6	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  001cf	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  001d5	ff 40 14	 inc	 DWORD PTR [eax+20]
  001d8	b1 10		 mov	 cl, 16			; 00000010H
  001da	2a ca		 sub	 cl, dl
  001dc	66 d3 ef	 shr	 di, cl
  001df	8b 4d f4	 mov	 ecx, DWORD PTR _extra$1$[ebp]
  001e2	83 c1 f0	 add	 ecx, -16		; fffffff0H
  001e5	03 ca		 add	 ecx, edx
  001e7	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  001ee	eb 0c		 jmp	 SHORT $LN29@compress_b
$LN9@compress_b:
  001f0	66 d3 e7	 shl	 di, cl
  001f3	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  001fa	03 ce		 add	 ecx, esi
$LN29@compress_b:
  001fc	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN8@compress_b:

; 1101 :             }
; 1102 :             dist--; /* dist is now the match distance - 1 */

  00202	4b		 dec	 ebx

; 1103 :             code = d_code(dist);

  00203	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00209	73 09		 jae	 SHORT $LN23@compress_b
  0020b	0f b6 8b 00 00
	00 00		 movzx	 ecx, BYTE PTR __dist_code[ebx]
  00212	eb 0c		 jmp	 SHORT $LN30@compress_b
$LN23@compress_b:
  00214	8b cb		 mov	 ecx, ebx
  00216	c1 e9 07	 shr	 ecx, 7
  00219	0f b6 89 00 01
	00 00		 movzx	 ecx, BYTE PTR __dist_code[ecx+256]
$LN30@compress_b:

; 1104 :             Assert (code < D_CODES, "bad d_code");
; 1105 : 
; 1106 :             send_code(s, code, dtree);       /* send the distance code */

  00220	8b 55 10	 mov	 edx, DWORD PTR _dtree$[ebp]
  00223	89 4d f8	 mov	 DWORD PTR _code$2$[ebp], ecx
  00226	8d 3c 8a	 lea	 edi, DWORD PTR [edx+ecx*4]
  00229	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0022e	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00232	89 4d fc	 mov	 DWORD PTR _len$1$[ebp], ecx
  00235	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0023b	8b d6		 mov	 edx, esi
  0023d	2b 55 fc	 sub	 edx, DWORD PTR _len$1$[ebp]
  00240	3b ca		 cmp	 ecx, edx
  00242	7e 59		 jle	 SHORT $LN7@compress_b
  00244	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  00247	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0024a	66 8b d7	 mov	 dx, di
  0024d	66 d3 e2	 shl	 dx, cl
  00250	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00257	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0025a	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00261	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00264	ff 40 14	 inc	 DWORD PTR [eax+20]
  00267	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  0026e	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00271	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00274	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00277	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0027d	ff 40 14	 inc	 DWORD PTR [eax+20]
  00280	b1 10		 mov	 cl, 16			; 00000010H
  00282	2a ca		 sub	 cl, dl
  00284	66 d3 ef	 shr	 di, cl
  00287	8b 4d fc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0028a	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0028d	03 ca		 add	 ecx, edx
  0028f	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00296	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0029b	eb 10		 jmp	 SHORT $LN31@compress_b
$LN7@compress_b:
  0029d	66 8b 17	 mov	 dx, WORD PTR [edi]
  002a0	66 d3 e2	 shl	 dx, cl
  002a3	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002aa	03 4d fc	 add	 ecx, DWORD PTR _len$1$[ebp]
$LN31@compress_b:
  002ad	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx

; 1107 :             extra = extra_dbits[code];

  002b3	8b 4d f8	 mov	 ecx, DWORD PTR _code$2$[ebp]
  002b6	8b 3c 8d 00 00
	00 00		 mov	 edi, DWORD PTR _extra_dbits[ecx*4]

; 1108 :             if (extra != 0) {

  002bd	85 ff		 test	 edi, edi
  002bf	74 7a		 je	 SHORT $LN18@compress_b

; 1109 :                 dist -= base_dist[code];

  002c1	2b 1c 8d 00 00
	00 00		 sub	 ebx, DWORD PTR _base_dist[ecx*4]

; 1110 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  002c8	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  002ce	8b d6		 mov	 edx, esi
  002d0	2b d7		 sub	 edx, edi
  002d2	3b ca		 cmp	 ecx, edx
  002d4	7e 53		 jle	 SHORT $LN4@compress_b
  002d6	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  002d9	66 8b d3	 mov	 dx, bx
  002dc	66 d3 e2	 shl	 dx, cl
  002df	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002e6	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002e9	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  002f0	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  002f3	ff 40 14	 inc	 DWORD PTR [eax+20]
  002f6	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  002fd	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00300	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00303	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00306	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0030c	ff 40 14	 inc	 DWORD PTR [eax+20]
  0030f	b1 10		 mov	 cl, 16			; 00000010H
  00311	2a ca		 sub	 cl, dl
  00313	66 d3 eb	 shr	 bx, cl
  00316	8d 4f f0	 lea	 ecx, DWORD PTR [edi-16]
  00319	03 ca		 add	 ecx, edx
  0031b	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00320	66 89 98 b8 16
	00 00		 mov	 WORD PTR [eax+5816], bx
  00327	eb 0c		 jmp	 SHORT $LN27@compress_b
$LN4@compress_b:
  00329	66 d3 e3	 shl	 bx, cl
  0032c	66 09 98 b8 16
	00 00		 or	 WORD PTR [eax+5816], bx
  00333	03 cf		 add	 ecx, edi
$LN27@compress_b:
  00335	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN18@compress_b:

; 1111 :             }
; 1112 :         } /* literal or match pair ? */
; 1113 : 
; 1114 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1115 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1116 :                "pendingBuf overflow");
; 1117 : 
; 1118 :     } while (lx < s->last_lit);

  0033b	8b 55 f0	 mov	 edx, DWORD PTR _lx$1$[ebp]
  0033e	3b 90 a0 16 00
	00		 cmp	 edx, DWORD PTR [eax+5792]
  00344	0f 82 d6 fc ff
	ff		 jb	 $LL19@compress_b
$LN17@compress_b:

; 1119 : 
; 1120 :     send_code(s, END_BLOCK, ltree);

  0034a	8b 5d 0c	 mov	 ebx, DWORD PTR _ltree$[ebp]
  0034d	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00353	0f b7 bb 02 04
	00 00		 movzx	 edi, WORD PTR [ebx+1026]
  0035a	2b f7		 sub	 esi, edi
  0035c	89 7d 0c	 mov	 DWORD PTR _len$1$[ebp], edi
  0035f	3b ce		 cmp	 ecx, esi
  00361	7e 58		 jle	 SHORT $LN2@compress_b
  00363	0f b7 bb 00 04
	00 00		 movzx	 edi, WORD PTR [ebx+1024]
  0036a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0036d	66 8b d7	 mov	 dx, di
  00370	66 d3 e2	 shl	 dx, cl
  00373	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0037a	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0037d	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00384	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00387	ff 40 14	 inc	 DWORD PTR [eax+20]
  0038a	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00391	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00394	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00397	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0039a	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  003a0	ff 40 14	 inc	 DWORD PTR [eax+20]
  003a3	b1 10		 mov	 cl, 16			; 00000010H
  003a5	2a ca		 sub	 cl, dl
  003a7	66 d3 ef	 shr	 di, cl
  003aa	8b 4d 0c	 mov	 ecx, DWORD PTR _len$1$[ebp]
  003ad	83 c1 f0	 add	 ecx, -16		; fffffff0H
  003b0	03 ca		 add	 ecx, edx
  003b2	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  003b9	eb 13		 jmp	 SHORT $LN32@compress_b
$LN2@compress_b:
  003bb	66 8b 93 00 04
	00 00		 mov	 dx, WORD PTR [ebx+1024]
  003c2	66 d3 e2	 shl	 dx, cl
  003c5	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  003cc	03 cf		 add	 ecx, edi
$LN32@compress_b:
  003ce	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx

; 1121 :     s->last_eob_len = ltree[END_BLOCK].Len;

  003d4	0f b7 8b 02 04
	00 00		 movzx	 ecx, WORD PTR [ebx+1026]
  003db	5f		 pop	 edi
  003dc	5e		 pop	 esi
  003dd	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  003e3	5b		 pop	 ebx

; 1122 : }

  003e4	8b e5		 mov	 esp, ebp
  003e6	5d		 pop	 ebp
  003e7	c3		 ret	 0
_compress_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _send_all_trees
_TEXT	SEGMENT
_s$ = 8							; size = 4
_lcodes$ = 12						; size = 4
_dcodes$ = 16						; size = 4
_blcodes$ = 20						; size = 4
_send_all_trees PROC					; COMDAT

; 845  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 846  :     int rank;                    /* index in bl_order */
; 847  : 
; 848  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 849  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 850  :             "too many codes");
; 851  :     Tracev((stderr, "\nbl counts: "));
; 852  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00005	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00008	57		 push	 edi
  00009	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  0000f	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00012	7e 55		 jle	 SHORT $LN11@send_all_t
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _lcodes$[ebp]
  00017	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0001a	81 c7 ff fe ff
	ff		 add	 edi, -257		; fffffeffH
  00020	66 8b c7	 mov	 ax, di
  00023	66 d3 e0	 shl	 ax, cl
  00026	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00029	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  00030	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  00037	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0003a	ff 46 14	 inc	 DWORD PTR [esi+20]
  0003d	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  00044	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00047	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0004d	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  00053	ff 46 14	 inc	 DWORD PTR [esi+20]
  00056	b1 10		 mov	 cl, 16			; 00000010H
  00058	2a c8		 sub	 cl, al
  0005a	66 d3 ef	 shr	 di, cl
  0005d	83 c0 f5	 add	 eax, -11		; fffffff5H
  00060	66 89 be b8 16
	00 00		 mov	 WORD PTR [esi+5816], di
  00067	eb 15		 jmp	 SHORT $LN17@send_all_t
$LN11@send_all_t:
  00069	8b 45 0c	 mov	 eax, DWORD PTR _lcodes$[ebp]
  0006c	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  00071	66 d3 e0	 shl	 ax, cl
  00074	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0007b	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]
$LN17@send_all_t:

; 853  :     send_bits(s, dcodes-1,   5);

  0007e	8b c8		 mov	 ecx, eax
  00080	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  00086	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00089	7e 50		 jle	 SHORT $LN9@send_all_t
  0008b	8b 7d 10	 mov	 edi, DWORD PTR _dcodes$[ebp]
  0008e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00091	4f		 dec	 edi
  00092	66 8b c7	 mov	 ax, di
  00095	66 d3 e0	 shl	 ax, cl
  00098	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009b	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  000a2	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  000a9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000ac	ff 46 14	 inc	 DWORD PTR [esi+20]
  000af	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  000b6	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000b9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000bc	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000bf	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  000c5	ff 46 14	 inc	 DWORD PTR [esi+20]
  000c8	b1 10		 mov	 cl, 16			; 00000010H
  000ca	2a c8		 sub	 cl, al
  000cc	66 d3 ef	 shr	 di, cl
  000cf	83 c0 f5	 add	 eax, -11		; fffffff5H
  000d2	66 89 be b8 16
	00 00		 mov	 WORD PTR [esi+5816], di
  000d9	eb 11		 jmp	 SHORT $LN18@send_all_t
$LN9@send_all_t:
  000db	8b 45 10	 mov	 eax, DWORD PTR _dcodes$[ebp]
  000de	48		 dec	 eax
  000df	66 d3 e0	 shl	 ax, cl
  000e2	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  000e9	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]
$LN18@send_all_t:

; 854  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  000ec	8b c8		 mov	 ecx, eax
  000ee	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  000f4	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  000f7	7e 52		 jle	 SHORT $LN7@send_all_t
  000f9	8b 7d 14	 mov	 edi, DWORD PTR _blcodes$[ebp]
  000fc	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000ff	83 c7 fc	 add	 edi, -4			; fffffffcH
  00102	66 8b c7	 mov	 ax, di
  00105	66 d3 e0	 shl	 ax, cl
  00108	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0010b	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  00112	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  00119	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0011c	ff 46 14	 inc	 DWORD PTR [esi+20]
  0011f	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  00126	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00129	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0012f	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  00135	ff 46 14	 inc	 DWORD PTR [esi+20]
  00138	b1 10		 mov	 cl, 16			; 00000010H
  0013a	2a c8		 sub	 cl, al
  0013c	66 d3 ef	 shr	 di, cl
  0013f	83 c0 f4	 add	 eax, -12		; fffffff4H
  00142	66 89 be b8 16
	00 00		 mov	 WORD PTR [esi+5816], di
  00149	eb 13		 jmp	 SHORT $LN19@send_all_t
$LN7@send_all_t:
  0014b	8b 45 14	 mov	 eax, DWORD PTR _blcodes$[ebp]
  0014e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00151	66 d3 e0	 shl	 ax, cl
  00154	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0015b	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN19@send_all_t:

; 855  :     for (rank = 0; rank < blcodes; rank++) {

  0015e	33 db		 xor	 ebx, ebx
  00160	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  00166	39 5d 14	 cmp	 DWORD PTR _blcodes$[ebp], ebx
  00169	0f 8e 8c 00 00
	00		 jle	 $LN3@send_all_t
  0016f	90		 npad	 1
$LL5@send_all_t:

; 856  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 857  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  00170	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  00176	0f b6 83 00 00
	00 00		 movzx	 eax, BYTE PTR _bl_order[ebx]
  0017d	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00180	7e 54		 jle	 SHORT $LN2@send_all_t
  00182	0f b7 bc 86 7e
	0a 00 00	 movzx	 edi, WORD PTR [esi+eax*4+2686]
  0018a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0018d	66 8b c7	 mov	 ax, di
  00190	66 d3 e0	 shl	 ax, cl
  00193	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00196	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0019d	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  001a4	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001a7	ff 46 14	 inc	 DWORD PTR [esi+20]
  001aa	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  001b1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b7	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001ba	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  001c0	ff 46 14	 inc	 DWORD PTR [esi+20]
  001c3	b1 10		 mov	 cl, 16			; 00000010H
  001c5	2a c8		 sub	 cl, al
  001c7	66 d3 ef	 shr	 di, cl
  001ca	83 c0 f3	 add	 eax, -13		; fffffff3H
  001cd	66 89 be b8 16
	00 00		 mov	 WORD PTR [esi+5816], di
  001d4	eb 15		 jmp	 SHORT $LN20@send_all_t
$LN2@send_all_t:
  001d6	66 8b 84 86 7e
	0a 00 00	 mov	 ax, WORD PTR [esi+eax*4+2686]
  001de	66 d3 e0	 shl	 ax, cl
  001e1	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  001e8	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
$LN20@send_all_t:
  001eb	43		 inc	 ebx
  001ec	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  001f2	3b 5d 14	 cmp	 ebx, DWORD PTR _blcodes$[ebp]
  001f5	0f 8c 75 ff ff
	ff		 jl	 $LL5@send_all_t
$LN3@send_all_t:

; 858  :     }
; 859  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 860  : 
; 861  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  001fb	8b 45 0c	 mov	 eax, DWORD PTR _lcodes$[ebp]
  001fe	48		 dec	 eax
  001ff	50		 push	 eax
  00200	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]
  00206	50		 push	 eax
  00207	56		 push	 esi
  00208	e8 00 00 00 00	 call	 _send_tree

; 862  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 863  : 
; 864  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  0020d	8b 45 10	 mov	 eax, DWORD PTR _dcodes$[ebp]
  00210	48		 dec	 eax
  00211	50		 push	 eax
  00212	8d 86 88 09 00
	00		 lea	 eax, DWORD PTR [esi+2440]
  00218	50		 push	 eax
  00219	56		 push	 esi
  0021a	e8 00 00 00 00	 call	 _send_tree
  0021f	83 c4 18	 add	 esp, 24			; 00000018H
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx

; 865  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 866  : }

  00225	5d		 pop	 ebp
  00226	c3		 ret	 0
_send_all_trees ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _build_bl_tree
_TEXT	SEGMENT
_s$ = 8							; size = 4
_build_bl_tree PROC					; COMDAT

; 809  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 810  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 811  : 
; 812  :     /* Determine the bit length frequencies for literal and distance trees */
; 813  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	ff b6 1c 0b 00
	00		 push	 DWORD PTR [esi+2844]
  0000d	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]
  00013	50		 push	 eax
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _scan_tree

; 814  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  0001a	ff b6 28 0b 00
	00		 push	 DWORD PTR [esi+2856]
  00020	8d 86 88 09 00
	00		 lea	 eax, DWORD PTR [esi+2440]
  00026	50		 push	 eax
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 _scan_tree

; 815  : 
; 816  :     /* Build the bit length tree: */
; 817  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  0002d	8d 86 30 0b 00
	00		 lea	 eax, DWORD PTR [esi+2864]
  00033	50		 push	 eax
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 _build_tree
  0003a	83 c4 20	 add	 esp, 32			; 00000020H

; 818  :     /* opt_len now includes the length of the tree representations, except
; 819  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 820  :      */
; 821  : 
; 822  :     /* Determine the number of bit length codes to send. The pkzip format
; 823  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 824  :      * 3 but the actual value used is 4.)
; 825  :      */
; 826  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0003d	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  00042	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL4@build_bl_t:

; 827  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00050	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bl_order[eax]
  00057	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00060	75 7b		 jne	 SHORT $LN8@build_bl_t
  00062	0f b6 88 ff ff
	ff ff		 movzx	 ecx, BYTE PTR _bl_order[eax-1]
  00069	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00072	75 68		 jne	 SHORT $LN11@build_bl_t
  00074	0f b6 88 fe ff
	ff ff		 movzx	 ecx, BYTE PTR _bl_order[eax-2]
  0007b	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00084	75 41		 jne	 SHORT $LN12@build_bl_t
  00086	0f b6 88 fd ff
	ff ff		 movzx	 ecx, BYTE PTR _bl_order[eax-3]
  0008d	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00096	75 1a		 jne	 SHORT $LN13@build_bl_t

; 818  :     /* opt_len now includes the length of the tree representations, except
; 819  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 820  :      */
; 821  : 
; 822  :     /* Determine the number of bit length codes to send. The pkzip format
; 823  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 824  :      * 3 but the actual value used is 4.)
; 825  :      */
; 826  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  00098	83 e8 04	 sub	 eax, 4
  0009b	83 f8 03	 cmp	 eax, 3
  0009e	7d b0		 jge	 SHORT $LL4@build_bl_t

; 828  :     }
; 829  :     /* Update opt_len to include the bit length tree and counts */
; 830  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000a0	8d 0c 45 11 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+17]
  000a7	03 c8		 add	 ecx, eax
  000a9	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000af	5e		 pop	 esi

; 831  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 832  :             s->opt_len, s->static_len));
; 833  : 
; 834  :     return max_blindex;
; 835  : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN13@build_bl_t:

; 827  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000b2	83 e8 03	 sub	 eax, 3

; 828  :     }
; 829  :     /* Update opt_len to include the bit length tree and counts */
; 830  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000b5	8d 0c 45 11 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+17]
  000bc	03 c8		 add	 ecx, eax
  000be	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000c4	5e		 pop	 esi

; 831  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 832  :             s->opt_len, s->static_len));
; 833  : 
; 834  :     return max_blindex;
; 835  : }

  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN12@build_bl_t:

; 827  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000c7	83 e8 02	 sub	 eax, 2

; 828  :     }
; 829  :     /* Update opt_len to include the bit length tree and counts */
; 830  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000ca	8d 0c 45 11 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+17]
  000d1	03 c8		 add	 ecx, eax
  000d3	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000d9	5e		 pop	 esi

; 831  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 832  :             s->opt_len, s->static_len));
; 833  : 
; 834  :     return max_blindex;
; 835  : }

  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN11@build_bl_t:

; 827  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000dc	48		 dec	 eax
$LN8@build_bl_t:

; 828  :     }
; 829  :     /* Update opt_len to include the bit length tree and counts */
; 830  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000dd	8d 0c 45 11 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+17]
  000e4	03 c8		 add	 ecx, eax
  000e6	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000ec	5e		 pop	 esi

; 831  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 832  :             s->opt_len, s->static_len));
; 833  : 
; 834  :     return max_blindex;
; 835  : }

  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_build_bl_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _send_tree
_TEXT	SEGMENT
_curlen$1$ = -20					; size = 4
tv1249 = -16						; size = 4
_len$1$ = -16						; size = 4
_len$1$ = -16						; size = 4
_len$1$ = -16						; size = 4
_len$1$ = -16						; size = 4
tv1227 = -12						; size = 4
_len$1$ = -8						; size = 4
tv1250 = -4						; size = 4
_s$ = 8							; size = 4
tv1196 = 12						; size = 4
_tree$ = 12						; size = 4
_nextlen$1$ = 16					; size = 4
_max_code$ = 16						; size = 4
_send_tree PROC						; COMDAT

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  :     int n;                     /* iterates over all tree elements */
; 762  :     int prevlen = -1;          /* last emitted length */
; 763  :     int curlen;                /* length of current code */
; 764  :     int nextlen = tree[0].Len; /* length of next code */

  00003	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	83 cf ff	 or	 edi, -1

; 765  :     int count = 0;             /* repeat count of the current code */

  00013	33 db		 xor	 ebx, ebx

; 766  :     int max_count = 7;         /* max repeat count */

  00015	8d 77 08	 lea	 esi, DWORD PTR [edi+8]

; 767  :     int min_count = 4;         /* min repeat count */

  00018	8d 57 05	 lea	 edx, DWORD PTR [edi+5]

; 768  : 
; 769  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 770  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0001b	85 c9		 test	 ecx, ecx
  0001d	75 08		 jne	 SHORT $LN36@send_tree
  0001f	be 8a 00 00 00	 mov	 esi, 138		; 0000008aH
  00024	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$LN36@send_tree:

; 771  : 
; 772  :     for (n = 0; n <= max_code; n++) {

  00027	8b 45 10	 mov	 eax, DWORD PTR _max_code$[ebp]
  0002a	85 c0		 test	 eax, eax
  0002c	0f 88 a7 04 00
	00		 js	 $LN33@send_tree
  00032	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00035	83 c0 06	 add	 eax, 6
  00038	89 45 0c	 mov	 DWORD PTR tv1196[ebp], eax
  0003b	8b 45 10	 mov	 eax, DWORD PTR _max_code$[ebp]
  0003e	40		 inc	 eax
  0003f	89 45 fc	 mov	 DWORD PTR tv1250[ebp], eax
$LL35@send_tree:

; 773  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00042	8b 45 0c	 mov	 eax, DWORD PTR tv1196[ebp]

; 774  :         if (++count < max_count && curlen == nextlen) {

  00045	43		 inc	 ebx
  00046	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00049	89 45 10	 mov	 DWORD PTR _nextlen$1$[ebp], eax
  0004c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004f	89 4d ec	 mov	 DWORD PTR _curlen$1$[ebp], ecx
  00052	3b de		 cmp	 ebx, esi
  00054	7d 09		 jge	 SHORT $LN32@send_tree
  00056	3b 4d 10	 cmp	 ecx, DWORD PTR _nextlen$1$[ebp]
  00059	0f 84 6a 04 00
	00		 je	 $LN34@send_tree
$LN32@send_tree:

; 775  :             continue;
; 776  :         } else if (count < min_count) {

  0005f	3b da		 cmp	 ebx, edx
  00061	0f 8d ab 00 00
	00		 jge	 $LN30@send_tree
  00067	8d 90 7e 0a 00
	00		 lea	 edx, DWORD PTR [eax+2686]
  0006d	8d b8 7c 0a 00
	00		 lea	 edi, DWORD PTR [eax+2684]
  00073	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00076	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  00079	89 55 f0	 mov	 DWORD PTR tv1249[ebp], edx
  0007c	89 7d f4	 mov	 DWORD PTR tv1227[ebp], edi
  0007f	90		 npad	 1
$LL29@send_tree:

; 777  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  00080	0f b7 32	 movzx	 esi, WORD PTR [edx]
  00083	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00089	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0008e	2b d6		 sub	 edx, esi
  00090	89 75 f8	 mov	 DWORD PTR _len$1$[ebp], esi
  00093	3b ca		 cmp	 ecx, edx
  00095	7e 57		 jle	 SHORT $LN26@send_tree
  00097	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  0009a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0009d	66 8b d7	 mov	 dx, di
  000a0	66 d3 e2	 shl	 dx, cl
  000a3	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  000aa	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ad	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  000b4	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  000b7	ff 40 14	 inc	 DWORD PTR [eax+20]
  000ba	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  000c1	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  000c4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c7	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  000ca	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  000d0	ff 40 14	 inc	 DWORD PTR [eax+20]
  000d3	b1 10		 mov	 cl, 16			; 00000010H
  000d5	2a ca		 sub	 cl, dl
  000d7	66 d3 ef	 shr	 di, cl
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _len$1$[ebp]
  000dd	83 c1 f0	 add	 ecx, -16		; fffffff0H
  000e0	03 ca		 add	 ecx, edx
  000e2	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  000e9	8b 7d f4	 mov	 edi, DWORD PTR tv1227[ebp]
  000ec	eb 0f		 jmp	 SHORT $LN44@send_tree
$LN26@send_tree:
  000ee	66 8b 17	 mov	 dx, WORD PTR [edi]
  000f1	66 d3 e2	 shl	 dx, cl
  000f4	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  000fb	03 ce		 add	 ecx, esi
$LN44@send_tree:
  000fd	8b 55 f0	 mov	 edx, DWORD PTR tv1249[ebp]
  00100	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00106	4b		 dec	 ebx
  00107	0f 85 73 ff ff
	ff		 jne	 $LL29@send_tree

; 778  : 
; 779  :         } else if (curlen != 0) {

  0010d	e9 89 03 00 00	 jmp	 $LN5@send_tree
$LN30@send_tree:
  00112	85 c9		 test	 ecx, ecx
  00114	0f 84 95 01 00
	00		 je	 $LN23@send_tree

; 780  :             if (curlen != prevlen) {

  0011a	3b cf		 cmp	 ecx, edi
  0011c	0f 84 95 00 00
	00		 je	 $LN22@send_tree

; 781  :                 send_code(s, curlen, s->bl_tree); count--;

  00122	0f b7 bc 88 7e
	0a 00 00	 movzx	 edi, WORD PTR [eax+ecx*4+2686]
  0012a	8b b0 bc 16 00
	00		 mov	 esi, DWORD PTR [eax+5820]
  00130	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00135	2b d7		 sub	 edx, edi
  00137	89 7d f0	 mov	 DWORD PTR _len$1$[ebp], edi
  0013a	3b f2		 cmp	 esi, edx
  0013c	7e 5b		 jle	 SHORT $LN21@send_tree
  0013e	0f b7 bc 88 7c
	0a 00 00	 movzx	 edi, WORD PTR [eax+ecx*4+2684]
  00146	8b ce		 mov	 ecx, esi
  00148	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0014b	66 8b d7	 mov	 dx, di
  0014e	66 d3 e2	 shl	 dx, cl
  00151	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00158	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0015b	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00162	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00165	ff 40 14	 inc	 DWORD PTR [eax+20]
  00168	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  0016f	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00172	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00175	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00178	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0017e	ff 40 14	 inc	 DWORD PTR [eax+20]
  00181	b1 10		 mov	 cl, 16			; 00000010H
  00183	2a ca		 sub	 cl, dl
  00185	66 d3 ef	 shr	 di, cl
  00188	8b 4d f0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0018b	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0018e	03 ca		 add	 ecx, edx
  00190	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00197	eb 17		 jmp	 SHORT $LN45@send_tree
$LN21@send_tree:
  00199	66 8b 94 88 7c
	0a 00 00	 mov	 dx, WORD PTR [eax+ecx*4+2684]
  001a1	8b ce		 mov	 ecx, esi
  001a3	66 d3 e2	 shl	 dx, cl
  001a6	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  001a9	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
$LN45@send_tree:
  001b0	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  001b6	4b		 dec	 ebx
$LN22@send_tree:

; 782  :             }
; 783  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 784  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  001b7	0f b7 b0 be 0a
	00 00		 movzx	 esi, WORD PTR [eax+2750]
  001be	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  001c4	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  001c9	2b d6		 sub	 edx, esi
  001cb	89 75 f0	 mov	 DWORD PTR _len$1$[ebp], esi
  001ce	3b ca		 cmp	 ecx, edx
  001d0	7e 58		 jle	 SHORT $LN19@send_tree
  001d2	0f b7 b8 bc 0a
	00 00		 movzx	 edi, WORD PTR [eax+2748]
  001d9	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  001dc	66 8b d7	 mov	 dx, di
  001df	66 d3 e2	 shl	 dx, cl
  001e2	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  001e9	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001ec	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  001f3	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  001f6	ff 40 14	 inc	 DWORD PTR [eax+20]
  001f9	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00200	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00203	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00206	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00209	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0020f	ff 40 14	 inc	 DWORD PTR [eax+20]
  00212	b1 10		 mov	 cl, 16			; 00000010H
  00214	2a ca		 sub	 cl, dl
  00216	66 d3 ef	 shr	 di, cl
  00219	8b 4d f0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0021c	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0021f	03 ca		 add	 ecx, edx
  00221	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00228	eb 13		 jmp	 SHORT $LN46@send_tree
$LN19@send_tree:
  0022a	66 8b 90 bc 0a
	00 00		 mov	 dx, WORD PTR [eax+2748]
  00231	66 d3 e2	 shl	 dx, cl
  00234	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0023b	03 ce		 add	 ecx, esi
$LN46@send_tree:
  0023d	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00243	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00246	7e 52		 jle	 SHORT $LN17@send_tree
  00248	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0024b	8d 7b fd	 lea	 edi, DWORD PTR [ebx-3]
  0024e	66 8b d7	 mov	 dx, di
  00251	66 d3 e2	 shl	 dx, cl
  00254	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0025b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0025e	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00265	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00268	ff 40 14	 inc	 DWORD PTR [eax+20]
  0026b	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00272	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00275	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00278	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0027b	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00281	ff 40 14	 inc	 DWORD PTR [eax+20]
  00284	b1 10		 mov	 cl, 16			; 00000010H
  00286	2a ca		 sub	 cl, dl
  00288	66 d3 ef	 shr	 di, cl
  0028b	8d 4a f2	 lea	 ecx, DWORD PTR [edx-14]
  0028e	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00295	e9 fb 01 00 00	 jmp	 $LN47@send_tree
$LN17@send_tree:
  0029a	8d 53 fd	 lea	 edx, DWORD PTR [ebx-3]
  0029d	66 d3 e2	 shl	 dx, cl
  002a0	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002a7	83 c1 02	 add	 ecx, 2
  002aa	e9 e6 01 00 00	 jmp	 $LN47@send_tree
$LN23@send_tree:

; 785  : 
; 786  :         } else if (count <= 10) {
; 787  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  002af	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  002b5	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  002ba	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  002bd	0f 8f ed 00 00
	00		 jg	 $LN14@send_tree
  002c3	0f b7 b0 c2 0a
	00 00		 movzx	 esi, WORD PTR [eax+2754]
  002ca	2b d6		 sub	 edx, esi
  002cc	89 75 f0	 mov	 DWORD PTR _len$1$[ebp], esi
  002cf	3b ca		 cmp	 ecx, edx
  002d1	7e 58		 jle	 SHORT $LN13@send_tree
  002d3	0f b7 b8 c0 0a
	00 00		 movzx	 edi, WORD PTR [eax+2752]
  002da	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  002dd	66 8b d7	 mov	 dx, di
  002e0	66 d3 e2	 shl	 dx, cl
  002e3	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002ea	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002ed	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  002f4	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  002f7	ff 40 14	 inc	 DWORD PTR [eax+20]
  002fa	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00301	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00304	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00307	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0030a	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00310	ff 40 14	 inc	 DWORD PTR [eax+20]
  00313	b1 10		 mov	 cl, 16			; 00000010H
  00315	2a ca		 sub	 cl, dl
  00317	66 d3 ef	 shr	 di, cl
  0031a	8b 4d f0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0031d	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00320	03 ca		 add	 ecx, edx
  00322	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00329	eb 13		 jmp	 SHORT $LN48@send_tree
$LN13@send_tree:
  0032b	66 8b 90 c0 0a
	00 00		 mov	 dx, WORD PTR [eax+2752]
  00332	66 d3 e2	 shl	 dx, cl
  00335	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0033c	03 ce		 add	 ecx, esi
$LN48@send_tree:
  0033e	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00344	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00347	7e 52		 jle	 SHORT $LN11@send_tree
  00349	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0034c	8d 7b fd	 lea	 edi, DWORD PTR [ebx-3]
  0034f	66 8b d7	 mov	 dx, di
  00352	66 d3 e2	 shl	 dx, cl
  00355	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0035c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0035f	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00366	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00369	ff 40 14	 inc	 DWORD PTR [eax+20]
  0036c	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00373	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00376	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00379	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  0037c	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00382	ff 40 14	 inc	 DWORD PTR [eax+20]
  00385	b1 10		 mov	 cl, 16			; 00000010H
  00387	2a ca		 sub	 cl, dl
  00389	66 d3 ef	 shr	 di, cl
  0038c	8d 4a f3	 lea	 ecx, DWORD PTR [edx-13]
  0038f	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00396	e9 fa 00 00 00	 jmp	 $LN47@send_tree
$LN11@send_tree:
  0039b	8d 53 fd	 lea	 edx, DWORD PTR [ebx-3]
  0039e	66 d3 e2	 shl	 dx, cl
  003a1	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  003a8	83 c1 03	 add	 ecx, 3

; 788  : 
; 789  :         } else {

  003ab	e9 e5 00 00 00	 jmp	 $LN47@send_tree
$LN14@send_tree:

; 790  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  003b0	0f b7 b0 c6 0a
	00 00		 movzx	 esi, WORD PTR [eax+2758]
  003b7	2b d6		 sub	 edx, esi
  003b9	89 75 f0	 mov	 DWORD PTR _len$1$[ebp], esi
  003bc	3b ca		 cmp	 ecx, edx
  003be	7e 58		 jle	 SHORT $LN8@send_tree
  003c0	0f b7 b8 c4 0a
	00 00		 movzx	 edi, WORD PTR [eax+2756]
  003c7	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  003ca	66 8b d7	 mov	 dx, di
  003cd	66 d3 e2	 shl	 dx, cl
  003d0	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  003d7	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  003da	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  003e1	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  003e4	ff 40 14	 inc	 DWORD PTR [eax+20]
  003e7	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  003ee	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  003f1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  003f4	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  003f7	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  003fd	ff 40 14	 inc	 DWORD PTR [eax+20]
  00400	b1 10		 mov	 cl, 16			; 00000010H
  00402	2a ca		 sub	 cl, dl
  00404	66 d3 ef	 shr	 di, cl
  00407	8b 4d f0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0040a	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0040d	03 ca		 add	 ecx, edx
  0040f	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00416	eb 13		 jmp	 SHORT $LN49@send_tree
$LN8@send_tree:
  00418	66 8b 90 c4 0a
	00 00		 mov	 dx, WORD PTR [eax+2756]
  0041f	66 d3 e2	 shl	 dx, cl
  00422	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00429	03 ce		 add	 ecx, esi
$LN49@send_tree:
  0042b	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00431	83 f9 09	 cmp	 ecx, 9
  00434	7e 4f		 jle	 SHORT $LN6@send_tree
  00436	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00439	8d 7b f5	 lea	 edi, DWORD PTR [ebx-11]
  0043c	66 8b d7	 mov	 dx, di
  0043f	66 d3 e2	 shl	 dx, cl
  00442	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00449	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0044c	0f b6 88 b8 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5816]
  00453	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00456	ff 40 14	 inc	 DWORD PTR [eax+20]
  00459	0f b6 88 b9 16
	00 00		 movzx	 ecx, BYTE PTR [eax+5817]
  00460	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00463	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00466	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00469	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0046f	ff 40 14	 inc	 DWORD PTR [eax+20]
  00472	b1 10		 mov	 cl, 16			; 00000010H
  00474	2a ca		 sub	 cl, dl
  00476	66 d3 ef	 shr	 di, cl
  00479	8d 4a f7	 lea	 ecx, DWORD PTR [edx-9]
  0047c	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00483	eb 10		 jmp	 SHORT $LN47@send_tree
$LN6@send_tree:
  00485	8d 53 f5	 lea	 edx, DWORD PTR [ebx-11]
  00488	66 d3 e2	 shl	 dx, cl
  0048b	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00492	83 c1 07	 add	 ecx, 7
$LN47@send_tree:
  00495	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN5@send_tree:

; 791  :         }
; 792  :         count = 0; prevlen = curlen;
; 793  :         if (nextlen == 0) {

  0049b	8b 55 10	 mov	 edx, DWORD PTR _nextlen$1$[ebp]
  0049e	8b 4d ec	 mov	 ecx, DWORD PTR _curlen$1$[ebp]
  004a1	33 db		 xor	 ebx, ebx
  004a3	8b f9		 mov	 edi, ecx
  004a5	85 d2		 test	 edx, edx
  004a7	75 0a		 jne	 SHORT $LN4@send_tree

; 794  :             max_count = 138, min_count = 3;

  004a9	be 8a 00 00 00	 mov	 esi, 138		; 0000008aH
  004ae	8d 53 03	 lea	 edx, DWORD PTR [ebx+3]
  004b1	eb 16		 jmp	 SHORT $LN34@send_tree
$LN4@send_tree:

; 795  :         } else if (curlen == nextlen) {

  004b3	3b ca		 cmp	 ecx, edx
  004b5	75 0a		 jne	 SHORT $LN2@send_tree

; 796  :             max_count = 6, min_count = 3;

  004b7	be 06 00 00 00	 mov	 esi, 6
  004bc	8d 56 fd	 lea	 edx, DWORD PTR [esi-3]

; 797  :         } else {

  004bf	eb 08		 jmp	 SHORT $LN34@send_tree
$LN2@send_tree:

; 798  :             max_count = 7, min_count = 4;

  004c1	be 07 00 00 00	 mov	 esi, 7
  004c6	8d 56 fd	 lea	 edx, DWORD PTR [esi-3]
$LN34@send_tree:

; 771  : 
; 772  :     for (n = 0; n <= max_code; n++) {

  004c9	83 45 0c 04	 add	 DWORD PTR tv1196[ebp], 4
  004cd	ff 4d fc	 dec	 DWORD PTR tv1250[ebp]
  004d0	8b 4d 10	 mov	 ecx, DWORD PTR _nextlen$1$[ebp]
  004d3	0f 85 69 fb ff
	ff		 jne	 $LL35@send_tree
$LN33@send_tree:
  004d9	5f		 pop	 edi
  004da	5e		 pop	 esi
  004db	5b		 pop	 ebx

; 799  :         }
; 800  :     }
; 801  : }

  004dc	8b e5		 mov	 esp, ebp
  004de	5d		 pop	 ebp
  004df	c3		 ret	 0
_send_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _scan_tree
_TEXT	SEGMENT
_prevlen$1$ = -4					; size = 4
_s$ = 8							; size = 4
tv297 = 12						; size = 4
_tree$ = 12						; size = 4
tv303 = 16						; size = 4
_max_code$ = 16						; size = 4
_scan_tree PROC						; COMDAT

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 716  :     int n;                     /* iterates over all tree elements */
; 717  :     int prevlen = -1;          /* last emitted length */
; 718  :     int curlen;                /* length of current code */
; 719  :     int nextlen = tree[0].Len; /* length of next code */

  00004	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	53		 push	 ebx
  00008	0f b7 58 02	 movzx	 ebx, WORD PTR [eax+2]

; 720  :     int count = 0;             /* repeat count of the current code */

  0000c	33 d2		 xor	 edx, edx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _prevlen$1$[ebp], -1

; 721  :     int max_count = 7;         /* max repeat count */

  00017	8d 7a 07	 lea	 edi, DWORD PTR [edx+7]

; 722  :     int min_count = 4;         /* min repeat count */

  0001a	8d 72 04	 lea	 esi, DWORD PTR [edx+4]

; 723  : 
; 724  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0001d	85 db		 test	 ebx, ebx
  0001f	75 08		 jne	 SHORT $LN17@scan_tree
  00021	bf 8a 00 00 00	 mov	 edi, 138		; 0000008aH
  00026	8d 72 03	 lea	 esi, DWORD PTR [edx+3]
$LN17@scan_tree:

; 725  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00029	8b 4d 10	 mov	 ecx, DWORD PTR _max_code$[ebp]
  0002c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00031	66 89 54 88 06	 mov	 WORD PTR [eax+ecx*4+6], dx

; 726  : 
; 727  :     for (n = 0; n <= max_code; n++) {

  00036	ba 00 00 00 00	 mov	 edx, 0
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 88 8d 00 00
	00		 js	 $LN14@scan_tree

; 725  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00043	83 c0 06	 add	 eax, 6
  00046	41		 inc	 ecx
  00047	89 45 0c	 mov	 DWORD PTR tv297[ebp], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004d	89 4d 10	 mov	 DWORD PTR tv303[ebp], ecx
$LL16@scan_tree:

; 728  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00050	8b cb		 mov	 ecx, ebx
  00052	8b 5d 0c	 mov	 ebx, DWORD PTR tv297[ebp]

; 729  :         if (++count < max_count && curlen == nextlen) {

  00055	42		 inc	 edx
  00056	0f b7 1b	 movzx	 ebx, WORD PTR [ebx]
  00059	3b d7		 cmp	 edx, edi
  0005b	7d 04		 jge	 SHORT $LN13@scan_tree
  0005d	3b cb		 cmp	 ecx, ebx
  0005f	74 66		 je	 SHORT $LN15@scan_tree
$LN13@scan_tree:

; 730  :             continue;
; 731  :         } else if (count < min_count) {

  00061	3b d6		 cmp	 edx, esi
  00063	7d 0a		 jge	 SHORT $LN11@scan_tree

; 732  :             s->bl_tree[curlen].Freq += count;

  00065	66 01 94 88 7c
	0a 00 00	 add	 WORD PTR [eax+ecx*4+2684], dx
  0006d	eb 2f		 jmp	 SHORT $LN5@scan_tree
$LN11@scan_tree:

; 733  :         } else if (curlen != 0) {

  0006f	85 c9		 test	 ecx, ecx
  00071	74 16		 je	 SHORT $LN9@scan_tree

; 734  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  00073	3b 4d fc	 cmp	 ecx, DWORD PTR _prevlen$1$[ebp]
  00076	74 08		 je	 SHORT $LN8@scan_tree
  00078	66 ff 84 88 7c
	0a 00 00	 inc	 WORD PTR [eax+ecx*4+2684]
$LN8@scan_tree:

; 735  :             s->bl_tree[REP_3_6].Freq++;

  00080	66 ff 80 bc 0a
	00 00		 inc	 WORD PTR [eax+2748]
  00087	eb 15		 jmp	 SHORT $LN5@scan_tree
$LN9@scan_tree:

; 736  :         } else if (count <= 10) {

  00089	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0008c	7f 09		 jg	 SHORT $LN6@scan_tree

; 737  :             s->bl_tree[REPZ_3_10].Freq++;

  0008e	66 ff 80 c0 0a
	00 00		 inc	 WORD PTR [eax+2752]

; 738  :         } else {

  00095	eb 07		 jmp	 SHORT $LN5@scan_tree
$LN6@scan_tree:

; 739  :             s->bl_tree[REPZ_11_138].Freq++;

  00097	66 ff 80 c4 0a
	00 00		 inc	 WORD PTR [eax+2756]
$LN5@scan_tree:

; 740  :         }
; 741  :         count = 0; prevlen = curlen;

  0009e	33 d2		 xor	 edx, edx
  000a0	89 4d fc	 mov	 DWORD PTR _prevlen$1$[ebp], ecx

; 742  :         if (nextlen == 0) {

  000a3	85 db		 test	 ebx, ebx
  000a5	75 0a		 jne	 SHORT $LN4@scan_tree

; 743  :             max_count = 138, min_count = 3;

  000a7	bf 8a 00 00 00	 mov	 edi, 138		; 0000008aH
  000ac	8d 72 03	 lea	 esi, DWORD PTR [edx+3]
  000af	eb 16		 jmp	 SHORT $LN15@scan_tree
$LN4@scan_tree:

; 744  :         } else if (curlen == nextlen) {

  000b1	3b cb		 cmp	 ecx, ebx
  000b3	75 0a		 jne	 SHORT $LN2@scan_tree

; 745  :             max_count = 6, min_count = 3;

  000b5	bf 06 00 00 00	 mov	 edi, 6
  000ba	8d 77 fd	 lea	 esi, DWORD PTR [edi-3]

; 746  :         } else {

  000bd	eb 08		 jmp	 SHORT $LN15@scan_tree
$LN2@scan_tree:

; 747  :             max_count = 7, min_count = 4;

  000bf	bf 07 00 00 00	 mov	 edi, 7
  000c4	8d 77 fd	 lea	 esi, DWORD PTR [edi-3]
$LN15@scan_tree:

; 726  : 
; 727  :     for (n = 0; n <= max_code; n++) {

  000c7	83 45 0c 04	 add	 DWORD PTR tv297[ebp], 4
  000cb	ff 4d 10	 dec	 DWORD PTR tv303[ebp]
  000ce	75 80		 jne	 SHORT $LL16@scan_tree
$LN14@scan_tree:
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 748  :         }
; 749  :     }
; 750  : }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_scan_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _build_tree
_TEXT	SEGMENT
_stree$1$ = -12						; size = 4
_node$2$ = -8						; size = 4
_max_code$1$ = -4					; size = 4
tv505 = 8						; size = 4
_s$ = 8							; size = 4
_desc$ = 12						; size = 4
_build_tree PROC					; COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 627  :     ct_data *tree         = desc->dyn_tree;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00009	53		 push	 ebx
  0000a	8b 18		 mov	 ebx, DWORD PTR [eax]

; 628  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0000c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000f	56		 push	 esi
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]

; 629  :     int elems             = desc->stat_desc->elems;

  00012	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 630  :     int n, m;          /* iterate over heap elements */
; 631  :     int max_code = -1; /* largest code with non zero frequency */
; 632  :     int node;          /* new node being created */
; 633  : 
; 634  :     /* Construct the initial heap, with least frequent element in
; 635  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 636  :      * heap[0] is not used.
; 637  :      */
; 638  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00015	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00018	57		 push	 edi
  00019	89 4d f4	 mov	 DWORD PTR _stree$1$[ebp], ecx
  0001c	83 cf ff	 or	 edi, -1

; 639  : 
; 640  :     for (n = 0; n < elems; n++) {

  0001f	33 c9		 xor	 ecx, ecx
  00021	89 55 f8	 mov	 DWORD PTR _node$2$[ebp], edx
  00024	89 7d fc	 mov	 DWORD PTR _max_code$1$[ebp], edi
  00027	c7 86 50 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5200], 0
  00031	c7 86 54 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [esi+5204], 573 ; 0000023dH
  0003b	85 d2		 test	 edx, edx
  0003d	7e 36		 jle	 SHORT $LN22@build_tree
  0003f	90		 npad	 1
$LL14@build_tree:

; 641  :         if (tree[n].Freq != 0) {

  00040	66 83 3c 8b 00	 cmp	 WORD PTR [ebx+ecx*4], 0
  00045	74 1f		 je	 SHORT $LN11@build_tree

; 642  :             s->heap[++(s->heap_len)] = max_code = n;

  00047	ff 86 50 14 00
	00		 inc	 DWORD PTR [esi+5200]
  0004d	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  00053	8b f9		 mov	 edi, ecx
  00055	89 8c 86 5c 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2908], ecx

; 643  :             s->depth[n] = 0;

  0005c	c6 84 31 58 14
	00 00 00	 mov	 BYTE PTR [ecx+esi+5208], 0

; 644  :         } else {

  00064	eb 07		 jmp	 SHORT $LN13@build_tree
$LN11@build_tree:

; 645  :             tree[n].Len = 0;

  00066	33 c0		 xor	 eax, eax
  00068	66 89 44 8b 02	 mov	 WORD PTR [ebx+ecx*4+2], ax
$LN13@build_tree:

; 639  : 
; 640  :     for (n = 0; n < elems; n++) {

  0006d	41		 inc	 ecx
  0006e	3b ca		 cmp	 ecx, edx
  00070	7c ce		 jl	 SHORT $LL14@build_tree
  00072	89 7d fc	 mov	 DWORD PTR _max_code$1$[ebp], edi
$LN22@build_tree:

; 646  :         }
; 647  :     }
; 648  : 
; 649  :     /* The pkzip format requires that at least one distance code exists,
; 650  :      * and that at least one bit should be sent even if there is only one
; 651  :      * possible code. So to avoid special checks later on we force at least
; 652  :      * two codes of non zero frequency.
; 653  :      */
; 654  :     while (s->heap_len < 2) {

  00075	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  0007c	7d 54		 jge	 SHORT $LN8@build_tree
  0007e	ba 01 00 00 00	 mov	 edx, 1
$LL9@build_tree:

; 655  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  00083	83 ff 02	 cmp	 edi, 2
  00086	7d 05		 jge	 SHORT $LN17@build_tree
  00088	47		 inc	 edi
  00089	8b cf		 mov	 ecx, edi
  0008b	eb 02		 jmp	 SHORT $LN18@build_tree
$LN17@build_tree:
  0008d	33 c9		 xor	 ecx, ecx
$LN18@build_tree:
  0008f	ff 86 50 14 00
	00		 inc	 DWORD PTR [esi+5200]
  00095	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  0009b	89 8c 86 5c 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2908], ecx

; 656  :         tree[node].Freq = 1;
; 657  :         s->depth[node] = 0;
; 658  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _stree$1$[ebp]
  000a5	66 89 14 8b	 mov	 WORD PTR [ebx+ecx*4], dx
  000a9	c6 84 0e 58 14
	00 00 00	 mov	 BYTE PTR [esi+ecx+5208], 0
  000b1	ff 8e a8 16 00
	00		 dec	 DWORD PTR [esi+5800]
  000b7	85 c0		 test	 eax, eax
  000b9	74 0b		 je	 SHORT $LN7@build_tree
  000bb	0f b7 44 88 02	 movzx	 eax, WORD PTR [eax+ecx*4+2]
  000c0	29 86 ac 16 00
	00		 sub	 DWORD PTR [esi+5804], eax
$LN7@build_tree:

; 646  :         }
; 647  :     }
; 648  : 
; 649  :     /* The pkzip format requires that at least one distance code exists,
; 650  :      * and that at least one bit should be sent even if there is only one
; 651  :      * possible code. So to avoid special checks later on we force at least
; 652  :      * two codes of non zero frequency.
; 653  :      */
; 654  :     while (s->heap_len < 2) {

  000c6	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  000cd	7c b4		 jl	 SHORT $LL9@build_tree
  000cf	89 7d fc	 mov	 DWORD PTR _max_code$1$[ebp], edi
$LN8@build_tree:

; 659  :         /* node is 0 or 1 so it does not have extra bits */
; 660  :     }
; 661  :     desc->max_code = max_code;

  000d2	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  000d5	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 662  : 
; 663  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 664  :      * establish sub-heaps of increasing lengths:
; 665  :      */
; 666  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  000d8	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  000de	99		 cdq
  000df	2b c2		 sub	 eax, edx
  000e1	8b f8		 mov	 edi, eax
  000e3	d1 ff		 sar	 edi, 1
  000e5	83 ff 01	 cmp	 edi, 1
  000e8	7c 17		 jl	 SHORT $LL3@build_tree
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL6@build_tree:
  000f0	57		 push	 edi
  000f1	53		 push	 ebx
  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 _pqdownheap
  000f8	4f		 dec	 edi
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	83 ff 01	 cmp	 edi, 1
  000ff	7d ef		 jge	 SHORT $LL6@build_tree
$LL3@build_tree:

; 667  : 
; 668  :     /* Construct the Huffman tree by repeatedly combining the least two
; 669  :      * frequent nodes.
; 670  :      */
; 671  :     node = elems;              /* next internal node of the tree */
; 672  :     do {
; 673  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00101	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  00107	8b be 60 0b 00
	00		 mov	 edi, DWORD PTR [esi+2912]
  0010d	8b 84 86 5c 0b
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+2908]
  00114	6a 01		 push	 1
  00116	53		 push	 ebx
  00117	89 86 60 0b 00
	00		 mov	 DWORD PTR [esi+2912], eax
  0011d	ff 8e 50 14 00
	00		 dec	 DWORD PTR [esi+5200]
  00123	56		 push	 esi
  00124	e8 00 00 00 00	 call	 _pqdownheap

; 674  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */

  00129	8b 8e 60 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2912]

; 675  : 
; 676  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  0012f	ff 8e 54 14 00
	00		 dec	 DWORD PTR [esi+5204]
  00135	8b 86 54 14 00
	00		 mov	 eax, DWORD PTR [esi+5204]

; 677  :         s->heap[--(s->heap_max)] = m;
; 678  : 
; 679  :         /* Create a new node father of n and m */
; 680  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  0013b	8b 55 f8	 mov	 edx, DWORD PTR _node$2$[ebp]
  0013e	89 bc 86 5c 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2908], edi
  00145	ff 8e 54 14 00
	00		 dec	 DWORD PTR [esi+5204]
  0014b	8b 86 54 14 00
	00		 mov	 eax, DWORD PTR [esi+5204]
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	89 8c 86 5c 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2908], ecx
  0015b	8d 04 8b	 lea	 eax, DWORD PTR [ebx+ecx*4]
  0015e	89 45 08	 mov	 DWORD PTR tv505[ebp], eax
  00161	66 8b 00	 mov	 ax, WORD PTR [eax]
  00164	66 03 04 bb	 add	 ax, WORD PTR [ebx+edi*4]
  00168	66 89 04 93	 mov	 WORD PTR [ebx+edx*4], ax

; 681  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
; 682  :                                 s->depth[n] : s->depth[m]) + 1);

  0016c	8a 84 3e 58 14
	00 00		 mov	 al, BYTE PTR [esi+edi+5208]
  00173	8a 8c 0e 58 14
	00 00		 mov	 cl, BYTE PTR [esi+ecx+5208]
  0017a	3a c1		 cmp	 al, cl
  0017c	0f b6 c0	 movzx	 eax, al
  0017f	73 03		 jae	 SHORT $LN20@build_tree
  00181	0f b6 c1	 movzx	 eax, cl
$LN20@build_tree:

; 683  :         tree[n].Dad = tree[m].Dad = (ush)node;

  00184	8b 4d 08	 mov	 ecx, DWORD PTR tv505[ebp]
  00187	fe c0		 inc	 al
  00189	88 84 16 58 14
	00 00		 mov	 BYTE PTR [esi+edx+5208], al
  00190	0f b7 c2	 movzx	 eax, dx
  00193	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 684  : #ifdef DUMP_BL_TREE
; 685  :         if (tree == s->bl_tree) {
; 686  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 687  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 688  :         }
; 689  : #endif
; 690  :         /* and insert the new node in the heap */
; 691  :         s->heap[SMALLEST] = node++;
; 692  :         pqdownheap(s, tree, SMALLEST);

  00197	6a 01		 push	 1
  00199	66 89 44 bb 02	 mov	 WORD PTR [ebx+edi*4+2], ax
  0019e	89 96 60 0b 00
	00		 mov	 DWORD PTR [esi+2912], edx
  001a4	42		 inc	 edx
  001a5	53		 push	 ebx
  001a6	56		 push	 esi
  001a7	89 55 f8	 mov	 DWORD PTR _node$2$[ebp], edx
  001aa	e8 00 00 00 00	 call	 _pqdownheap
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 693  : 
; 694  :     } while (s->heap_len >= 2);

  001b2	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  001b9	0f 8d 42 ff ff
	ff		 jge	 $LL3@build_tree

; 695  : 
; 696  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  001bf	ff 8e 54 14 00
	00		 dec	 DWORD PTR [esi+5204]
  001c5	8b 8e 54 14 00
	00		 mov	 ecx, DWORD PTR [esi+5204]

; 697  : 
; 698  :     /* At this point, the fields freq and dad are set. We can now
; 699  :      * generate the bit lengths.
; 700  :      */
; 701  :     gen_bitlen(s, (tree_desc *)desc);

  001cb	ff 75 0c	 push	 DWORD PTR _desc$[ebp]
  001ce	8b 86 60 0b 00
	00		 mov	 eax, DWORD PTR [esi+2912]
  001d4	56		 push	 esi
  001d5	89 84 8e 5c 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2908], eax
  001dc	e8 00 00 00 00	 call	 _gen_bitlen

; 702  : 
; 703  :     /* The field len is now set, we can generate the bit codes */
; 704  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  001e1	81 c6 3c 0b 00
	00		 add	 esi, 2876		; 00000b3cH
  001e7	56		 push	 esi
  001e8	ff 75 fc	 push	 DWORD PTR _max_code$1$[ebp]
  001eb	53		 push	 ebx
  001ec	e8 00 00 00 00	 call	 _gen_codes
  001f1	83 c4 14	 add	 esp, 20			; 00000014H
  001f4	5f		 pop	 edi
  001f5	5e		 pop	 esi
  001f6	5b		 pop	 ebx

; 705  : }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
_build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _gen_codes
_TEXT	SEGMENT
_next_code$ = -32					; size = 32
_tree$ = 8						; size = 4
_max_code$ = 12						; size = 4
_bl_count$ = 16						; size = 4
_gen_codes PROC						; COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 586  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 587  :     ush code = 0;              /* running code value */
; 588  :     int bits;                  /* bit index */
; 589  :     int n;                     /* code index */
; 590  : 
; 591  :     /* The distribution counts are first used to generate the code values
; 592  :      * without bit reversal.
; 593  :      */
; 594  :     for (bits = 1; bits <= MAX_BITS; bits++) {

  00006	8d 45 e2	 lea	 eax, DWORD PTR _next_code$[ebp+2]
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR _bl_count$[ebp]
  0000d	33 d2		 xor	 edx, edx
  0000f	57		 push	 edi
  00010	b9 01 00 00 00	 mov	 ecx, 1
  00015	2b f0		 sub	 esi, eax
$LL7@gen_codes:
  00017	8d 04 4e	 lea	 eax, DWORD PTR [esi+ecx*2]
  0001a	41		 inc	 ecx

; 595  :         next_code[bits] = code = (code + bl_count[bits-1]) << 1;

  0001b	66 8b 44 05 e0	 mov	 ax, WORD PTR _next_code$[ebp+eax]
  00020	66 03 c2	 add	 ax, dx
  00023	66 03 c0	 add	 ax, ax
  00026	0f b7 d0	 movzx	 edx, ax
  00029	66 89 54 4d de	 mov	 WORD PTR _next_code$[ebp+ecx*2-2], dx
  0002e	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00031	7e e4		 jle	 SHORT $LL7@gen_codes

; 596  :     }
; 597  :     /* Check that the bit counts in bl_count are consistent. The last code
; 598  :      * must be all ones.
; 599  :      */
; 600  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 601  :             "inconsistent bit counts");
; 602  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 603  : 
; 604  :     for (n = 0;  n <= max_code; n++) {

  00033	8b 7d 0c	 mov	 edi, DWORD PTR _max_code$[ebp]
  00036	33 f6		 xor	 esi, esi
  00038	85 ff		 test	 edi, edi
  0003a	78 2e		 js	 SHORT $LN2@gen_codes
  0003c	53		 push	 ebx
  0003d	8b 5d 08	 mov	 ebx, DWORD PTR _tree$[ebp]
$LL4@gen_codes:

; 605  :         int len = tree[n].Len;

  00040	0f b7 54 b3 02	 movzx	 edx, WORD PTR [ebx+esi*4+2]

; 606  :         if (len == 0) continue;

  00045	85 d2		 test	 edx, edx
  00047	74 1b		 je	 SHORT $LN3@gen_codes

; 607  :         /* Now reverse the bits */
; 608  :         tree[n].Code = bi_reverse(next_code[len]++, len);

  00049	0f b7 44 55 e0	 movzx	 eax, WORD PTR _next_code$[ebp+edx*2]
  0004e	8b c8		 mov	 ecx, eax
  00050	52		 push	 edx
  00051	40		 inc	 eax
  00052	51		 push	 ecx
  00053	66 89 44 55 e0	 mov	 WORD PTR _next_code$[ebp+edx*2], ax
  00058	e8 00 00 00 00	 call	 _bi_reverse
  0005d	83 c4 08	 add	 esp, 8
  00060	66 89 04 b3	 mov	 WORD PTR [ebx+esi*4], ax
$LN3@gen_codes:

; 596  :     }
; 597  :     /* Check that the bit counts in bl_count are consistent. The last code
; 598  :      * must be all ones.
; 599  :      */
; 600  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 601  :             "inconsistent bit counts");
; 602  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 603  : 
; 604  :     for (n = 0;  n <= max_code; n++) {

  00064	46		 inc	 esi
  00065	3b f7		 cmp	 esi, edi
  00067	7e d7		 jle	 SHORT $LL4@gen_codes
  00069	5b		 pop	 ebx
$LN2@gen_codes:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 609  : 
; 610  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 611  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 612  :     }
; 613  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_gen_codes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _gen_bitlen
_TEXT	SEGMENT
tv642 = -44						; size = 4
_extra$1$ = -40						; size = 4
tv651 = -36						; size = 4
tv626 = -36						; size = 4
tv630 = -32						; size = 4
_stree$1$ = -28						; size = 4
_base$1$ = -24						; size = 4
_max_code$1$ = -20					; size = 4
_overflow$1$ = -16					; size = 4
tv645 = -12						; size = 4
_h$1$ = -8						; size = 4
_bits$3$ = -4						; size = 4
_s$ = 8							; size = 4
_tree$1$ = 12						; size = 4
_desc$ = 12						; size = 4
_gen_bitlen PROC					; COMDAT

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 498  :     ct_data *tree        = desc->dyn_tree;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _desc$[ebp]
  00009	53		 push	 ebx

; 499  :     int max_code         = desc->max_code;

  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]

; 500  :     const ct_data *stree = desc->stat_desc->static_tree;

  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00012	89 4d ec	 mov	 DWORD PTR _max_code$1$[ebp], ecx
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d e4	 mov	 DWORD PTR _stree$1$[ebp], ecx

; 501  :     const intf *extra    = desc->stat_desc->extra_bits;

  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	89 4d d8	 mov	 DWORD PTR _extra$1$[ebp], ecx

; 502  :     int base             = desc->stat_desc->extra_base;

  00020	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00023	89 4d e8	 mov	 DWORD PTR _base$1$[ebp], ecx

; 503  :     int max_length       = desc->stat_desc->max_length;
; 504  :     int h;              /* heap index */
; 505  :     int n, m;           /* iterate over the tree elements */
; 506  :     int bits;           /* bit length */
; 507  :     int xbits;          /* extra bits */
; 508  :     ush f;              /* frequency */
; 509  :     int overflow = 0;   /* number of elements with bit length too large */
; 510  : 
; 511  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

  00026	33 c9		 xor	 ecx, ecx
  00028	56		 push	 esi
  00029	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0002c	0f b7 c1	 movzx	 eax, cx
  0002f	8b c8		 mov	 ecx, eax
  00031	c1 e0 10	 shl	 eax, 16			; 00000010H
  00034	0b c8		 or	 ecx, eax
  00036	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00039	57		 push	 edi
  0003a	89 88 3c 0b 00
	00		 mov	 DWORD PTR [eax+2876], ecx
  00040	89 88 40 0b 00
	00		 mov	 DWORD PTR [eax+2880], ecx
  00046	89 88 44 0b 00
	00		 mov	 DWORD PTR [eax+2884], ecx
  0004c	89 88 48 0b 00
	00		 mov	 DWORD PTR [eax+2888], ecx
  00052	89 88 4c 0b 00
	00		 mov	 DWORD PTR [eax+2892], ecx
  00058	89 88 50 0b 00
	00		 mov	 DWORD PTR [eax+2896], ecx
  0005e	89 88 54 0b 00
	00		 mov	 DWORD PTR [eax+2900], ecx
  00064	89 88 58 0b 00
	00		 mov	 DWORD PTR [eax+2904], ecx

; 512  : 
; 513  :     /* In a first pass, compute the optimal bit lengths (which may
; 514  :      * overflow in the case of the bit length tree).
; 515  :      */
; 516  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  0006a	8b c8		 mov	 ecx, eax
  0006c	33 ff		 xor	 edi, edi
  0006e	8b 81 54 14 00
	00		 mov	 eax, DWORD PTR [ecx+5204]
  00074	89 55 0c	 mov	 DWORD PTR _tree$1$[ebp], edx
  00077	8b 84 81 5c 0b
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2908]
  0007e	89 75 fc	 mov	 DWORD PTR _bits$3$[ebp], esi
  00081	66 89 7c 82 02	 mov	 WORD PTR [edx+eax*4+2], di

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00086	8b 99 54 14 00
	00		 mov	 ebx, DWORD PTR [ecx+5204]
  0008c	43		 inc	 ebx
  0008d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _overflow$1$[ebp], 0
  00094	81 fb 3d 02 00
	00		 cmp	 ebx, 573		; 0000023dH
  0009a	0f 8d a1 01 00
	00		 jge	 $LN5@gen_bitlen

; 512  : 
; 513  :     /* In a first pass, compute the optimal bit lengths (which may
; 514  :      * overflow in the case of the bit length tree).
; 515  :      */
; 516  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  000a0	8d 91 5c 0b 00
	00		 lea	 edx, DWORD PTR [ecx+2908]
  000a6	b8 3d 02 00 00	 mov	 eax, 573		; 0000023dH
  000ab	2b c3		 sub	 eax, ebx
  000ad	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  000b0	03 d8		 add	 ebx, eax
  000b2	89 45 dc	 mov	 DWORD PTR tv651[ebp], eax
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _tree$1$[ebp]
  000b8	89 5d f8	 mov	 DWORD PTR _h$1$[ebp], ebx
  000bb	89 55 e0	 mov	 DWORD PTR tv630[ebp], edx
  000be	33 db		 xor	 ebx, ebx
$LL20@gen_bitlen:

; 519  :         n = s->heap[h];

  000c0	8b 3a		 mov	 edi, DWORD PTR [edx]

; 520  :         bits = tree[tree[n].Dad].Len + 1;

  000c2	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  000c9	89 55 f4	 mov	 DWORD PTR tv645[ebp], edx
  000cc	0f b7 44 02 02	 movzx	 eax, WORD PTR [edx+eax+2]
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _tree$1$[ebp]
  000d4	0f b7 54 82 02	 movzx	 edx, WORD PTR [edx+eax*4+2]
  000d9	42		 inc	 edx

; 521  :         if (bits > max_length) bits = max_length, overflow++;

  000da	3b d6		 cmp	 edx, esi
  000dc	7e 06		 jle	 SHORT $LN17@gen_bitlen
  000de	43		 inc	 ebx
  000df	8b d6		 mov	 edx, esi
  000e1	89 5d f0	 mov	 DWORD PTR _overflow$1$[ebp], ebx
$LN17@gen_bitlen:

; 522  :         tree[n].Len = (ush)bits;

  000e4	8b 75 f4	 mov	 esi, DWORD PTR tv645[ebp]
  000e7	8b 45 0c	 mov	 eax, DWORD PTR _tree$1$[ebp]
  000ea	66 89 54 06 02	 mov	 WORD PTR [esi+eax+2], dx

; 523  :         /* We overwrite tree[n].Dad which is no longer needed */
; 524  : 
; 525  :         if (n > max_code) continue; /* not a leaf node */

  000ef	8b 75 fc	 mov	 esi, DWORD PTR _bits$3$[ebp]
  000f2	3b 7d ec	 cmp	 edi, DWORD PTR _max_code$1$[ebp]
  000f5	7f 5b		 jg	 SHORT $LN19@gen_bitlen

; 526  : 
; 527  :         s->bl_count[bits]++;

  000f7	66 ff 84 51 3c
	0b 00 00	 inc	 WORD PTR [ecx+edx*2+2876]

; 528  :         xbits = 0;
; 529  :         if (n >= base) xbits = extra[n-base];

  000ff	3b 7d e8	 cmp	 edi, DWORD PTR _base$1$[ebp]
  00102	7c 0e		 jl	 SHORT $LN44@gen_bitlen
  00104	2b 7d e8	 sub	 edi, DWORD PTR _base$1$[ebp]
  00107	8b 75 d8	 mov	 esi, DWORD PTR _extra$1$[ebp]
  0010a	8b 3c be	 mov	 edi, DWORD PTR [esi+edi*4]
  0010d	8b 75 fc	 mov	 esi, DWORD PTR _bits$3$[ebp]
  00110	eb 02		 jmp	 SHORT $LN15@gen_bitlen
$LN44@gen_bitlen:
  00112	33 ff		 xor	 edi, edi
$LN15@gen_bitlen:

; 530  :         f = tree[n].Freq;

  00114	8b 5d f4	 mov	 ebx, DWORD PTR tv645[ebp]
  00117	0f b7 04 03	 movzx	 eax, WORD PTR [ebx+eax]

; 531  :         s->opt_len += (ulg)f * (bits + xbits);
; 532  :         if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);

  0011b	8b 5d f0	 mov	 ebx, DWORD PTR _overflow$1$[ebp]
  0011e	89 45 d4	 mov	 DWORD PTR tv642[ebp], eax
  00121	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00124	8b 55 d4	 mov	 edx, DWORD PTR tv642[ebp]
  00127	0f af c2	 imul	 eax, edx
  0012a	01 81 a8 16 00
	00		 add	 DWORD PTR [ecx+5800], eax
  00130	83 7d e4 00	 cmp	 DWORD PTR _stree$1$[ebp], 0
  00134	74 19		 je	 SHORT $LN45@gen_bitlen
  00136	8b 75 e4	 mov	 esi, DWORD PTR _stree$1$[ebp]
  00139	8b 45 f4	 mov	 eax, DWORD PTR tv645[ebp]
  0013c	0f b7 44 30 02	 movzx	 eax, WORD PTR [eax+esi+2]
  00141	8b 75 fc	 mov	 esi, DWORD PTR _bits$3$[ebp]
  00144	03 c7		 add	 eax, edi
  00146	0f af c2	 imul	 eax, edx
  00149	01 81 ac 16 00
	00		 add	 DWORD PTR [ecx+5804], eax
$LN45@gen_bitlen:
  0014f	8b 45 0c	 mov	 eax, DWORD PTR _tree$1$[ebp]
$LN19@gen_bitlen:

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00152	8b 55 e0	 mov	 edx, DWORD PTR tv630[ebp]
  00155	83 c2 04	 add	 edx, 4
  00158	ff 4d dc	 dec	 DWORD PTR tv651[ebp]
  0015b	89 55 e0	 mov	 DWORD PTR tv630[ebp], edx
  0015e	0f 85 5c ff ff
	ff		 jne	 $LL20@gen_bitlen

; 533  :     }
; 534  :     if (overflow == 0) return;

  00164	85 db		 test	 ebx, ebx
  00166	0f 84 d5 00 00
	00		 je	 $LN5@gen_bitlen
  0016c	8d 5e ff	 lea	 ebx, DWORD PTR [esi-1]
  0016f	81 c6 9e 05 00
	00		 add	 esi, 1438		; 0000059eH
  00175	8d 3c 71	 lea	 edi, DWORD PTR [ecx+esi*2]
  00178	8b 75 f0	 mov	 esi, DWORD PTR _overflow$1$[ebp]
  0017b	89 7d dc	 mov	 DWORD PTR tv626[ebp], edi
  0017e	8b ff		 npad	 2
$LL12@gen_bitlen:

; 535  : 
; 536  :     Trace((stderr,"\nbit length overflow\n"));
; 537  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 538  : 
; 539  :     /* Find the first bit length which could increase: */
; 540  :     do {
; 541  :         bits = max_length-1;

  00180	8b d3		 mov	 edx, ebx

; 542  :         while (s->bl_count[bits] == 0) bits--;

  00182	8d 81 3c 0b 00
	00		 lea	 eax, DWORD PTR [ecx+2876]
  00188	66 83 3c 50 00	 cmp	 WORD PTR [eax+edx*2], 0
  0018d	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00190	75 0a		 jne	 SHORT $LN8@gen_bitlen
$LL9@gen_bitlen:
  00192	8d 40 fe	 lea	 eax, DWORD PTR [eax-2]
  00195	4a		 dec	 edx
  00196	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0019a	74 f6		 je	 SHORT $LL9@gen_bitlen
$LN8@gen_bitlen:

; 543  :         s->bl_count[bits]--;      /* move one leaf down the tree */
; 544  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */

  0019c	66 83 84 51 3e
	0b 00 00 02	 add	 WORD PTR [ecx+edx*2+2878], 2
  001a5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001aa	66 01 84 51 3c
	0b 00 00	 add	 WORD PTR [ecx+edx*2+2876], ax

; 545  :         s->bl_count[max_length]--;

  001b2	66 01 07	 add	 WORD PTR [edi], ax

; 546  :         /* The brother of the overflow item also moves one step up,
; 547  :          * but this does not affect bl_count[max_length]
; 548  :          */
; 549  :         overflow -= 2;

  001b5	83 ee 02	 sub	 esi, 2

; 550  :     } while (overflow > 0);

  001b8	85 f6		 test	 esi, esi
  001ba	7f c4		 jg	 SHORT $LL12@gen_bitlen

; 551  : 
; 552  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 553  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 554  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 555  :      * from 'ar' written by Haruhiko Okumura.)
; 556  :      */
; 557  :     for (bits = max_length; bits != 0; bits--) {

  001bc	8b 75 fc	 mov	 esi, DWORD PTR _bits$3$[ebp]
  001bf	8b 5d f8	 mov	 ebx, DWORD PTR _h$1$[ebp]
  001c2	85 f6		 test	 esi, esi
  001c4	0f 84 77 00 00
	00		 je	 $LN5@gen_bitlen
  001ca	8d 9b 00 00 00
	00		 npad	 6
$LL7@gen_bitlen:

; 558  :         n = s->bl_count[bits];

  001d0	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 559  :         while (n != 0) {

  001d3	85 c0		 test	 eax, eax
  001d5	74 5c		 je	 SHORT $LN6@gen_bitlen

; 558  :         n = s->bl_count[bits];

  001d7	8b 55 ec	 mov	 edx, DWORD PTR _max_code$1$[ebp]
  001da	8d bb d7 02 00
	00		 lea	 edi, DWORD PTR [ebx+727]
  001e0	8d 3c b9	 lea	 edi, DWORD PTR [ecx+edi*4]
$LL4@gen_bitlen:

; 560  :             m = s->heap[--h];

  001e3	4b		 dec	 ebx
  001e4	8d 7f fc	 lea	 edi, DWORD PTR [edi-4]
  001e7	89 5d f8	 mov	 DWORD PTR _h$1$[ebp], ebx
  001ea	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 561  :             if (m > max_code) continue;

  001ec	3b da		 cmp	 ebx, edx
  001ee	7f 39		 jg	 SHORT $LN36@gen_bitlen

; 562  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  001f0	8b 55 0c	 mov	 edx, DWORD PTR _tree$1$[ebp]
  001f3	0f b7 54 9a 02	 movzx	 edx, WORD PTR [edx+ebx*4+2]
  001f8	3b d6		 cmp	 edx, esi
  001fa	74 29		 je	 SHORT $LN1@gen_bitlen

; 563  :                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 564  :                 s->opt_len += ((long)bits - (long)tree[m].Len)
; 565  :                               *(long)tree[m].Freq;

  001fc	8b d6		 mov	 edx, esi
  001fe	8b 75 0c	 mov	 esi, DWORD PTR _tree$1$[ebp]
  00201	0f b7 4c 9e 02	 movzx	 ecx, WORD PTR [esi+ebx*4+2]
  00206	2b d1		 sub	 edx, ecx
  00208	8b ce		 mov	 ecx, esi

; 566  :                 tree[m].Len = (ush)bits;

  0020a	8b 75 fc	 mov	 esi, DWORD PTR _bits$3$[ebp]
  0020d	0f b7 0c 99	 movzx	 ecx, WORD PTR [ecx+ebx*4]
  00211	0f af d1	 imul	 edx, ecx
  00214	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00217	01 91 a8 16 00
	00		 add	 DWORD PTR [ecx+5800], edx
  0021d	8b 55 0c	 mov	 edx, DWORD PTR _tree$1$[ebp]
  00220	66 89 74 9a 02	 mov	 WORD PTR [edx+ebx*4+2], si
$LN1@gen_bitlen:

; 567  :             }
; 568  :             n--;

  00225	8b 55 ec	 mov	 edx, DWORD PTR _max_code$1$[ebp]
  00228	48		 dec	 eax
$LN36@gen_bitlen:

; 559  :         while (n != 0) {

  00229	8b 5d f8	 mov	 ebx, DWORD PTR _h$1$[ebp]
  0022c	85 c0		 test	 eax, eax
  0022e	75 b3		 jne	 SHORT $LL4@gen_bitlen
  00230	8b 7d dc	 mov	 edi, DWORD PTR tv626[ebp]
$LN6@gen_bitlen:

; 551  : 
; 552  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 553  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 554  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 555  :      * from 'ar' written by Haruhiko Okumura.)
; 556  :      */
; 557  :     for (bits = max_length; bits != 0; bits--) {

  00233	4e		 dec	 esi
  00234	83 ef 02	 sub	 edi, 2
  00237	89 75 fc	 mov	 DWORD PTR _bits$3$[ebp], esi
  0023a	89 7d dc	 mov	 DWORD PTR tv626[ebp], edi
  0023d	85 f6		 test	 esi, esi
  0023f	75 8f		 jne	 SHORT $LL7@gen_bitlen
$LN5@gen_bitlen:
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx

; 569  :         }
; 570  :     }
; 571  : }

  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
_gen_bitlen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _pqdownheap
_TEXT	SEGMENT
tv289 = -4						; size = 4
_s$ = 8							; size = 4
_tree$ = 12						; size = 4
_v$1$ = 16						; size = 4
_k$ = 16						; size = 4
_pqdownheap PROC					; COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 464  :     int v = s->heap[k];

  00004	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00007	53		 push	 ebx

; 465  :     int j = k << 1;  /* left son of k */
; 466  :     while (j <= s->heap_len) {

  00008	8b 88 50 14 00
	00		 mov	 ecx, DWORD PTR [eax+5200]
  0000e	57		 push	 edi
  0000f	8b 7d 10	 mov	 edi, DWORD PTR _k$[ebp]
  00012	8b 9c b8 5c 0b
	00 00		 mov	 ebx, DWORD PTR [eax+edi*4+2908]
  00019	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  0001c	89 5d 10	 mov	 DWORD PTR _v$1$[ebp], ebx
  0001f	3b d1		 cmp	 edx, ecx
  00021	0f 8f b0 00 00
	00		 jg	 $LN15@pqdownheap
  00027	56		 push	 esi
  00028	8b 75 0c	 mov	 esi, DWORD PTR _tree$[ebp]
  0002b	8d 34 9e	 lea	 esi, DWORD PTR [esi+ebx*4]
  0002e	89 75 fc	 mov	 DWORD PTR tv289[ebp], esi
$LN19@pqdownheap:

; 467  :         /* Set j to the smallest of the two sons: */
; 468  :         if (j < s->heap_len &&
; 469  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {

  00031	7d 3e		 jge	 SHORT $LN4@pqdownheap
  00033	8b 9c 90 60 0b
	00 00		 mov	 ebx, DWORD PTR [eax+edx*4+2912]
  0003a	8b b4 90 5c 0b
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+2908]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _tree$[ebp]
  00047	0f b7 34 b0	 movzx	 esi, WORD PTR [eax+esi*4]
  0004b	0f b7 0c 99	 movzx	 ecx, WORD PTR [ecx+ebx*4]
  0004f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00052	66 3b ce	 cmp	 cx, si
  00055	72 19		 jb	 SHORT $LN3@pqdownheap
  00057	75 18		 jne	 SHORT $LN4@pqdownheap
  00059	8b b4 90 5c 0b
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+2908]
  00060	8a 8c 03 58 14
	00 00		 mov	 cl, BYTE PTR [ebx+eax+5208]
  00067	3a 8c 06 58 14
	00 00		 cmp	 cl, BYTE PTR [esi+eax+5208]
  0006e	77 01		 ja	 SHORT $LN4@pqdownheap
$LN3@pqdownheap:

; 470  :             j++;

  00070	42		 inc	 edx
$LN4@pqdownheap:

; 471  :         }
; 472  :         /* Exit if v is smaller than both sons */
; 473  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  00071	8b b4 90 5c 0b
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+2908]
  00078	8b 4d fc	 mov	 ecx, DWORD PTR tv289[ebp]
  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR _tree$[ebp]
  0007e	0f b7 09	 movzx	 ecx, WORD PTR [ecx]
  00081	0f b7 1c b3	 movzx	 ebx, WORD PTR [ebx+esi*4]
  00085	66 3b cb	 cmp	 cx, bx
  00088	72 3c		 jb	 SHORT $LN14@pqdownheap
  0008a	8b 5d 10	 mov	 ebx, DWORD PTR _v$1$[ebp]
  0008d	75 10		 jne	 SHORT $LN2@pqdownheap
  0008f	8a 8c 03 58 14
	00 00		 mov	 cl, BYTE PTR [ebx+eax+5208]
  00096	3a 8c 06 58 14
	00 00		 cmp	 cl, BYTE PTR [esi+eax+5208]
  0009d	76 19		 jbe	 SHORT $LN16@pqdownheap
$LN2@pqdownheap:

; 474  : 
; 475  :         /* Exchange v with the smallest son */
; 476  :         s->heap[k] = s->heap[j];  k = j;

  0009f	89 b4 b8 5c 0b
	00 00		 mov	 DWORD PTR [eax+edi*4+2908], esi
  000a6	8b 88 50 14 00
	00		 mov	 ecx, DWORD PTR [eax+5200]
  000ac	8b fa		 mov	 edi, edx

; 477  : 
; 478  :         /* And continue down the tree, setting j to the left son of k */
; 479  :         j <<= 1;

  000ae	03 d2		 add	 edx, edx
  000b0	3b d1		 cmp	 edx, ecx
  000b2	0f 8e 79 ff ff
	ff		 jle	 $LN19@pqdownheap
$LN16@pqdownheap:
  000b8	5e		 pop	 esi

; 480  :     }
; 481  :     s->heap[k] = v;

  000b9	89 9c b8 5c 0b
	00 00		 mov	 DWORD PTR [eax+edi*4+2908], ebx
  000c0	5f		 pop	 edi
  000c1	5b		 pop	 ebx

; 482  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN14@pqdownheap:

; 480  :     }
; 481  :     s->heap[k] = v;

  000c6	8b 4d 10	 mov	 ecx, DWORD PTR _v$1$[ebp]
  000c9	5e		 pop	 esi
  000ca	89 8c b8 5c 0b
	00 00		 mov	 DWORD PTR [eax+edi*4+2908], ecx
  000d1	5f		 pop	 edi
  000d2	5b		 pop	 ebx

; 482  : }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
$LN15@pqdownheap:

; 480  :     }
; 481  :     s->heap[k] = v;

  000d7	89 9c b8 5c 0b
	00 00		 mov	 DWORD PTR [eax+edi*4+2908], ebx
  000de	5f		 pop	 edi
  000df	5b		 pop	 ebx

; 482  : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_pqdownheap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _init_block
_TEXT	SEGMENT
_s$ = 8							; size = 4
_init_block PROC					; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 418  :     int n; /* iterates over tree elements */
; 419  : 
; 420  :     /* Initialize the trees. */
; 421  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0000b	8d 81 94 00 00
	00		 lea	 eax, DWORD PTR [ecx+148]
  00011	56		 push	 esi
$LL9@init_block:
  00012	33 f6		 xor	 esi, esi
  00014	66 89 30	 mov	 WORD PTR [eax], si
  00017	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  0001a	4a		 dec	 edx
  0001b	75 f5		 jne	 SHORT $LL9@init_block

; 422  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0001d	8d 81 88 09 00
	00		 lea	 eax, DWORD PTR [ecx+2440]
  00023	ba 1e 00 00 00	 mov	 edx, 30			; 0000001eH
$LL6@init_block:
  00028	33 f6		 xor	 esi, esi
  0002a	66 89 30	 mov	 WORD PTR [eax], si
  0002d	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00030	4a		 dec	 edx
  00031	75 f5		 jne	 SHORT $LL6@init_block

; 423  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  00033	8d 81 7c 0a 00
	00		 lea	 eax, DWORD PTR [ecx+2684]
  00039	ba 13 00 00 00	 mov	 edx, 19			; 00000013H
  0003e	8b ff		 npad	 2
$LL3@init_block:
  00040	33 f6		 xor	 esi, esi
  00042	66 89 30	 mov	 WORD PTR [eax], si
  00045	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00048	4a		 dec	 edx
  00049	75 f5		 jne	 SHORT $LL3@init_block

; 424  : 
; 425  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 426  :     s->opt_len = s->static_len = 0L;

  00050	89 b1 ac 16 00
	00		 mov	 DWORD PTR [ecx+5804], esi
  00056	89 b1 a8 16 00
	00		 mov	 DWORD PTR [ecx+5800], esi

; 427  :     s->last_lit = s->matches = 0;

  0005c	89 b1 b0 16 00
	00		 mov	 DWORD PTR [ecx+5808], esi
  00062	89 b1 a0 16 00
	00		 mov	 DWORD PTR [ecx+5792], esi
  00068	66 89 81 94 04
	00 00		 mov	 WORD PTR [ecx+1172], ax
  0006f	5e		 pop	 esi

; 428  : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_init_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT _tr_static_init
_TEXT	SEGMENT
_tr_static_init PROC					; COMDAT

; 241  : #if defined(GEN_TREES_H) || !defined(STDC)
; 242  :     static int static_init_done = 0;
; 243  :     int n;        /* iterates over tree elements */
; 244  :     int bits;     /* bit counter */
; 245  :     int length;   /* length value */
; 246  :     int code;     /* code value */
; 247  :     int dist;     /* distance index */
; 248  :     ush bl_count[MAX_BITS+1];
; 249  :     /* number of codes at each bit length for an optimal tree */
; 250  : 
; 251  :     if (static_init_done) return;
; 252  : 
; 253  :     /* For some embedded targets, global variables are not initialized: */
; 254  : #ifdef NO_INIT_GLOBAL_POINTERS
; 255  :     static_l_desc.static_tree = static_ltree;
; 256  :     static_l_desc.extra_bits = extra_lbits;
; 257  :     static_d_desc.static_tree = static_dtree;
; 258  :     static_d_desc.extra_bits = extra_dbits;
; 259  :     static_bl_desc.extra_bits = extra_blbits;
; 260  : #endif
; 261  : 
; 262  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 263  :     length = 0;
; 264  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 265  :         base_length[code] = length;
; 266  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 267  :             _length_code[length++] = (uch)code;
; 268  :         }
; 269  :     }
; 270  :     Assert (length == 256, "tr_static_init: length != 256");
; 271  :     /* Note that the length 255 (match length 258) can be represented
; 272  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 273  :      * overwrite length_code[255] to use the best encoding:
; 274  :      */
; 275  :     _length_code[length-1] = (uch)code;
; 276  : 
; 277  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 278  :     dist = 0;
; 279  :     for (code = 0 ; code < 16; code++) {
; 280  :         base_dist[code] = dist;
; 281  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 282  :             _dist_code[dist++] = (uch)code;
; 283  :         }
; 284  :     }
; 285  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 286  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 287  :     for ( ; code < D_CODES; code++) {
; 288  :         base_dist[code] = dist << 7;
; 289  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 290  :             _dist_code[256 + dist++] = (uch)code;
; 291  :         }
; 292  :     }
; 293  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 294  : 
; 295  :     /* Construct the codes of the static literal tree */
; 296  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 297  :     n = 0;
; 298  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 299  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 300  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 301  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 302  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 303  :      * tree construction to get a canonical Huffman tree (longest code
; 304  :      * all ones)
; 305  :      */
; 306  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 307  : 
; 308  :     /* The static distance tree is trivial: */
; 309  :     for (n = 0; n < D_CODES; n++) {
; 310  :         static_dtree[n].Len = 5;
; 311  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 312  :     }
; 313  :     static_init_done = 1;
; 314  : 
; 315  : #  ifdef GEN_TREES_H
; 316  :     gen_trees_header();
; 317  : #  endif
; 318  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 319  : }

  00000	c3		 ret	 0
_tr_static_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT __tr_stored_block
_TEXT	SEGMENT
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_stored_len$ = 16					; size = 4
_last$ = 20						; size = 4
__tr_stored_block PROC					; COMDAT

; 876  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 877  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

  00004	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
  00007	8b 8f bc 16 00
	00		 mov	 ecx, DWORD PTR [edi+5820]
  0000d	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00010	7e 51		 jle	 SHORT $LN2@tr_stored_
  00012	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00015	56		 push	 esi
  00016	8b 75 14	 mov	 esi, DWORD PTR _last$[ebp]
  00019	66 8b c6	 mov	 ax, si
  0001c	66 d3 e0	 shl	 ax, cl
  0001f	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00022	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  00029	0f b6 87 b8 16
	00 00		 movzx	 eax, BYTE PTR [edi+5816]
  00030	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00033	ff 47 14	 inc	 DWORD PTR [edi+20]
  00036	0f b6 87 b9 16
	00 00		 movzx	 eax, BYTE PTR [edi+5817]
  0003d	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00040	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00043	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00046	8b 87 bc 16 00
	00		 mov	 eax, DWORD PTR [edi+5820]
  0004c	ff 47 14	 inc	 DWORD PTR [edi+20]
  0004f	b1 10		 mov	 cl, 16			; 00000010H
  00051	2a c8		 sub	 cl, al
  00053	66 d3 ee	 shr	 si, cl
  00056	83 c0 f3	 add	 eax, -13		; fffffff3H
  00059	66 89 b7 b8 16
	00 00		 mov	 WORD PTR [edi+5816], si
  00060	5e		 pop	 esi
  00061	eb 11		 jmp	 SHORT $LN5@tr_stored_
$LN2@tr_stored_:
  00063	66 8b 45 14	 mov	 ax, WORD PTR _last$[ebp]
  00067	66 d3 e0	 shl	 ax, cl
  0006a	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  00071	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
$LN5@tr_stored_:

; 878  : #ifdef DEBUG
; 879  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 880  :     s->compressed_len += (stored_len + 4) << 3;
; 881  : #endif
; 882  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  00074	6a 01		 push	 1
  00076	ff 75 10	 push	 DWORD PTR _stored_len$[ebp]
  00079	89 87 bc 16 00
	00		 mov	 DWORD PTR [edi+5820], eax
  0007f	ff 75 0c	 push	 DWORD PTR _buf$[ebp]
  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 _copy_block
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	5f		 pop	 edi

; 883  : }

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
__tr_stored_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT __tr_align
_TEXT	SEGMENT
_s$ = 8							; size = 4
__tr_align PROC						; COMDAT

; 898  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 899  :     send_bits(s, STATIC_TREES<<1, 3);

  00004	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00007	57		 push	 edi
  00008	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  0000e	bf 02 00 00 00	 mov	 edi, 2
  00013	8b c7		 mov	 eax, edi
  00015	66 d3 e0	 shl	 ax, cl
  00018	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0001f	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00022	7e 41		 jle	 SHORT $LN9@tr_align
  00024	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00027	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0002e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00031	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00034	ff 46 14	 inc	 DWORD PTR [esi+20]
  00037	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  0003e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00047	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  0004d	ff 46 14	 inc	 DWORD PTR [esi+20]
  00050	b1 10		 mov	 cl, 16			; 00000010H
  00052	8b c7		 mov	 eax, edi
  00054	2a ca		 sub	 cl, dl
  00056	66 d3 e8	 shr	 ax, cl
  00059	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  00060	8d 42 f3	 lea	 eax, DWORD PTR [edx-13]
  00063	eb 03		 jmp	 SHORT $LN13@tr_align
$LN9@tr_align:
  00065	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
$LN13@tr_align:

; 900  :     send_code(s, END_BLOCK, static_ltree);

  00068	8b c8		 mov	 ecx, eax
  0006a	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  00070	33 c0		 xor	 eax, eax
  00072	66 d3 e0	 shl	 ax, cl
  00075	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0007c	83 f9 09	 cmp	 ecx, 9
  0007f	7e 41		 jle	 SHORT $LN7@tr_align
  00081	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00084	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0008b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0008e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00091	ff 46 14	 inc	 DWORD PTR [esi+20]
  00094	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  0009b	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0009e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a1	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000a4	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  000aa	ff 46 14	 inc	 DWORD PTR [esi+20]
  000ad	b1 10		 mov	 cl, 16			; 00000010H
  000af	33 c0		 xor	 eax, eax
  000b1	2a ca		 sub	 cl, dl
  000b3	66 d3 e8	 shr	 ax, cl
  000b6	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  000bd	8d 42 f7	 lea	 eax, DWORD PTR [edx-9]
  000c0	eb 03		 jmp	 SHORT $LN14@tr_align
$LN7@tr_align:
  000c2	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
$LN14@tr_align:

; 901  : #ifdef DEBUG
; 902  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 903  : #endif
; 904  :     bi_flush(s);

  000c5	56		 push	 esi
  000c6	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  000cc	e8 00 00 00 00	 call	 _bi_flush

; 905  :     /* Of the 10 bits for the empty block, we have already sent
; 906  :      * (10 - bi_valid) bits. The lookahead for the last real code (before
; 907  :      * the EOB of the previous block) was thus at least one plus the length
; 908  :      * of the EOB plus what we have just sent of the empty static block.
; 909  :      */
; 910  :     if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {

  000d1	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  000d7	8b 86 b4 16 00
	00		 mov	 eax, DWORD PTR [esi+5812]
  000dd	2b c1		 sub	 eax, ecx
  000df	83 c0 0b	 add	 eax, 11			; 0000000bH
  000e2	83 c4 04	 add	 esp, 4
  000e5	83 f8 09	 cmp	 eax, 9
  000e8	0f 8d c9 00 00
	00		 jge	 $LN12@tr_align

; 911  :         send_bits(s, STATIC_TREES<<1, 3);

  000ee	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000f1	7e 4b		 jle	 SHORT $LN4@tr_align
  000f3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000f6	8b c7		 mov	 eax, edi
  000f8	66 d3 e0	 shl	 ax, cl
  000fb	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000fe	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  00105	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0010c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0010f	ff 46 14	 inc	 DWORD PTR [esi+20]
  00112	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  00119	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0011c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0011f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00122	8b 86 bc 16 00
	00		 mov	 eax, DWORD PTR [esi+5820]
  00128	ff 46 14	 inc	 DWORD PTR [esi+20]
  0012b	b1 10		 mov	 cl, 16			; 00000010H
  0012d	2a c8		 sub	 cl, al
  0012f	66 d3 ef	 shr	 di, cl
  00132	83 c0 f3	 add	 eax, -13		; fffffff3H
  00135	66 89 be b8 16
	00 00		 mov	 WORD PTR [esi+5816], di
  0013c	eb 0d		 jmp	 SHORT $LN15@tr_align
$LN4@tr_align:
  0013e	66 d3 e7	 shl	 di, cl
  00141	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00144	66 09 be b8 16
	00 00		 or	 WORD PTR [esi+5816], di
$LN15@tr_align:

; 912  :         send_code(s, END_BLOCK, static_ltree);

  0014b	8b c8		 mov	 ecx, eax
  0014d	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  00153	33 c0		 xor	 eax, eax
  00155	66 d3 e0	 shl	 ax, cl
  00158	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0015f	83 f9 09	 cmp	 ecx, 9
  00162	7e 41		 jle	 SHORT $LN2@tr_align
  00164	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00167	0f b6 86 b8 16
	00 00		 movzx	 eax, BYTE PTR [esi+5816]
  0016e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00171	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00174	ff 46 14	 inc	 DWORD PTR [esi+20]
  00177	0f b6 86 b9 16
	00 00		 movzx	 eax, BYTE PTR [esi+5817]
  0017e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00184	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00187	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  0018d	ff 46 14	 inc	 DWORD PTR [esi+20]
  00190	b1 10		 mov	 cl, 16			; 00000010H
  00192	33 c0		 xor	 eax, eax
  00194	2a ca		 sub	 cl, dl
  00196	66 d3 e8	 shr	 ax, cl
  00199	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  001a0	8d 42 f7	 lea	 eax, DWORD PTR [edx-9]
  001a3	eb 03		 jmp	 SHORT $LN16@tr_align
$LN2@tr_align:
  001a5	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
$LN16@tr_align:

; 913  : #ifdef DEBUG
; 914  :         s->compressed_len += 10L;
; 915  : #endif
; 916  :         bi_flush(s);

  001a8	56		 push	 esi
  001a9	89 86 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], eax
  001af	e8 00 00 00 00	 call	 _bi_flush
  001b4	83 c4 04	 add	 esp, 4
$LN12@tr_align:

; 917  :     }
; 918  :     s->last_eob_len = 7;

  001b7	5f		 pop	 edi
  001b8	c7 86 b4 16 00
	00 07 00 00 00	 mov	 DWORD PTR [esi+5812], 7
  001c2	5e		 pop	 esi

; 919  : }

  001c3	5d		 pop	 ebp
  001c4	c3		 ret	 0
__tr_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT __tr_flush_block
_TEXT	SEGMENT
_max_blindex$1$ = -4					; size = 4
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_stored_len$ = 16					; size = 4
_last$ = 20						; size = 4
__tr_flush_block PROC					; COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 931  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 932  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */
; 933  : 
; 934  :     /* Build the Huffman trees unless a stored block is forced */
; 935  :     if (s->level > 0) {

  00006	8b 75 10	 mov	 esi, DWORD PTR _stored_len$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _max_blindex$1$[ebp], 0
  00014	83 bf 84 00 00
	00 00		 cmp	 DWORD PTR [edi+132], 0
  0001b	7e 58		 jle	 SHORT $LN14@tr_flush_b

; 936  : 
; 937  :         /* Check if the file is binary or text */
; 938  :         if (s->strm->data_type == Z_UNKNOWN)

  0001d	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0001f	83 7b 2c 02	 cmp	 DWORD PTR [ebx+44], 2
  00023	75 0c		 jne	 SHORT $LN13@tr_flush_b

; 939  :             s->strm->data_type = detect_data_type(s);

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 _detect_data_type
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
$LN13@tr_flush_b:

; 940  : 
; 941  :         /* Construct the literal and distance trees */
; 942  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  00031	8d 87 18 0b 00
	00		 lea	 eax, DWORD PTR [edi+2840]
  00037	50		 push	 eax
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 _build_tree

; 943  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 944  :                 s->static_len));
; 945  : 
; 946  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  0003e	8d 87 24 0b 00
	00		 lea	 eax, DWORD PTR [edi+2852]
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	e8 00 00 00 00	 call	 _build_tree

; 947  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 948  :                 s->static_len));
; 949  :         /* At this point, opt_len and static_len are the total bit lengths of
; 950  :          * the compressed block data, excluding the tree representations.
; 951  :          */
; 952  : 
; 953  :         /* Build the bit length tree for the above two trees, and get the index
; 954  :          * in bl_order of the last bit length code to send.
; 955  :          */
; 956  :         max_blindex = build_bl_tree(s);

  0004b	57		 push	 edi
  0004c	e8 00 00 00 00	 call	 _build_bl_tree

; 957  : 
; 958  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 959  :         opt_lenb = (s->opt_len+3+7)>>3;

  00051	8b 8f a8 16 00
	00		 mov	 ecx, DWORD PTR [edi+5800]

; 960  :         static_lenb = (s->static_len+3+7)>>3;

  00057	8b 97 ac 16 00
	00		 mov	 edx, DWORD PTR [edi+5804]
  0005d	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00060	83 c2 0a	 add	 edx, 10			; 0000000aH
  00063	c1 e9 03	 shr	 ecx, 3
  00066	c1 ea 03	 shr	 edx, 3
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	89 45 fc	 mov	 DWORD PTR _max_blindex$1$[ebp], eax

; 961  : 
; 962  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 963  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 964  :                 s->last_lit));
; 965  : 
; 966  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

  0006f	3b d1		 cmp	 edx, ecx
  00071	77 07		 ja	 SHORT $LN11@tr_flush_b

; 967  : 
; 968  :     } else {

  00073	eb 03		 jmp	 SHORT $LN17@tr_flush_b
$LN14@tr_flush_b:

; 969  :         Assert(buf != (char*)0, "lost buf");
; 970  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  00075	8d 56 05	 lea	 edx, DWORD PTR [esi+5]
$LN17@tr_flush_b:
  00078	8b ca		 mov	 ecx, edx
$LN11@tr_flush_b:

; 971  :     }
; 972  : 
; 973  : #ifdef FORCE_STORED
; 974  :     if (buf != (char*)0) { /* force stored block */
; 975  : #else
; 976  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  0007a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0007d	3b c1		 cmp	 eax, ecx
  0007f	77 1b		 ja	 SHORT $LN10@tr_flush_b
  00081	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00084	85 c0		 test	 eax, eax
  00086	74 14		 je	 SHORT $LN10@tr_flush_b

; 977  :                        /* 4: two words for the lengths */
; 978  : #endif
; 979  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 980  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 981  :          * the last block flush, because compression would have been
; 982  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 983  :          * transform a block into a stored block.
; 984  :          */
; 985  :         _tr_stored_block(s, buf, stored_len, last);

  00088	8b 5d 14	 mov	 ebx, DWORD PTR _last$[ebp]
  0008b	53		 push	 ebx
  0008c	56		 push	 esi
  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 __tr_stored_block
  00094	83 c4 10	 add	 esp, 16			; 00000010H
  00097	e9 45 01 00 00	 jmp	 $LN4@tr_flush_b
$LN10@tr_flush_b:

; 986  : 
; 987  : #ifdef FORCE_STATIC
; 988  :     } else if (static_lenb >= 0) { /* force static trees */
; 989  : #else
; 990  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

  0009c	83 bf 88 00 00
	00 04		 cmp	 DWORD PTR [edi+136], 4
  000a3	0f 84 b2 00 00
	00		 je	 $LN7@tr_flush_b
  000a9	3b d1		 cmp	 edx, ecx
  000ab	0f 84 aa 00 00
	00		 je	 $LN7@tr_flush_b

; 994  : #ifdef DEBUG
; 995  :         s->compressed_len += 3 + s->static_len;
; 996  : #endif
; 997  :     } else {
; 998  :         send_bits(s, (DYN_TREES<<1)+last, 3);

  000b1	8b 8f bc 16 00
	00		 mov	 ecx, DWORD PTR [edi+5820]
  000b7	8b 5d 14	 mov	 ebx, DWORD PTR _last$[ebp]
  000ba	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000bd	7e 4f		 jle	 SHORT $LN3@tr_flush_b
  000bf	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  000c2	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  000c5	66 8b c6	 mov	 ax, si
  000c8	66 d3 e0	 shl	 ax, cl
  000cb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000ce	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  000d5	0f b6 87 b8 16
	00 00		 movzx	 eax, BYTE PTR [edi+5816]
  000dc	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000df	ff 47 14	 inc	 DWORD PTR [edi+20]
  000e2	0f b6 87 b9 16
	00 00		 movzx	 eax, BYTE PTR [edi+5817]
  000e9	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  000ec	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000ef	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000f2	8b 87 bc 16 00
	00		 mov	 eax, DWORD PTR [edi+5820]
  000f8	ff 47 14	 inc	 DWORD PTR [edi+20]
  000fb	b1 10		 mov	 cl, 16			; 00000010H
  000fd	2a c8		 sub	 cl, al
  000ff	66 d3 ee	 shr	 si, cl
  00102	83 c0 f3	 add	 eax, -13		; fffffff3H
  00105	66 89 b7 b8 16
	00 00		 mov	 WORD PTR [edi+5816], si
  0010c	eb 10		 jmp	 SHORT $LN18@tr_flush_b
$LN3@tr_flush_b:
  0010e	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00111	66 d3 e0	 shl	 ax, cl
  00114	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  0011b	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
$LN18@tr_flush_b:
  0011e	89 87 bc 16 00
	00		 mov	 DWORD PTR [edi+5820], eax

; 999  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
; 1000 :                        max_blindex+1);

  00124	8b 45 fc	 mov	 eax, DWORD PTR _max_blindex$1$[ebp]
  00127	40		 inc	 eax
  00128	50		 push	 eax
  00129	8b 87 28 0b 00
	00		 mov	 eax, DWORD PTR [edi+2856]
  0012f	40		 inc	 eax
  00130	50		 push	 eax
  00131	8b 87 1c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2844]
  00137	40		 inc	 eax
  00138	50		 push	 eax
  00139	57		 push	 edi
  0013a	e8 00 00 00 00	 call	 _send_all_trees

; 1001 :         compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);

  0013f	8d 87 88 09 00
	00		 lea	 eax, DWORD PTR [edi+2440]
  00145	50		 push	 eax
  00146	8d 87 94 00 00
	00		 lea	 eax, DWORD PTR [edi+148]
  0014c	50		 push	 eax
  0014d	57		 push	 edi
  0014e	e8 00 00 00 00	 call	 _compress_block
  00153	83 c4 1c	 add	 esp, 28			; 0000001cH
  00156	e9 86 00 00 00	 jmp	 $LN4@tr_flush_b
$LN7@tr_flush_b:

; 991  : #endif
; 992  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

  0015b	8b 8f bc 16 00
	00		 mov	 ecx, DWORD PTR [edi+5820]
  00161	8b 5d 14	 mov	 ebx, DWORD PTR _last$[ebp]
  00164	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00167	7e 4f		 jle	 SHORT $LN6@tr_flush_b
  00169	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0016c	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  0016f	66 8b c6	 mov	 ax, si
  00172	66 d3 e0	 shl	 ax, cl
  00175	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00178	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  0017f	0f b6 87 b8 16
	00 00		 movzx	 eax, BYTE PTR [edi+5816]
  00186	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00189	ff 47 14	 inc	 DWORD PTR [edi+20]
  0018c	0f b6 87 b9 16
	00 00		 movzx	 eax, BYTE PTR [edi+5817]
  00193	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00196	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00199	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0019c	8b 87 bc 16 00
	00		 mov	 eax, DWORD PTR [edi+5820]
  001a2	ff 47 14	 inc	 DWORD PTR [edi+20]
  001a5	b1 10		 mov	 cl, 16			; 00000010H
  001a7	2a c8		 sub	 cl, al
  001a9	66 d3 ee	 shr	 si, cl
  001ac	83 c0 f3	 add	 eax, -13		; fffffff3H
  001af	66 89 b7 b8 16
	00 00		 mov	 WORD PTR [edi+5816], si
  001b6	eb 10		 jmp	 SHORT $LN19@tr_flush_b
$LN6@tr_flush_b:
  001b8	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  001bb	66 d3 e0	 shl	 ax, cl
  001be	66 09 87 b8 16
	00 00		 or	 WORD PTR [edi+5816], ax
  001c5	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
$LN19@tr_flush_b:

; 993  :         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);

  001c8	68 00 00 00 00	 push	 OFFSET _static_dtree
  001cd	68 00 00 00 00	 push	 OFFSET _static_ltree
  001d2	57		 push	 edi
  001d3	89 87 bc 16 00
	00		 mov	 DWORD PTR [edi+5820], eax
  001d9	e8 00 00 00 00	 call	 _compress_block
  001de	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@tr_flush_b:

; 1002 : #ifdef DEBUG
; 1003 :         s->compressed_len += 3 + s->opt_len;
; 1004 : #endif
; 1005 :     }
; 1006 :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 1007 :     /* The above check is made mod 2^32, for files larger than 512 MB
; 1008 :      * and uLong implemented on 32 bits.
; 1009 :      */
; 1010 :     init_block(s);

  001e1	57		 push	 edi
  001e2	e8 00 00 00 00	 call	 _init_block
  001e7	83 c4 04	 add	 esp, 4

; 1011 : 
; 1012 :     if (last) {

  001ea	85 db		 test	 ebx, ebx
  001ec	74 09		 je	 SHORT $LN1@tr_flush_b

; 1013 :         bi_windup(s);

  001ee	57		 push	 edi
  001ef	e8 00 00 00 00	 call	 _bi_windup
  001f4	83 c4 04	 add	 esp, 4
$LN1@tr_flush_b:
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx

; 1014 : #ifdef DEBUG
; 1015 :         s->compressed_len += 7;  /* align on byte boundary */
; 1016 : #endif
; 1017 :     }
; 1018 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1019 :            s->compressed_len-7*last));
; 1020 : }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
__tr_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT __tr_tally
_TEXT	SEGMENT
_s$ = 8							; size = 4
_dist$ = 12						; size = 4
_lc$ = 16						; size = 4
__tr_tally PROC						; COMDAT

; 1030 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1031 :     s->d_buf[s->last_lit] = (ush)dist;

  00003	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00006	53		 push	 ebx
  00007	8b 8a a0 16 00
	00		 mov	 ecx, DWORD PTR [edx+5792]
  0000d	8b 82 a4 16 00
	00		 mov	 eax, DWORD PTR [edx+5796]

; 1032 :     s->l_buf[s->last_lit++] = (uch)lc;

  00013	8b 5d 10	 mov	 ebx, DWORD PTR _lc$[ebp]
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _dist$[ebp]
  0001a	66 89 34 48	 mov	 WORD PTR [eax+ecx*2], si
  0001e	8b 82 a0 16 00
	00		 mov	 eax, DWORD PTR [edx+5792]
  00024	8b 8a 98 16 00
	00		 mov	 ecx, DWORD PTR [edx+5784]
  0002a	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  0002d	ff 82 a0 16 00
	00		 inc	 DWORD PTR [edx+5792]

; 1033 :     if (dist == 0) {

  00033	85 f6		 test	 esi, esi
  00035	75 0a		 jne	 SHORT $LN2@tr_tally

; 1034 :         /* lc is the unmatched char */
; 1035 :         s->dyn_ltree[lc].Freq++;

  00037	66 ff 84 9a 94
	00 00 00	 inc	 WORD PTR [edx+ebx*4+148]

; 1036 :     } else {

  0003f	eb 39		 jmp	 SHORT $LN1@tr_tally
$LN2@tr_tally:

; 1037 :         s->matches++;

  00041	ff 82 b0 16 00
	00		 inc	 DWORD PTR [edx+5808]

; 1038 :         /* Here, lc is the match length - MIN_MATCH */
; 1039 :         dist--;             /* dist = match distance - 1 */
; 1040 :         Assert((ush)dist < (ush)MAX_DIST(s) &&
; 1041 :                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
; 1042 :                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
; 1043 : 
; 1044 :         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;

  00047	0f b6 83 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[ebx]
  0004e	4e		 dec	 esi
  0004f	66 ff 84 82 98
	04 00 00	 inc	 WORD PTR [edx+eax*4+1176]

; 1045 :         s->dyn_dtree[d_code(dist)].Freq++;

  00057	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  0005d	73 09		 jae	 SHORT $LN5@tr_tally
  0005f	0f b6 86 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[esi]
  00066	eb 0a		 jmp	 SHORT $LN6@tr_tally
$LN5@tr_tally:
  00068	c1 ee 07	 shr	 esi, 7
  0006b	0f b6 86 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[esi+256]
$LN6@tr_tally:
  00072	66 ff 84 82 88
	09 00 00	 inc	 WORD PTR [edx+eax*4+2440]
$LN1@tr_tally:

; 1046 :     }
; 1047 : 
; 1048 : #ifdef TRUNCATE_BLOCK
; 1049 :     /* Try to guess if it is profitable to stop the current block here */
; 1050 :     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
; 1051 :         /* Compute an upper bound for the compressed length */
; 1052 :         ulg out_length = (ulg)s->last_lit*8L;
; 1053 :         ulg in_length = (ulg)((long)s->strstart - s->block_start);
; 1054 :         int dcode;
; 1055 :         for (dcode = 0; dcode < D_CODES; dcode++) {
; 1056 :             out_length += (ulg)s->dyn_dtree[dcode].Freq *
; 1057 :                 (5L+extra_dbits[dcode]);
; 1058 :         }
; 1059 :         out_length >>= 3;
; 1060 :         Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
; 1061 :                s->last_lit, in_length, out_length,
; 1062 :                100L - out_length*100L/in_length));
; 1063 :         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
; 1064 :     }
; 1065 : #endif
; 1066 :     return (s->last_lit == s->lit_bufsize-1);

  0007a	8b 8a 9c 16 00
	00		 mov	 ecx, DWORD PTR [edx+5788]
  00080	49		 dec	 ecx
  00081	33 c0		 xor	 eax, eax
  00083	39 8a a0 16 00
	00		 cmp	 DWORD PTR [edx+5792], ecx
  00089	5e		 pop	 esi
  0008a	0f 94 c0	 sete	 al
  0008d	5b		 pop	 ebx

; 1067 :     /* We avoid equality with lit_bufsize because of wraparound at 64K
; 1068 :      * on 16 bit machines and because stored blocks are restricted to
; 1069 :      * 64K-1 bytes.
; 1070 :      */
; 1071 : }

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
__tr_tally ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\mattia\desktop\audio plugin developement\esempi\compzocchiogui 2.10\zlib\trees.c
;	COMDAT __tr_init
_TEXT	SEGMENT
_s$ = 8							; size = 4
__tr_init PROC						; COMDAT

; 388  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 389  :     tr_static_init();
; 390  : 
; 391  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00006	8d 81 94 00 00
	00		 lea	 eax, DWORD PTR [ecx+148]
  0000c	89 81 18 0b 00
	00		 mov	 DWORD PTR [ecx+2840], eax

; 392  :     s->l_desc.stat_desc = &static_l_desc;
; 393  : 
; 394  :     s->d_desc.dyn_tree = s->dyn_dtree;

  00012	8d 81 88 09 00
	00		 lea	 eax, DWORD PTR [ecx+2440]
  00018	89 81 24 0b 00
	00		 mov	 DWORD PTR [ecx+2852], eax

; 395  :     s->d_desc.stat_desc = &static_d_desc;
; 396  : 
; 397  :     s->bl_desc.dyn_tree = s->bl_tree;

  0001e	8d 81 7c 0a 00
	00		 lea	 eax, DWORD PTR [ecx+2684]
  00024	89 81 30 0b 00
	00		 mov	 DWORD PTR [ecx+2864], eax

; 398  :     s->bl_desc.stat_desc = &static_bl_desc;
; 399  : 
; 400  :     s->bi_buf = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	c7 81 20 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2848], OFFSET _static_l_desc
  00036	c7 81 2c 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2860], OFFSET _static_d_desc
  00040	c7 81 38 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2872], OFFSET _static_bl_desc
  0004a	66 89 81 b8 16
	00 00		 mov	 WORD PTR [ecx+5816], ax

; 401  :     s->bi_valid = 0;

  00051	89 81 bc 16 00
	00		 mov	 DWORD PTR [ecx+5820], eax

; 402  :     s->last_eob_len = 8; /* enough lookahead for inflate */

  00057	c7 81 b4 16 00
	00 08 00 00 00	 mov	 DWORD PTR [ecx+5812], 8

; 403  : #ifdef DEBUG
; 404  :     s->compressed_len = 0L;
; 405  :     s->bits_sent = 0L;
; 406  : #endif
; 407  : 
; 408  :     /* Initialize the first block of the first file: */
; 409  :     init_block(s);

  00061	89 4d 08	 mov	 DWORD PTR _s$[ebp], ecx

; 410  : }

  00064	5d		 pop	 ebp

; 403  : #ifdef DEBUG
; 404  :     s->compressed_len = 0L;
; 405  :     s->bits_sent = 0L;
; 406  : #endif
; 407  : 
; 408  :     /* Initialize the first block of the first file: */
; 409  :     init_block(s);

  00065	e9 00 00 00 00	 jmp	 _init_block
__tr_init ENDP
_TEXT	ENDS
END
